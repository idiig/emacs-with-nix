#+title: 基于 Nix Flakes 的 Emacs 配置
#+author: idiig
#+setupfile: https://fniessen.github.io/org-html-themes/org/theme-bigblow.setup
* 本配置
:PROPERTIES:
:header-args: :tangle no
:END:
** 目的
这份配置文件的特色是使用 Nix Flakes 同时管理 emacs 的包和 emacs 在使用
过程中会调用的外部程序。使用这个方法的主要目的是有以下理由：
- 同时协同 emacs 插件和其依赖的外部工具 ::
  emacs 内置的包管理器无法管理系统级别工具，比如用于检索的
  =consult-ripgrep= 会寻找可运行的 =ripgrep= 调用。这样我需要脱离 elisp 的设
  定文件去下载这个外部工具。还有很多编程语言也有这个问题。我的习惯是希
  望针对特定的项目文件夹定制所需的环境（比如使用 nix 和.dir-locals.el）。
  但是，类似于语言服务器这类本质与项目无关，但与我的编辑环境有关的设定，
  我倾向于使用与项目无关的环境。
** 其他方式做不到的
目前不依赖 emacs 的其他包管理工具的其他方式也有一些：
- git 子模块 ::
  这种方式可以管理 emacs 包，而且可以灵活的更新和回滚版本。但是这个方
  法也同样不方便整合系统级别的依赖。
- =twist.nix= 等基于 nix 的方法 ::
  在 nix 文件里写配置的话，确实可以使用 =${pkgs.xxx}= 的方式使用系统工具
  避免，在配置文件外单独下载。但完全使用 nix 的话，写配置的方式更新快，
  个人希望尽可能使用 elisp 的方式写配置。
** 本配置的做法
这份配置的解决法如下：
- 通过 org-babel 同时写 nix 和 elisp。前者用于版本，emacs 包，依赖的系
  统工具的管理，后者用于 emacs 本身的配置的管理。
- 可以在 elisp 中用 =$pkgs.git= 的方式直接引用Nix的包。
** 目前的缺点
目前使用下，这个配置方式也有一些缺点：
- 添加系统工具的时候，需要重启调试过程繁琐
- 依赖的系统工具多了以后，占用容量大
- nixpkgs 里的工具相对滞后，新包加入慢  
* 实现方式
:PROPERTIES:
:header-args: :tangle no
:END:
下面以配置 =Magit= 为例说明这个配置的方法。这里和大多数的配置一样我们把
整体目的一致的包放在一个集群实现。每个集群主要分成两个子节点，一个用于
安装包和依赖项，另一个用于配置包本身。

依赖的部分可以从 =pkgs= (=nixpkgs.legacyPackages.${system}=) 同时安装emacs
外部依赖（系统工具如 =git= ）。然后从 =epkgs=
(=pkgs.emacs.pkgs.withPackages=) 中安装emacs 的包。

这里稍微多做一些解释。在配置节里面，我利用了org-babel的一些文学编程特
性。首先我们在一个入口代码块中使用了 =:noweb=yes= [fn:lit-prog]。然后在
后面的代码块中我们使用 =:noweb-ref= 参照入口代码块，最后后续的这些代码块
都会在 =org-babel-tangle= (=C-c C-v C-t=) 时合并到这个入口代码块中输出为
flake.nix。

[fn:lit-prog] 关于文学编程中 =noweb= 的解释可以参考 [[https://www.cs.tufts.edu/~nr/noweb/][这个链接]] 。本身我们
还有一个=:session= 的方式更适合一些数据科学的工作流。这里我们主要为了和
=:以前使用。
* 如何使用
:PROPERTIES:
:header-args: :tangle no
:END:
用emacs打开本文档， =M-x org-babel-tangle= 或使用快捷键 =C-c C-v t= 生成
flake.nix。接下去运行可以通过在终端运行下面进行调试和版本回滚：
** 调试
#+begin_src sh
  export NIXPKGS_ALLOW_UNFREE=1	# allow unfree packages
  nix run <path/to/this/config> \	# replace <path/to/this/config> with the actual path
      --impure \			# use impure mode
      --extra-experimental-features nix-command \ # enable nix-command feature
      --extra-experimental-features flakes # enable flakes feature
  source ~/.bashrc			 # source bash configuration
  ne			     # starts emacs with the new configuration
#+end_src
** 版本回滚
*** 使用git
#+begin_src sh
  git checkout <previous-commit>
  nix run <path/to/this/config> \	# replace <path/to/this/config> with the actual path
      --impure \			# use impure mode
      --extra-experimental-features nix-command \ # enable nix-command feature
      --extra-experimental-features flakes # enable flakes feature
  source ~/.bashrc			 # source bash configuration
  ne			     # starts emacs with the new configuration
#+end_src
*** 备份lock文件
#+begin_src sh
  nix flake metadata		# check flake metadata
  cp flake.lock flake.lock.bachup	# backup current lock file
  nix run --recreate-lock-file --inputs-from ./flake.lock.backup # recreate lock file
#+end_src
* 配置入口 (=flake.nix=)
包的安装基于下面的 =flake.nix= 。可以看到这里使用了几个占位符：
- =<<epkgs>>= :: 这里放置 emacs 包的列表
- =<<ecfg>>= :: 这里放置 emacs 的配置代码
- =<<emacs-early-init-config>>= :: 这里放置 emacs 的 early-init 配置代码
- =<<externals>>= :: 这里放置外部包的定义

这些占位符会在后续的代码块中被替换。  
#+BEGIN_SRC nix :tangle flake.nix :noweb yes
  {
    description = "idiig's Emacs Configuration with Nix Flakes";

    inputs = {
      nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
      flake-utils.url = "github:numtide/flake-utils";
      emacs-overlay.url = "github:nix-community/emacs-overlay";
      <<externals>>
    };

    outputs = inputs@{ self, nixpkgs, flake-utils, emacs-overlay, ... }:
      let
        # 用于安装非 nixpkgs 元的外部包的函数
        mkPackages = pkgs: emacsPackages: import ./externals {
          inherit inputs pkgs emacsPackages;
        };
      in
        flake-utils.lib.eachDefaultSystem (system:
  	      let
            
  		      pkgs = import nixpkgs {
  			      inherit system;
  			      overlays = [ emacs-overlay.overlay ];
  		      };

  		      # 主配置文件
  		      emacsConfig = pkgs.writeText "init.el" ''
  	    <<ecfg>>
  	    '';

  		      # early-init 配置文件
  		      emacsEarlyInitConfig = pkgs.writeText "early-init.el" ''
  	    <<emacs-early-init-config>>
  	    '';

            # 首先定义你的基础 Emacs
            emacs = pkgs.emacs30-gtk3;

            # 定义覆盖函数
            overrides = final: prev: mkPackages pkgs final;
            
            # 创建扩展的包集合并选择包
            emacsWithPackages = ((pkgs.emacsPackagesFor emacs).overrideScope overrides).withPackages (epkgs: with epkgs; [
              <<epkgs>>
            ]);
            
  	      in {
  		      packages.default = pkgs.writeShellScriptBin "script" ''
  	      #!/usr/bin/env bash
  	      set -e

  	      # 导出配置到 nix-emacs
  	      EMACS_DIR="$HOME/nix-emacs"
  	      mkdir -p "$EMACS_DIR"
  	      ${pkgs.rsync}/bin/rsync ${emacsConfig} "$EMACS_DIR/init.el"
  	      ${pkgs.rsync}/bin/rsync ${emacsEarlyInitConfig} "$EMACS_DIR/early-init.el"

  	      # 路径
  	      <<sys-path>>

  	      # 更新 Emacs 路径（兼容 macOS 和 Linux）
          if sed --version 2>/dev/null | grep "(GNU sed)"; then
  		      sed -i '/^alias ne=/d' "$HOME/.bashrc"
  	      else
  		      sed -i \"\" '/^alias ne=/d' "$HOME/.bashrc"
  	      fi

  	      echo "alias ne='QT_QUICK_BACKEND=software LIBGL_ALWAYS_SOFTWARE=1 ${emacsWithPackages}/bin/emacs --init-dir \"$EMACS_DIR\"'" >> "$HOME/.bashrc"

  	      # 提示用户手动 source 而不是直接执行，以避免 shell 继承问题
  	      echo "请手动运行 'source ~/.bashrc' 以使 alias 生效"
  	      echo "Emacs 配置已同步到 $EMACS_DIR"
  	      '';  
  	      });
  }
#+END_SRC

* 配置本体
:PROPERTIES:
:header-args: :tangle no
:END:
** Early-init
:PROPERTIES:
:header-args: :noweb-ref emacs-early-init-config
:END:
#+begin_src emacs-lisp
  ;; 增加 GC 阈值，加快启动
  (setq gc-cons-threshold 402653184 gc-cons-percentage 0.6)

  ;; 启动完成后恢复正常 GC 设定
  (add-hook 'emacs-startup-hook
  	  (lambda ()
  	    (setq gc-cons-threshold 10485760
  		  gc-cons-percentage 0.1)))

  ;; 禁用bidi，加速大文件
  (setq-default bidi-display-reordering nil)
  (setq bidi-inhibit-bpa t
        long-line-threshold 1000
        large-hscroll-threshold 1000
        syntax-wholeline-max 1000)
#+end_src
** Emacs基建
*** Mac OS 键位设定
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  ;; 在mac中使用Command key作为meta
  (setq mac-option-key-is-meta nil
        mac-command-key-is-meta t
        mac-command-modifier 'meta
        mac-option-modifier 'none)

  ;; 便于使用mac的JIS日语键盘
  (global-set-key (kbd "C-¥") 'toggle-input-method)
#+end_src
*** 包管理和其他基础
这里我考虑了到底是否要使用 =use-package= 。因为我现在在使用 org mode写配
置文件的目的是希望可以穿插自然语言的代码描述，所以需要拆分代码。
=use-package= 这种一体成型的写法不是很适合这种风格。但考虑了实际写的过程，
我觉得大多数情况可以在配置代码前面作完整的整理，而不需要过于细粒度的代
码表述，然后在迁移的过程可能也比较简单。所以我最后还是决定改成使用
=use-package= 了。
**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
- =use-package= ：用简介的宏语言描述包
- =diminish= ：用于隐藏一些 minor mode
#+begin_src nix
  use-package
    diminish
#+end_src
**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (require 'use-package)
  (require 'diminish)
#+end_src
*** 更好的默认设置
**** 取消装饰物 (=tool-bar-mode=, =menu-bar-mode=, =scroll-bar-mode=, built-in)
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
关闭工具栏，菜单，滑动控件。必要时可手动开启。
#+begin_src emacs-lisp
  ;; Useful decorations nil
  (tool-bar-mode -1)			; 关闭工具栏
  (menu-bar-mode -1)			; 关闭工具栏
  (scroll-bar-mode -1)			; 关闭文件滑动控件
#+end_src
**** 关闭提示音 (=C source code=)
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
#+end_src
**** 简短回答是否选项 (=C source code=)
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (setq use-short-answers t)
#+end_src
**** 干净的启动画面 (=startup=, built-in)
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
启动后只留下纯净的 =*Scratch*= 页面。
#+begin_src emacs-lisp
  (setq inhibit-splash-screen 1)     ; 关闭启动帮助画面
  (setq initial-scratch-message nil) ; 关闭scratch message
  (setq inhibit-startup-message t)   ; 关闭启动信息
#+end_src
**** 优化长文档卡顿 (=so-long=, built-in)
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
启用 =so-long-mode= 自动检测包含超长行的文件(如压缩后的 JavaScript、JSON
等),并自动禁用可能导致性能问题的功能(如语法高亮、行号显示等),避免
Emacs 在处理这类文件时出现卡顿或假死现象。
#+begin_src emacs-lisp
  (use-package so-long
    :init
    (global-so-long-mode +1))
#+end_src
**** 更符合直觉地删除选中内容 (=delsel=, built-in)
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
选中文字能在粘贴时被整体替换（与其他文本编辑器相同）。
#+begin_src emacs-lisp
  (use-package delsel
    :custom
    (delete-selection-mode t))
#+end_src
**** 外部变更时自动在编辑器内反映变更 (=autorevert=, built-in)
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
文件在外部更新时buffer更新。
#+begin_src emacs-lisp
  (use-package autorevert
    :custom
    (global-auto-revert-mode t))
#+end_src
**** 框架最大化与框架显示信息 (=frame=, built-in)
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
- *初始框架最大化* ::
  设置 Emacs 启动时自动以最大化状态显示窗口（而非全屏模式）
- *框架标题显示优化* ::
  自定义框架标题格式,显示 "idiig - " 前缀,后接当前文件的完整路径(如果
  是文件)或缓冲区名称(如果不是文件)。文件路径会使用缩写形式(如 =~/= 代替
  家目录),便于快速识别当前编辑的文件位置
#+begin_src emacs-lisp
;; frame.el
(use-package frame
  :init
  (setq initial-frame-alist '((fullscreen . maximized)))	; 全屏
  (setq frame-title-format ; 窗口显示文件路径/buffer名
      '("" " idiig - "
        (:eval (if (buffer-file-name)
                   (abbreviate-file-name (buffer-file-name)) "%b")))))

#+end_src
**** 更好的新窗口弹出，移动和缩放行为 (=window=, built-in)
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
***** 更符合直觉的窗口大小调整
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
- *按键代表边界移动的方向* ::
   =C-[^, {, }]= 默认代表窗口的放大与缩小，但在上方窗口按 ~^~ 时，我期望两
  个窗口的边界向上移动（即缩小上方窗口）,但实际上 =enlarge-window= 会让
  上方窗口变大（边界向下移动），这点不符合直觉。这里设计成按键代表边界
  移动的方向，而不是当前窗口的放大/缩小方向。
#+begin_src emacs-lisp
  (use-package window
    :bind
    (([remap enlarge-window] . idiig/smart-adjust-window-size-up)
     ([remap shrink-window] . idiig/smart-adjust-window-size-down)
     ([remap shrink-window-horizontally] . idiig/smart-adjust-window-size-left)
     ([remap enlarge-window-horizontally] . idiig/smart-adjust-window-size-right))
    
    :init
    (defun idiig/smart-adjust-window-size (direction &optional delta horizontal)
      "Intelligently adjust window size based on window position.
  DIRECTION: 'up, 'down, 'left, 'right indicates border movement direction
  DELTA: adjustment size, default is 5
  HORIZONTAL: whether to adjust horizontally"
      (let ((delta (or delta 5)))
        (pcase direction
  	;; Vertical adjustment
  	('up
  	 (cond
            ;; If there's a window below, shrink current window (border moves up)
            ((window-in-direction 'below)
             (shrink-window delta nil))
            ;; If there's a window above, enlarge current window (border moves up)
            ((window-in-direction 'above)
             (enlarge-window delta nil))
            (t (message "Cannot adjust window upward"))))
  	
  	('down
  	 (cond
            ;; If there's a window below, enlarge current window (border moves down)
            ((window-in-direction 'below)
             (enlarge-window delta nil))
            ;; If there's a window above, shrink current window (border moves down)
            ((window-in-direction 'above)
             (shrink-window delta nil))
            (t (message "Cannot adjust window downward"))))
  	
  	;; Horizontal adjustment
  	('left
  	 (cond
            ;; If there's a window on the right, shrink current window (border moves left)
            ((window-in-direction 'right)
             (shrink-window delta t))
            ;; If there's a window on the left, enlarge current window (border moves left)
            ((window-in-direction 'left)
             (enlarge-window delta t))
            (t (message "Cannot adjust window leftward"))))
  	
  	('right
  	 (cond
            ;; If there's a window on the right, enlarge current window (border moves right)
            ((window-in-direction 'right)
             (enlarge-window delta t))
            ;; If there's a window on the left, shrink current window (border moves right)
            ((window-in-direction 'left)
             (shrink-window delta t))
            (t (message "Cannot adjust window rightward")))))))
    
    ;; Define convenience commands
    (defun idiig/smart-adjust-window-size-up (&optional delta)
      "Move border upward"
      (interactive "P")
      (idiig/smart-adjust-window-size 'up (or delta 5)))

    (defun idiig/smart-adjust-window-size-down (&optional delta)
      "Move border downward"
      (interactive "P")
      (idiig/smart-adjust-window-size 'down (or delta 5)))

    (defun idiig/smart-adjust-window-size-left (&optional delta)
      "Move border leftward"
      (interactive "P")
      (idiig/smart-adjust-window-size 'left (or delta 5)))

    (defun idiig/smart-adjust-window-size-right (&optional delta)
      "Move border rightward"
      (interactive "P")
      (idiig/smart-adjust-window-size 'right (or delta 5))))
#+end_src
- 窗口的放大缩小转变为持续的行为 ::
  默认行为中放大缩小需要不断反复按 =C-x= 。这里为了避免重复按 =C-x= ，后续
  行为使用默认 =^, V, {, }= 持续调节边界的位置达到放大缩小窗口的。这里我
  没用 =C-x v= 是因为这个键位目前用于 =vc= 的默认快捷键。
#+begin_src emacs-lisp
  (use-package window
    :init
    ;; Add transient map support
    (defun idiig/smart-adjust-window-size-advice (orig-fun direction &rest args)
      "Add continuous adjustment support for idiig/smart-adjust-window-size"
      (let ((delta (or (car args) 5)))
        ;; Execute initial adjustment
        (apply orig-fun direction args)
        
        ;; Set transient map
        (set-transient-map
         (let ((map (make-sparse-keymap)))
  	 ;; ^ = border moves up
  	 (define-key map (kbd "^")
  		     `(lambda () (interactive) (idiig/smart-adjust-window-size 'up ,delta)))
  	 ;; V = border moves down
  	 (define-key map (kbd "V")
  		     `(lambda () (interactive) (idiig/smart-adjust-window-size 'down ,delta)))
  	 ;; { = border moves left
  	 (define-key map (kbd "{")
  		     `(lambda () (interactive) (idiig/smart-adjust-window-size 'left ,delta)))
  	 ;; } = border moves right
  	 (define-key map (kbd "}")
  		     `(lambda () (interactive) (idiig/smart-adjust-window-size 'right ,delta)))
  	 ;; + = balance windows
  	 (define-key map (kbd "+")
  		     (lambda () (interactive) (balance-windows)))
  	 ;; M = maximize
  	 (define-key map (kbd "M")
  		     (lambda () (interactive) (maximize-window)))
  	 ;; m = minimize
  	 (define-key map (kbd "m")
  		     (lambda () (interactive) (minimize-window)))
  	 map)
         nil nil
         "Use %k for further adjustment")))

    :config
    ;; Apply advice
    (advice-add 'idiig/smart-adjust-window-size :around #'idiig/smart-adjust-window-size-advice))
#+end_src
***** 分割新窗口时转跳到新窗口
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (defadvice split-window-below (after split-window-below-and-switch activate)
    "切换到新分割的窗口"
    (when (called-interactively-p 'any)
      (other-window 1)))

  (defadvice split-window-right (after split-window-right-and-switch activate)
    "切换到新分割的窗口"
    (when (called-interactively-p 'any)
      (other-window 1)))
#+end_src
***** =display-buffer= 行为
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
- *智能缓冲区切换* ::
  默认情况下 =switch-to-buffer= (C-x b) 总是在当前窗口替换显示新缓冲区。
  启用 =switch-to-buffer-obey-display-actions= 后，切换行为会遵循更智能的
  显示规则，例如某些特殊缓冲区会自动在侧边栏或底部显示
- *保护专用窗口* ::
  某些窗口被标记为"专用"(dedicated)，用于显示特定内容(如终端、REPL 等)。
  设置为 =pop= 后，在这些窗口中尝试切换缓冲区时会弹出新窗口，而非覆盖原内
  容，保持工作区布局稳定。专用 buffer（ =display-buffer= 行为；主要影响
  Emacs自动创建的窗口，如 =*help*= 等）。注意这里也会影响到 =magit= 这类
  transient 窗口
- *避免重复显示* ::
  当打开一个已在其他窗口显示的缓冲区时，优先跳转到该窗口而非创建新窗口。
  这样可以避免同一文件在多个窗口中重复出现，保持界面整洁

#+begin_src emacs-lisp
  (use-package window
    :custom
    ;; 缓冲区显示优先级:
    ;; 1. 复用已显示该缓冲区的窗口(避免重复显示)
    ;; 2. 在当前窗口显示
    ;; 3. 可跨不同 frame 查找可复用的窗口
    (display-buffer-base-action
     '((display-buffer-reuse-window display-buffer-same-window)
       (reusable-frames . t)))
    
    ;; 让缓冲区切换遵循智能显示规则
    (switch-to-buffer-obey-display-actions t)
    
    ;; 在专用窗口中切换缓冲区时弹出新窗口，保护原窗口内容
    (switch-to-buffer-in-dedicated-window 'pop))
#+end_src
**** 更好的文档相关行为 (=file=, built-in)
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
- *禁用自动备份* ::
  关闭 Emacs 默认的备份文件生成功能,不会在编辑文件时创建 =filename~= 格
  式的备份文件,保持目录整洁。如果需要版本控制,建议使用 Git 等专业工具
- *文件末尾强制换行* ::
  保存文件时自动在文件末尾添加换行符,符合 POSIX 标准和大多数编程规范。
  避免某些工具(如 Git)显示"文件末尾缺少换行符"的警告
- *保存时智能创建目录* ::
  保存文件时,如果父目录不存在会弹出询问是否创建。确认后自动创建所需的
  目录层级,避免因目录不存在导致保存失败
- *打开文件时自动创建目录* ::
  使用 =C-x C-f= 打开不存在的文件时,如果其父目录也不存在,会自动创建所需
  的目录结构,无需手动创建目录后再打开文件
#+begin_src emacs-lisp
  (use-package files
    :init
    (setq make-backup-files nil)		; 不自动生成备份文件
    (setq require-final-newline t)	; 文件最后添加新行
    :config
    ;; 不存在文档时询问是否新建
    (add-hook 'before-save-hook
              (lambda ()
                (when buffer-file-name
  		(let ((dir (file-name-directory buffer-file-name)))
                    (when (and (not (file-exists-p dir))
                               (y-or-n-p (format "Directory %s does not exist. Create it?" dir)))
                      (make-directory dir t))))))

    ;; 找文件时若无母文档则新建 
    (defadvice find-file (before make-directory-maybe
                                 (filename &optional wildcards) activate)
      "Create parent directory if not exists while visiting file."
      (unless (file-exists-p filename)
        (let ((dir (file-name-directory filename)))
  	(when dir
            (unless (file-exists-p dir)
              (make-directory dir t)))))))
#+end_src
**** 记录和读取最近打开的文档 (=recentf=, built-in)
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
- *最近文件记录* ::
  启用 =recentf-mode= 记录最近打开的文件,保存最多 500 个文件历史(显示前 10 个),
  方便快速重新打开常用文件。可配合 =consult-recent-file= 等命令快速访问
- *排除特定文件类型* ::
  自动过滤不需要记录的文件,包括:
  - Git 提交信息文件(=COMMIT_MSG= 等)
  - 临时文件(/tmp/ 目录)
  - sudo 编辑的文件
  - 标签文件(TAGS、GTAGS 等)
  - 媒体文件(视频、音频、字幕)
  - 图片文件(PNG 等)
  - 书签文件
- *退出时清理文件列表* ::
  关闭 Emacs 时自动清理已不存在的文件，保持最近文件列表的准确性，避免
  列表中出现已删除的文件路径
#+begin_src emacs-lisp
  (use-package recentf
    :defer t
    :commands (consult-recent-file)
    :init
    (recentf-mode 1)
    :custom
    ;; Save location and limits
    (recentf-save-file (expand-file-name "recentf" user-emacs-directory))
    (recentf-max-saved-items 2048)    ; Maximum number of recent files to save
    (recentf-max-menu-items 10)       ; Number of items to show in menu
    
    ;; Exclude files that shouldn't be tracked
    (recentf-exclude
     '(;; Version control
       "COMMIT_MSG" "COMMIT_EDITMSG" "github.*txt$"
       ;; System files
       "/tmp/" "/sudo:"
       ;; Tag files
       "/TAGS$" "/GTAGS$" "/GRAGS$" "/GPATH$"
       ;; Media files
       "\\.mkv$" "\\.mp[34]$" "\\.avi$"
       "\\.sub$" "\\.srt$" "\\.ass$"
       ;; Images
       ".*png$"
       ;; Other
       "bookmarks"))
    
    :hook
    ;; Clean up non-existent files when exiting Emacs
    (kill-emacs . idiig/cleanup-recentf)
    
    :config
    (defun idiig/cleanup-recentf ()
      "Remove non-existent files from recent files list."
      (when (fboundp 'recentf-cleanup)
        (recentf-cleanup))))
#+end_src

**** 保存书签到配置独立目录 (=bookmark=, built-in)
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (use-package bookmark
    :init
    (setq bookmark-default-file (expand-file-name "bookmarks" user-emacs-directory)
          bookmark-save-flag 1))
#+end_src
**** Mark 命令重复优化 (=simple=, built-in)
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
使 =C-u C-SPC= 命令后可以直接用 =C-SPC= 继续弹出 mark，无需重复输入 =C-u= 。
更快的输入方式: =C-u C-SPC, C-SPC, C-SPC= 而非 =C-u C-SPC, C-u C-SPC, C-u
C-SPC= 。
#+begin_src emacs-lisp
  (use-package simple
    :custom
    (set-mark-command-repeat-pop t))
#+end_src
**** 打开时自动到原先编辑的位置 (=saveplace=, built-in)
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
保存文件的编辑位置
#+begin_src emacs-lisp
  (use-package saveplace
    :init
    (setq save-place-file (expand-file-name "place" user-emacs-directory))
    (save-place-mode 1))
#+end_src

**** 保留历史记录 (=savehist-mode=, built-in)
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
默认 =savehist-mode= 只保存 minibuffer 历史，通过
=savehist-additional-variables= 可以保存更多变量(如 =kill-ring= 和
=register-alist=)，使其在 Emacs 会话间持久化。
#+begin_src emacs-lisp
  (use-package savehist
    :init
    (setq savehist-additional-variables '(search-ring ; 扩展历史记录保存：搜索历史
  					regexp-search-ring ; 正则搜索历史
  					register-alist	   ; 寄存器
  					kill-ring)	   ; 剪切板历史
          savehist-autosave-interval 60	; 每一分钟保存一次
          savehist-file (expand-file-name "savehist" user-emacs-directory)) ; 保存文件位置
    (savehist-mode t))			; 启用 savehist 模式
#+end_src

**** 更好的文件管理器 (=Dired=, built-in)
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (use-package dired
    :commands (dired dired-jump)
    :custom
    ;; Use human-readable file sizes and group directories first
    (dired-listing-switches "-AGFhlv --group-directories-first --time-style=long-iso")
    
    ;; Intelligently guess target directory for operations (e.g., in split windows)
    (dired-dwim-target t)
    
    ;; Always delete and copy directories recursively
    (dired-recursive-deletes 'always)
    (dired-recursive-copies 'always)
    
    ;; Move files to trash instead of permanent deletion
    (delete-by-moving-to-trash t)
    
    ;; Auto-revert dired buffer when directory contents change
    (dired-auto-revert-buffer t)

    ;; i-search should search file names only
    (dired-isearch-filenames t)
    
    :hook
    ;; Enable auto-revert and highlight current line in dired buffers
    (dired-mode . (lambda ()
                    (auto-revert-mode 1)
                    (hl-line-mode 1)))
    
    :config
    ;; Enable 'a' key to open directories in same buffer instead of creating new ones
    (put 'dired-find-alternate-file 'disabled nil))
#+end_src
**** 更合理的括号与配对行为 (=elec-pair=, =paren=, built-in)
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
***** 括号自动匹配 (=elec-pair=)
- *自动括号配对* ::
  启用 =electric-pair-mode= 自动补全成对的括号、引号等符号。输入左括号时
  自动插入右括号，并将光标置于中间，提高编码效率
- *配对行为设置* ::
  - 禁用括号平衡检查(=electric-pair-preserve-balance=)，允许在不平衡的情
    况下也能插入配对符号
  - 使用保守的抑制策略，在某些上下文(如字符串、注释内)中智能判断是否需
    要配对
- *模式特定配对* ::
  定义 =idiig/add-local-electric-pairs= 函数，可为特定模式添加自定义的配
  对符号。例如在 org 模式中为数学公式添加 =$= 符号的配对
- *禁用尖括号配对* ::
  特别禁用 =<>= 的自动配对，避免在编写 HTML、XML 或比较运算符时产生干扰
#+begin_src emacs-lisp
  (use-package elec-pair
    :custom
    ;; Disable balance checking - allow pairing even when unbalanced
    (electric-pair-preserve-balance nil)
    
    ;; Use conservative inhibit strategy for smart context detection
    (electric-pair-inhibit-predicate 'electric-pair-conservative-inhibit)
    
    :config
    ;; Enable automatic bracket pairing
    (electric-pair-mode 1)
    
    ;; Save default pairs for creating mode-specific local settings
    (defconst idiig/default-electric-pairs electric-pair-pairs
      "Default electric pair settings to use as base for local pairs.")
    
    (defun idiig/add-local-electric-pairs (pairs)
      "Add local electric pairs for the current buffer.
         
  Arguments:
    PAIRS: List of character pairs to add
         
  Example usage:
    (add-hook 'jupyter-org-interaction-mode-hook
              (lambda () (idiig/add-local-electric-pairs '((?$ . ?$)))))"
      (setq-local electric-pair-pairs (append idiig/default-electric-pairs pairs)
                  electric-pair-text-pairs electric-pair-pairs))
    
    ;; Disable auto-pairing for angle brackets <>
    (add-function :before-until electric-pair-inhibit-predicate
                  (lambda (c) (eq c ?<))))
#+end_src
***** 括号高亮 (=paren=)
- *括号匹配高亮* ::
  启用 =show-paren-mode= 自动高亮匹配的括号对，帮助快速识别代码块的范围和
  嵌套关系
- *增强的括号高亮* ::
  默认情况下，只有当光标直接位于括号上时才会高亮匹配的括号对。通过增强
  函数，即使光标位于括号内部(如括号包围的代码中间)，也能高亮显示当前所在
  的最内层括号对，更容易理解代码结构
#+BEGIN_SRC elisp
(use-package paren
  :config
  ;; Enable bracket matching highlight
  (show-paren-mode 1)
  
  ;; Enhanced bracket matching - highlight even when cursor is inside brackets
  (define-advice show-paren-function (:around (fn) fix-show-paren-function)
    "Highlight matching brackets even when cursor is not directly on a bracket.
When cursor is inside a bracketed expression, highlight the innermost
enclosing bracket pair."
    (cond ((looking-at-p "\\s(") (funcall fn))
          (t (save-excursion
               (ignore-errors (backward-up-list))
               (funcall fn))))))
#+END_SRC
**** 便利的光标首尾移动 (=mwim=)
***** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  mwim
#+end_src
***** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
*mwim*: 跳到代码之前而非最前，或者代码后面而不是最后
#+begin_src emacs-lisp
  (use-package mwim
    :bind
    ("C-a" . mwim-beginning-of-code-or-line-or-comment)
    ("C-e" . mwim-end-of-code-or-line)
    :commands
    (mwim-beginning-of-code-or-line-or-comment
     mwim-end-of-code-or-line))
#+end_src

**** 折行与复原 (=unfill=)
***** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  unfill
#+end_src
***** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
- 物理折行与复原
#+begin_src emacs-lisp
  (use-package unfill
    :bind
    ("M-q" . unfill-toggle)
    :commands
    (unfill-toggle))
#+end_src
**** 更好的minibuffer
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
***** 原生设定
- *completing-read-multiple 提示增强* ::
  为多选补全命令添加视觉提示符,在 minibuffer 中显示分隔符信息(例如
  =[CRM,]=),让使用者知道可以输入多个选项
- *Minibuffer 提示区保护* ::
  使 minibuffer 的提示文字变为只读,防止光标进入提示区域,避免误编辑提示
  文字
- *递归 Minibuffer* ::
  允许在 minibuffer 中再次调用需要 minibuffer 的命令,适合复杂的工作流
  程(例如在搜索文件时可以再次调用 M-x)
- *命令过滤(Emacs 28+)* ::
  在 =M-x= 界面中仅显示与当前 mode 相关的命令,保持补全界面的简洁性和情境
  相关性
- *鼠标离开时关闭 Minibuffer* ::
  当使用鼠标切换到其他缓冲区时自动关闭 minibuffer,避免 minibuffer 卡住
  的状态,适合经常使用鼠标操作的工作流程
  
#+begin_src emacs-lisp
  (use-package emacs
    :init
    ;; Add prompt indicator for `completing-read-multiple'
    ;; e.g., [CRM<separator>] in the minibuffer
    (defun crm-indicator (args)
      "Add a visual indicator showing the separator for `completing-read-multiple'."
      (cons (format "[CRM%s] %s"
                    (replace-regexp-in-string
                     "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                     crm-separator)
                    (car args))
            (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    :hook
    ;; Prevent cursor from entering minibuffer prompt area
    (minibuffer-setup . cursor-intangible-mode)
    
    ;; Close minibuffer when mouse leaves buffer (useful for mouse-heavy workflows)
    ;; Source: http://trey-jackson.blogspot.com/2010/04/emacs-tip-36-abort-minibuffer-when.html
    (mouse-leave-buffer . idiig/stop-using-minibuffer)

    :custom
    ;; Make minibuffer prompt read-only and prevent cursor from entering it
    (minibuffer-prompt-properties
     '(read-only t cursor-intangible t face minibuffer-prompt))
    
    ;; Enable recursive minibuffers (useful for complex workflows)
    (enable-recursive-minibuffers t)
    
    ;; In Emacs 28+, hide commands not relevant to current mode
    ;; This keeps the M-x interface clean and contextual
    (read-extended-command-predicate #'command-completion-default-include-p)

    :config
    (defun idiig/stop-using-minibuffer ()
      "Abort minibuffer when switching to another buffer with mouse.
  Useful for preventing stuck minibuffer states during mouse operations."
      (when (and (>= (recursion-depth) 1) 
                 (active-minibuffer-window))
        (abort-recursive-edit))))
#+end_src
***** 基础五件套
****** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  vertico
    orderless
    marginalia
    embark
    consult
    embark-consult
#+end_src

****** 配置
******* *Vertico*: 提供minibuffer补全UI
#+begin_src emacs-lisp
  (use-package vertico
    :after consult
    :custom
    (vertico-count 9)
    (vertico-cycle t)
    :init
    (vertico-mode))
#+end_src
******* *Orderless*: 提供补全格式选择
#+begin_src emacs-lisp
  (use-package orderless
    :after
    (consult)
    :init
    (defvar +orderless-dispatch-alist
    '((?% . char-fold-to-regexp)    ; %word% - 字符折叠匹配
      (?! . orderless-without-literal) ; !word! - 排除匹配
      (?`. orderless-initialism)    ; `word` - 首字母匹配
      (?= . orderless-literal)      ; =word= - 字面匹配
      (?~ . orderless-flex)))	  ; ~word~ - 弹性匹配
    :config
    (setq search-default-mode t)
    
    (defun +orderless--suffix-regexp ()
      (if (and (boundp 'consult--tofu-char) (boundp 'consult--tofu-range))
          (format "[%c-%c]*$"
                  consult--tofu-char
                  (+ consult--tofu-char consult--tofu-range -1))
        "$"))
    ;; Recognizes the following patterns:
    ;; * ~flex flex~
    ;; * =literal literal=
    ;; * %char-fold char-fold%
    ;; * `initialism initialism`
    ;; * !without-literal without-literal!
    ;; * .ext (file extension)
    ;; * regexp$ (regexp matching at end)
    (defun +orderless-dispatch (word _index _total)
      (cond
       ;; Ensure that $ works with Consult commands, which add disambiguation suffixes
       ((string-suffix-p "$" word)
        `(orderless-regexp . ,(concat (substring word 0 -1) (+orderless--suffix-regexp))))
       ;; File extensions
       ((and (or minibuffer-completing-file-name
                 (derived-mode-p 'eshell-mode))
             (string-match-p "\\`\\.." word))
        `(orderless-regexp . ,(concat "\\." (substring word 1) (+orderless--suffix-regexp))))
       ;; Ignore single !
       ((equal "!" word) `(orderless-literal . ""))
       ;; Prefix and suffix
       ((if-let (x (assq (aref word 0) +orderless-dispatch-alist))
            (cons (cdr x) (substring word 1))
          (when-let (x (assq (aref word (1- (length word))) +orderless-dispatch-alist))
            (cons (cdr x) (substring word 0 -1)))))))
    
    ;; Define orderless style with initialism by default ; add migemo feature for japanese
    (orderless-define-completion-style +orderless-with-initialism
      (orderless-matching-styles '(orderless-initialism
                                   orderless-literal
                                   orderless-regexp)))
    
    (setq completion-styles '(orderless basic)
          completion-category-defaults nil
          ;;; Enable partial-completion for files.
          ;;; Either give orderless precedence or partial-completion.
          ;;; Note that completion-category-overrides is not really an override,
          ;;; but rather prepended to the default completion-styles.
          ;; completion-category-overrides '((file (styles orderless partial-completion))) ;; orderless is tried first
          completion-category-overrides '((file (styles partial-completion)) ;; partial-completion is tried first
                                          (buffer (styles +orderless-with-initialism))
                                          (consult-location (styles +orderless-with-initialism))
                                          ;; enable initialism by default for symbols
                                          (command (styles +orderless-with-initialism))
                                          (variable (styles +orderless-with-initialism))
                                          (symbol (styles +orderless-with-initialism)))
          orderless-component-separator #'orderless-escapable-split-on-space ;; allow escaping space with backslash!
          orderless-style-dispatchers '(+orderless-dispatch)))
#+end_src
******* *Maginalia*: 增强minubuffer的annotation
#+begin_src emacs-lisp
  (use-package marginalia
    :after vertico
    ;; 只在minibuffer启用快捷键
    :bind (:map minibuffer-local-map ("M-A" . marginalia-cycle))
    :init
    (setq marginalia-align-offset 5)
    :config
    (marginalia-mode))
#+end_src
******* *Consult*: 增强minibuffer的检索
#+begin_src emacs-lisp
  (use-package consult
    :hook (after-init . (lambda () (require 'consult)))
    :bind (([remap M-x] . execute-extended-command)
           ([remap goto-line] . consult-goto-line)
           ([remap switch-to-buffer] . consult-buffer)
           ([remap find-file] . find-file)
  	 ([remap imenu] . consult-imenu)
           ("C-c r" . consult-recent-file)
           ("C-c y" . consult-yasnippet)
           ("C-c f" . consult-find)
           ("C-c s" . consult-line)
           ("C-c o" . consult-file-externally)
           ("C-c p f" . consult-ripgrep)
           (:map minibuffer-local-map
                 ("C-c h" . consult-history)
                 ("C-s" . #'previous-history-element)))
    :init
    (add-to-list 'exec-path "${pkgs.fd}/bin")
    (add-to-list 'exec-path "${pkgs.ripgrep}/bin")
    (defun idiig/consult-buffer-region-or-symbol ()
      "consult-line当前字符或选中区域."
      (interactive)
      (let ((input (if (region-active-p)
                       (buffer-substring-no-properties
                        (region-beginning) (region-end))
                     (thing-at-point 'symbol t))))
        (consult-line input)))
    (defun idiig/consult-project-region-or-symbol (&optional default-inputp)
      "consult-ripgrep 当前字符或选中区域."
      (interactive)
      (let ((input (if (region-active-p)
                       (buffer-substring-no-properties
                        (region-beginning) (region-end))
                     (thing-at-point 'symbol t))))
        (consult-ripgrep default-inputp input)))
    :config
    (progn
      ;; (defvar my-consult-line-map
      ;;   (let ((map (make-sparse-keymap)))
      ;;     (define-key map "C-s" #'previous-history-element)
      ;;     map))
      ;; (consult-customize consult-line :keymap my-consult-line-map)
      ;; ;; 禁止自动显示consult文件的内容
      (setq consult-preview-key "C-v")
      ;; 应用 Orderless 的正则解析到 consult-grep/ripgrep/find
      (defun consult--orderless-regexp-compiler (input type &rest _config)
        (setq input (orderless-pattern-compiler input))
        (cons
         (mapcar (lambda (r) (consult--convert-regexp r type)) input)
         (lambda (str) (orderless--highlight input str))))
      ;; 表示的buffer种类
      (defcustom consult-buffer-sources
        '(consult--source-hidden-buffer
          consult--source-buffer
          consult--source-file
          consult--source-bookmark
          consult--source-project-buffer
          consult--source-project-file)
        "Sources used by `consult-buffer'. See `consult--multi' for a description of the source values."
        :type '(repeat symbol))
      ;; ？提示检索buffer类型；f<SPC>=file, p<SPC>=project, etc..
      (define-key consult-narrow-map
  		(vconcat consult-narrow-key "?") #'consult-narrow-help)))
#+end_src
******* *Embark*: minibuffer action 和自适应的context menu
#+begin_src emacs-lisp
  (use-package embark
    :after vertico
    :bind
    (("C-h B" . embark-bindings)  ;; alternative for `describe-bindings'
     (:map minibuffer-local-map
           ("C-'" . embark-act)         ;; 对函数进行设置操作 
           ("M-." . embark-dwim)        ;; 实施 
           ("C-c C-e" . embark-export))) ;; occur 
    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)
    :config
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))

  ;; embark-export弹出occur和grep mode的buffer
  (use-package embark-consult
    :ensure t
    :after (consult))
#+end_src
                
**** 撤销 (=vundo=)
我原来使用 undotree ，现在使用 vundo。这些用于视觉化撤销树。这里我之绑
定了 =C-x u= ， =C-/= 我依然用的原生的 Undo，这样适合区分使用。
***** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix 
  vundo
#+end_src
***** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (use-package vundo
    :defer t
    :commands
    (vundo)
    :bind
    ("C-x u" . vundo))
#+end_src
**** 检索
***** =I-search= (built-in)
#+begin_src emacs-lisp
  (use-package isearch
    :custom
    (isearch-lazy-count t) 		; Enable lazy count in isearch
    (lazy-count-prefix-format "(%s/%s) ") ; Set prefix format for lazy count
    (lazy-count-suffix-format nil) ; No suffix format for lazy count
    (search-whitespace-regexp ".*?")) ; Make spaces match any whitespace in searches
#+end_src
***** =Ctrlf=
针对当前 buffer 利用 =Ctrlf= 而不在使用 =swiper= 和 =helm= 这类型的检索方式。
用于替代 =isearch= 的 =C-s= 键。另外的选项是 =consult-line= ，我映射到了 =C-c
s= 键位，用于不移动当前位置预览检索行，尤其是在类似与 org 存在折叠的情
况下，我不需要移动光标和展开折叠。关于 =consult= ，可见[[**Consult*: 增强minibuffer的检索][*Consult*: 增强
minibuffer的检索]]。
****** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix 
  ctrlf
#+end_src
****** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
******* 启动 =ctrf=
#+begin_src emacs-lisp
  (require 'ctrlf)
  (ctrlf-mode +1)
#+end_src
******* 切换检索风格
#+begin_src emacs-lisp
  (with-eval-after-load 'ctrlf
    
    ;; 定义 advice 函数
    (defun ctrlf-set-default-style-advice (style)
      "Advice function to set the default search style when changing styles.
  This ensures the selected style becomes the new default for future sessions."
      (setq ctrlf-default-search-style style))
    
    ;; 添加 advice
    (advice-add 'ctrlf-change-search-style :after #'ctrlf-set-default-style-advice))
#+end_src
**** 直接在grep检索页面编辑 (=wgrep=)
在 =grep=, =ag=, =ripgrep= 等检索的结果中按下 =e= 进入编辑模式，按下 =C-c C-c=
完成修改。
***** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  wgrep
#+end_src
***** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (use-package wgrep
    :commands occur-mode
    :config
    (setq wgrep-auto-save-buffer t)
    (setq wgrep-enable-key "e"))
#+end_src
**** 语言无关的结构化编程 (=puni=)
***** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  puni
#+end_src
***** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp :noweb yes
  (use-package puni
    :defer t
    :bind
    (:map puni-mode-map
    	([remap puni-kill-line] . idiig/puni-kill-line)
    	("C--" . idiig/puni-contract-region)
    	("C-=" . puni-expand-region))
    :init
    ;; The autoloads of Puni are set up so you can enable `puni-mode` or
    ;; `puni-global-mode` before `puni` is actually loaded. Only after you press
    ;; any key that calls Puni commands, it's loaded.
    (puni-global-mode)
    (add-hook 'term-mode-hook #'puni-disable-puni-mode)
    :config
    <<idiig/puni-kill-line>>
    <<idiig/puni-contract-region>>
    <<idiig/puni-expand-region-advice>>
  )
#+end_src
****** =puni-kill-line=
基于 =puni= 更改 =kill-line= ，在删除行的时候可以确认是否被包围在某个环境
中。如果被包围在某个环境中则删除到该环境的最后，如果没有则正常执行
=kill-line= 。
#+begin_src emacs-lisp :noweb-ref idiig/puni-kill-line
  (defun idiig/puni-kill-line (&optional n)
    "Kill a line forward while keeping expressions balanced.
  If forward kill is not possible, try backward. If still nothing
  can be deleted, kill the balanced expression around point."
    (interactive "p")
    (let ((bounds (puni-bounds-of-list-around-point)))
      (cond
       ;; Case 1: No list bounds found, try deleting surrounding sexp
       ((null bounds)
        (when-let ((sexp-bounds (puni-bounds-of-sexp-around-point)))
          (puni-delete-region (car sexp-bounds) (cdr sexp-bounds) 'kill)))

       ;; Case 2: Point is at end of bounds, try backward kill
       ((eq (point) (cdr bounds))
        (puni-backward-kill-line))

       ;; Case 3: Default forward kill
       (t
        (puni-kill-line n)))))
#+end_src
****** =idiig/puni-contract-region=
如无选中则保持 negative-argument,如有选中则缩小范围
#+begin_src emacs-lisp  :noweb-ref idiig/puni-contract-region 
  (defun idiig/puni-contract-region (&optional arg)
    "如无选中则保持 negative-argument,如有选中则缩小范围"
    (interactive "p")
    (if (region-active-p)
        (call-interactively #'puni-contract-region)
      (negative-argument arg)))
#+end_src

#+begin_src emacs-lisp
  ;; 添加 advice
  (with-eval-after-load 'puni
    (defun idiig/puni-expand-region-advice (orig-fun &rest args)
      "使用选中后的操作"
      
      (let* ((ev last-command-event)
             (echo-keystrokes nil))
        ;; 执行初始调整
        (apply orig-fun args)

        ;; 设置 transient map
        (let ((delta (car args))) 
  	(set-transient-map
  	 (let ((map (make-sparse-keymap)))
             ;; 持续扩大
             (define-key map (kbd "=") 'puni-expand-region)
             ;; 缩小范围
             (define-key map (kbd "-") 'puni-contract-region)
  	   ;; 其他操作
  	   ;; 检索
             (define-key map (kbd "/") 'idiig/consult-project-region-or-symbol)
             (define-key map (kbd "b") 'idiig/consult-buffer-region-or-symbol)
  	   ;; 加包围
  	   (define-key map (kbd ")") 'puni-wrap-round)
             (define-key map (kbd "]") 'puni-wrap-square)
  	   (define-key map (kbd "}") 'puni-wrap-curly)
  	   (define-key map (kbd ">") 'puni-wrap-angle)
  	   map)
  	 nil nil
  	 "Use %k for further adjustment"))))
    (advice-add 'puni-expand-region :around #'idiig/puni-expand-region-advice))
#+end_src
**** 覆盖 =<Backspace>= 和 =<DEL>= 等删除动作
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
***** =backward-hungry-delete=
向后删除时向后贪婪地删除连续的空白值。同时考虑对称的结构。
- 首先检查光标前面是否有连续的空白字符。
- 使用 =looking-back= 用于判断满足以下任何一个条件：
  - 光标之前在当前行是否有符合正则表达式 =(+ blank)= 的字符序列。
  - 光标是否在行首 =(bolp)= 。
- 如果有连续的空白字符或在行首：
  - 使用 =skip-chars-backward= 向后跳过这些字符，并记录开始位置 =start= 。
  - 然后 =delete-region= 用于删除从 =start= 到当前光标位置之间的字符。
#+begin_src emacs-lisp
  (defun idiig/backward-hungry-delete-advice (orig-fun &rest args)
    "Advice function to provide hungry delete functionality."
    (if (or (looking-back (rx (+ blank))) (bolp))
        (let ((start (save-excursion (skip-chars-backward " \t\f\n\r\v") (point))))
          (delete-region start (point)))
      (apply orig-fun args)))

  (defun idiig/apply-backward-hungry-delete-advice ()
    "Reapply the hungry delete advice to the current DEL key binding function."
    (let ((current-fun (key-binding (kbd "DEL"))))
      (advice-remove current-fun #'idiig/backward-hungry-delete-advice)    ; 移除旧的 advice
      (advice-add current-fun :around #'idiig/backward-hungry-delete-advice))) ; 应用新的 advice

  ;; 在 emacs-startup 时应用 advice
  (add-hook 'emacs-startup-hook #'idiig/apply-backward-hungry-delete-advice)

  ;; 如果你有其他 hook 如打开某种模式时，需要重新应用 advice，可添加对应 hook，例如：
  ;; (add-hook 'your-major-mode-hook #'idiig/reapply-backward-hungry-delete-advice)
#+end_src
***** =forward-hungry-delete=
向前删除时向前贪婪地删除连续的空白值。同时考虑对称的结构。
- 检查光标后的字符：
  - 使用 =looking-at= 判断光标后面的字符是否是一个或多个空白字符或换行符。
  - 如果匹配到，使用 =skip-chars-forward= 跳过所有这些字符并记录结束位置。
  - 使用 =delete-region= 删除从当前光标位置到记录的结束位置之间的所有空白。
- 字符删除逻辑：
  - 如果光标后没有多余的空白字符，使用 =dotimes= 循环和 =puni-forward-delete-char= 删除 =n= 个普通字符。
  - =unless (eobp)=: 确保在没有到达缓冲区末尾时进行字符删除，防止出现试图超出缓冲区范围的错误。
#+begin_src emacs-lisp
  (defun idiig/forward-hungry-delete-advice (orig-fun &rest args)
    "Advice function to provide forward hungry delete functionality."
    (if (looking-at (rx (or (1+ blank) "\n")))
        (let ((end (save-excursion
                     (skip-chars-forward " \t\f\v\n\r")
                     (point))))
          (delete-region (point) end))
      (apply orig-fun args)))

  (defun idiig/apply-forward-hungry-delete-advice ()
    "Apply the forward hungry delete advice to the current forward delete key binding function."
    (let ((current-fun (key-binding (kbd "C-d"))))
      (advice-remove current-fun #'idiig/forward-hungry-delete-advice) ; 移除旧的 advice
      (advice-add current-fun :around #'idiig/forward-hungry-delete-advice))) ; 应用新的 advice

  ;; 在 emacs-startup 时应用 advice
  (add-hook 'emacs-startup-hook #'idiig/apply-forward-hungry-delete-advice)

  ;; 如果你有其他 hook 需要重新应用 advice，可添加对应 hook，例如：
  ;; (add-hook 'your-major-mode-hook #'idiig/apply-forward-hungry-delete-advice)
#+end_src
***** =backward-kill-word-or-region=
如无选中则杀掉前面的单词，如有选中则杀掉选中区域。
#+begin_src emacs-lisp
  (defun idiig/backward-kill-word-or-region-advice (orig-fun &rest args)
    "Enhance the C-w function to handle region more flexibly."
    (if (region-active-p)
        ;; 当有选中区域时，使用传递的参数调用原始C-w功能（例如 `puni-kill-region`）
        (apply orig-fun args)
      ;; 当没有选中区域时，执行删除单词操作
      (let ((backward-kill-word-fun (or (key-binding (kbd "M-<DEL>"))
                                        (key-binding (kbd "S-<delete>"))
                                        'backward-kill-word))) ; 默认删除单词函数
        (if (fboundp backward-kill-word-fun)
            (call-interactively backward-kill-word-fun) ; 交互式调用删除单词
          (message "No word kill bound function found for M-<DEL> or S-<delete>")))))

  (defun idiig/apply-backward-kill-word-or-region-advice ()
    "Advice C-w to optionally kill region or word."
    ;; 通过 `key-binding` 得到当前与 C-w 绑定的函数
    (let ((current-fun (key-binding (kbd "C-w"))))
      (advice-remove current-fun #'idiig/backward-kill-word-or-region-advice)
      (advice-add current-fun :around #'idiig/backward-kill-word-or-region-advice)))

  ;; 在 emacs 启动时应用这个 advice
  (add-hook 'emacs-startup-hook #'idiig/apply-backward-kill-word-or-region-advice)
#+end_src
** CJK字体
这里我统一使用的是Sarasa的等宽字体，可以避免2个问题：
- 输入latin以后输入cjk文字以后，由于字体高度不等导致行高抖动
- 方便org等表格等宽表示
*** 依赖
:PROPERTIES:
:header-args: :noweb-ref sys-path
:END:
#+begin_src sh
  if [ "$(uname)" = "Darwin" ]; then
      # macOS
      mkdir -p "$HOME/Library/Fonts/"
      ${pkgs.rsync}/bin/rsync -av ${pkgs.sarasa-gothic}/share/fonts/truetype/ "$HOME/Library/Fonts/"
  else
      # Assume Linux
      mkdir -p "$HOME/.local/share/fonts/truetype/"
      ${pkgs.rsync}/bin/rsync -av ${pkgs.sarasa-gothic}/share/fonts/truetype/ "$HOME/.local/share/fonts/sarasa-gothic/"
      fc-cache -f -v ~/.local/share/fonts/
  fi
#+end_src

*** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (defvar idiig/fixed-width-font "Sarasa Mono J"
    "The font to use for monospaced (fixed width) text.")

  (defvar idiig/variable-width-font "Sarasa Gothic J"
    "The font to use for variable-pitch (document) text.")

  (defun idiig/scale-to-nearest-ten (value scale)
    "Scale VALUE by SCALE and round to nearest multiple of 10.
  For example: (idiig/scale-to-nearest-ten 1080 0.15) => 160"
    (* 10 (round (/ (* value scale) 10.0))))

  (defun idiig/set-fonts-based-on-screen-size (scale)
    "Set fonts based on the screen size.
  SCALE is the ratio of font height to screen height (e.g., 0.15)."
    (when (display-graphic-p)
      (let* ((screen-height (display-pixel-height))
  	   (my-font-height (idiig/scale-to-nearest-ten screen-height scale)))
        my-font-height)))

  (defvar idiig/font-height
    (idiig/set-fonts-based-on-screen-size 0.15)
    "Font height based on screen size.")

  (defvar idiig/lower-font-height 
    (idiig/set-fonts-based-on-screen-size 0.10)
    "Lower font height based on screen size.")

  (add-hook 'after-init-hook
  	  (lambda ()

  	    ;; 工具栏，菜单保持默认字体
  	    (set-face-attribute 'menu nil
  				:inherit 'unspecified)
  	    (set-face-attribute 'tool-bar nil
  				:inherit 'unspecified)

  	    ;; 设置 mode-line 字体
  	    (set-face-attribute 'mode-line nil
  				:inherit 'unspecified
  				:height idiig/lower-font-height)
  	    (set-face-attribute 'mode-line-inactive nil
  				:inherit 'unspecified
  				:height idiig/lower-font-height)
  	    
  	    (set-face-attribute 'default nil
  				:font idiig/fixed-width-font
  				:background "#fbf7f0"
  				:weight 'regular
  				:height idiig/font-height)
  	    (set-face-attribute 'fixed-pitch nil
  				:font idiig/fixed-width-font
  				:weight 'regular
  				:height idiig/font-height)
  	    (set-face-attribute 'variable-pitch nil
  				:font idiig/variable-width-font
  				:weight 'regular
  				:height idiig/font-height)
  	    ;; 设置 comint 提示符字体
  	    (set-face-attribute 'comint-highlight-prompt nil
  				:inherit 'fixed-pitch)
  	    ;; 设置 minibuffer prompt 字体
  	    (set-face-attribute 'minibuffer-prompt nil
  				:inherit 'fixed-pitch)
  	    (set-face-attribute 'header-line nil
  				:inherit 'fixed-pitch)))
#+end_src

** 日文
*** 输入法 (ddskk)
**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+BEGIN_SRC nix 
  ddskk
#+END_SRC

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (use-package ddskk
    :defer t
    :bind (("C-x j" . skk-mode))
    :config
    (setq skk-server-inhibit-startup-server nil)
    (setq skk-server-host "localhost")
    (setq skk-server-portnum 55100)
    (setq skk-share-private-jisyo t)

    ;; 候补显示设置
    (setq skk-show-inline t)
    (setq skk-show-tooltip t)
    (setq skk-show-candidates-always-pop-to-buffer t)
    (setq skk-henkan-show-candidates-rows 2)

    ;; 行为设置
    (setq skk-egg-like-newline t)
    (setq skk-delete-implies-kakutei nil)
    (setq skk-use-look t)
    (setq skk-auto-insert-paren t)
    (setq skk-henkan-strict-okuri-precedence t)

    ;; 片假名转换设置
    (setq skk-search-katakana 'jisx0201-kana)

    ;; 加载额外功能
    (require 'skk-hint)
    :hook
    (skk-load . (lambda ()
                  (require 'context-skk))))
#+end_src
*** 检索（Migemo）
**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  migemo
#+end_src
注意这里使用的是 =cmigemo= 。
**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
***** 基础配置
#+begin_src emacs-lisp
  (require 'migemo)
  ;; cmigemo(default)
  (setq migemo-command "${pkgs.cmigemo}/bin/cmigemo")
  (setq migemo-options '("-q" "--emacs"))

  ;; Set your installed path
  (setq migemo-dictionary "${pkgs.cmigemo}/share/migemo/utf-8/migemo-dict")

  (setq migemo-user-dictionary nil)
  (setq migemo-regex-dictionary nil)
  (when (and migemo-command migemo-dictionary)
    (migemo-init)
    (message "Migemo initialized with dictionary: %s" migemo-dictionary))
#+end_src
***** buffer内字符检索 (=Ctrlf=) 交互
#+begin_src emacs-lisp
  (with-eval-after-load 'migemo
    (with-eval-after-load 'ctrlf
      (add-to-list 'ctrlf-style-alist '(migemo-regexp . (:prompt "migemo-regexp"
  							       :translator migemo-search-pattern-get
  							       :case-fold ctrlf-no-uppercase-regexp-p)))))

#+end_src
***** minibuffer内检索 (=Orderless=) 交互
用 =migemo= 在minibuffer的检索中用 =#= 前缀可开启罗马字检索日语。
#+begin_src emacs-lisp
  (with-eval-after-load 'orderless
    (defun orderless-migemo (component)
    (let ((pattern (migemo-get-pattern component)))
      (condition-case nil
          (progn (string-match-p pattern "") pattern)
        (invalid-regexp nil))))
    
    (add-to-list '+orderless-dispatch-alist '(?# . orderless-migemo)))
#+end_src
** 中文
*** 输入法和基于输入法的检索 (pyim)
**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+BEGIN_SRC nix 
  pyim
    pyim-basedict
#+END_SRC
**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
***** 基础配置
#+begin_src emacs-lisp
  (use-package pyim
    :diminish pyim-isearch-mode
    :commands
    (toggle-input-method)
    :custom
    (default-input-method "pyim")
    (pyim-dcache-directory (concat user-emacs-directory "pyim/dcache"))
    (pyim-default-scheme 'quanpin)
    (pyim-page-tooltip 'popup)
    (pyim-page-length 4))

  ;; 加载并启用基础词库
  (use-package pyim-basedict
    :after pyim
    :config
    (pyim-basedict-enable))
#+end_src
***** TODO 正则表达交互
目前支持：
- 在minibuffer中用 =C-Ret= 把单字拼音转换为该读音本身代表的中文正则表达
- =M-x idiig/toggle-pyim-region= 用于开关中文的forward-word和backward
- 激活进入pyim时，自动开启中文的forward和backward
#+begin_src emacs-lisp
  (with-eval-after-load 'pyim
    (require 'pyim-cstring-utils)

    ;; C-return 把当前选中的位置转换为正则表达
    (define-key minibuffer-local-map (kbd "C-<return>") 'pyim-cregexp-convert-at-point)

    (defvar idiig/pyim-region-enabled nil
      "记录pyim区域功能是否启用的状态变量。")

    (defun idiig/toggle-pyim-region ()
      "切换pyim的单词移动功能。
  当启用时，会将forward-word和backward-word重映射为pyim的相应函数；
  当禁用时，会恢复原来的映射。"
      (interactive)
      (if idiig/pyim-region-enabled
  	(progn
  	  (idiig/disable-pyim-region)
  	  (setq idiig/pyim-region-enabled nil)
  	  (message "已禁用pyim区域功能"))
        (progn
  	(idiig/enable-pyim-region)
  	(setq idiig/pyim-region-enabled t)
  	(message "已启用pyim区域功能"))))

    (defun idiig/enable-pyim-region (&rest _)
      "启用pyim的单词移动建议。"
      (global-set-key [remap forward-word] 'pyim-forward-word)
      (global-set-key [remap backward-word] 'pyim-backward-word))

    (defun idiig/disable-pyim-region (&rest _)
      "禁用pyim的单词移动建议。"
      (global-unset-key [remap forward-word])
      (global-unset-key [remap backward-word]))

    ;; ;; 挂钩到 pyim 的启用/禁用钩子上
    ;; (advice-remove 'pyim-deactivate #'idiig/disable-pyim-region)
    ;; (advice-remove 'pyim-activate #'idiig/enable-pyim-region)
    ;; (advice-add 'pyim-deactivate :after #'idiig/disable-pyim-region)
    (advice-add 'pyim-activate :after #'idiig/enable-pyim-region))
#+end_src

***** buffer内检索 (=Ctrlf=) 交互
这里我写了一个函数 =pyim-cregex-build-lazy= 。这个函数交互 =pyim= 。参见输
入法。这个函数的工作逻辑如下：

- 如果还没有初始化拼音数据，就先进行预热预热时会加载 "a"、"e"、"o" 这
  三个字符的拼音映射数据设置初始化标志，避免重复初始化
- 接着分两种情况处理：
  1. 情况1 :: 单个字符且不是 a/e/o，双个字母不是 zh/ch/sh
     1) 使用 regexp-quote 直接转义字符
     2) 例如：输入 "b" → 直接匹配字符 "b"
     3) 避免触发拼音转换，提高性能
  2. 情况2 :: 其他所有情况
     1) 使用 pyim-cregexp-build 进行拼音转换，包括：
        + 单个字符 "a"、"e"、"o"（常用韵母）
        + 多个字符组合（如 "zh"、"zhong"）
- 设计目的
  1. 性能优化 :: 避免输入大多数单个字符时的拼音转换开销
  2. 保持功能 :: 在需要拼音搜索时正常工作
  3. 用户体验 :: 减少首次输入时的卡顿感
    
#+begin_src emacs-lisp
  (with-eval-after-load 'ctrlf
    
    (defvar pyim-ctrlf-initialized nil
      "Flag to track if pyim data has been initialized for ctrlf.")
    
    (defvar pyim-ctrlf-cache (make-hash-table :test 'equal)
      "Cache for pyim-cregexp-build results.")
    
    (defconst pyim-ctrlf-vowels-with-mapping '("a" "e" "o")
      "Vowels that have direct Chinese character mappings.")
    
    (defconst pyim-ctrlf-double-consonants '("zh" "ch" "sh")
      "Double-letter consonants that should use regex-quote for exact matching.")
    
    (defun pyim-cregexp-build-lazy (str)
      "Lazy wrapper for pyim-cregexp-build with caching."
      (unless pyim-ctrlf-initialized
        (message "Initializing pyim data for ctrlf...")
        ;; 预缓存常用字符的结果
        (call-interactively #'pyim-activate)
        (call-interactively #'pyim-deactivate)
        
        (dolist (vowel pyim-ctrlf-vowels-with-mapping)
          (let ((result (pyim-cregexp-build vowel)))
            (puthash vowel result pyim-ctrlf-cache)))
        (setq pyim-ctrlf-initialized t)
        (message "Pyim data initialized."))
      
      ;; 判断是否使用 regex-quote
      (if (or (and (= (length str) 1)
                   (not (member str pyim-ctrlf-vowels-with-mapping)))
              (member str pyim-ctrlf-double-consonants))
          (regexp-quote str)
        ;; 使用缓存或计算新结果
        (or (gethash str pyim-ctrlf-cache)
            (let ((result (pyim-cregexp-build str)))
              (puthash str result pyim-ctrlf-cache)
              result))))

    (add-to-list 'ctrlf-style-alist
                 '(pinyin-regexp . (:prompt "pinyin-regexp"
  					  :translator pyim-cregexp-build-lazy
  					  :case-fold ctrlf-no-uppercase-regexp-p
  					  :fallback (isearch-forward-regexp
  						     . isearch-backward-regexp)))))
#+end_src
***** minibuffer内检索 (=Orderless=) 交互
用 =pyim= 在minibuffer的检索中用 =◎= 前缀可开启拼音检索中文。
#+begin_src emacs-lisp
  ;; (with-eval-after-load 'orderless
  ;;   ;; 拼音检索字符串功能
  ;;   (defun zh-orderless-regexp (orig_func component)
  ;;     (call-interactively #'pyim-activate)
  ;;     (call-interactively #'pyim-deactivate)
  ;;     (let ((result (funcall orig_func component)))
  ;;       (pyim-cregexp-build result)))
  ;;   (advice-add 'orderless-regexp :around #'zh-orderless-regexp))

  (with-eval-after-load 'orderless

    (defvar pyim-orderless-initialized nil
      "Flag to track if pyim data has been initialized for orderless.")

    (defun orderless-pyim (component)
      (unless pyim-orderless-initialized
        (message "Initializing pyim for orderless...")
        ;; 预缓存常用字符的结果
        (call-interactively #'pyim-activate)
        (call-interactively #'pyim-deactivate)
        (setq pyim-orderless-initialized t)
        (message "Pyim data initialized."))
      
      (let ((pattern (pyim-cregexp-build component)))
        (condition-case nil
            (progn (string-match-p pattern "") pattern)
  	(invalid-regexp nil))))

    (add-to-list '+orderless-dispatch-alist '(?@ . orderless-pyim)))
#+end_src
** Git (=magit=)
用 Magit 进行项目与版本的管理
*** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

#+BEGIN_SRC nix
  magit
#+END_SRC

*** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

**** Magit

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind ("C-x g" . magit-status)
    :commands magit-status
    :init
    ;; 使用nix路径中的git
    (add-to-list 'exec-path "${pkgs.git}/bin"))
#+END_SRC
** 邮件
*** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  wanderlust
#+end_src
*** TODO 配置
** 文档写作
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
*** 文档后缀
#+begin_src emacs-lisp
  (defvar idiig/writing-environment-list '("\\.org\\'"
                                           "\\.md\\'"
                                           "\\.qmd\\'"
                                           "\\.rmd\\'"
                                           "\\.typ\\'"
                                           "\\.tex\\'"
                                           "\\.bib\\'"
                                           "\\.txt\\'"))
#+end_src

*** 文档状态折行
#+begin_src emacs-lisp
  (defun idiig/in-writing-environment-p ()
    "Check if current buffer file matches any pattern in idiig/writing-environment-list."
    (when (buffer-file-name)
      (cl-some (lambda (pattern)
                 (string-match-p pattern (buffer-file-name)))
               idiig/writing-environment-list)))

  (add-hook 'find-file-hook
            (lambda ()
              (when (idiig/in-writing-environment-p)
                (visual-line-mode 1))))

  (with-eval-after-load 'diminish
    (diminish 'visual-line-mode))
#+end_src

*** 在选中区域的状态下 =C-w= 删除选中的区域
在没选中的状态下删除上一个单词。
#+begin_src emacs-lisp
  (with-eval-after-load 'puni
    (defun idiig/backward-kill-word-or-region (&optional arg)
      (interactive "p")
      (if (region-active-p)
  	(call-interactively #'puni-kill-active-region)
        (backward-kill-word arg)))

    (global-set-key (kbd "C-w") 'idiig/backward-kill-word-or-region))
#+end_src

*** =C-M-\= 全局缩进
#+begin_src emacs-lisp
  (defun idiig/indent-buffer()
    (interactive)
    (indent-region (point-min) (point-max)))

  (defun idiig/indent-region-or-buffer()
    (interactive)
    (save-excursion
      (if (region-active-p)
          (progn
            (indent-region (region-beginning) (region-end)))
        (progn
          (idiig/indent-buffer)))))

  (global-set-key (kbd "C-M-\\") 'idiig/indent-region-or-buffer)
  (global-set-key (kbd "C-M-¥") 'idiig/indent-region-or-buffer)  ;; JIS keyboard
#+end_src

*** =Shift-Ret= 下方插入空白行
#+begin_src emacs-lisp
  (global-set-key [(shift return)] 'idiig/smart-open-line)
#+end_src

*** =M--= 匹配到括号
转跳匹配括号。
#+begin_src emacs-lisp
  (defun idiig/goto-match-paren (arg)
    "跳轉到匹配的括號，類似 vi 的 %。"
    (interactive "p")
    (cond
     ;; 光標在開括號上
     ((looking-at "[[({]") 
      (forward-sexp))
     ;; 光標在閉括號上
     ((looking-back "[])}]" 1) 
      (backward-sexp))
     ;; 光標在閉括號前（例如中間空格）
     ((looking-at "[])}]") 
      (forward-char)
      (backward-sexp))
     ;; 光標在開括號後
     ((looking-back "[[({]" 1)
      (backward-char)
      (forward-sexp))
     ;; 其他情況
     (t
      (message "未找到匹配的括號"))))

  (bind-key* "M--" 'idiig/goto-match-paren)
#+end_src

*** 点后插入空白
#+begin_src emacs-lisp
  (defun idiig/insert-space-after-point ()
    (interactive)
    (save-excursion (insert " ")))

  (bind-key* "C-." 'idiig/insert-space-after-point)
#+end_src

** 文档阅览 (=emacs-reader=)
*** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  (melpaBuild {
    ename = "reader";
    pname = "emacs-reader";
    version = "20250630";
    src = pkgs.fetchFromGitea {
      domain = "codeberg.org";
      owner = "divyaranjan";
      repo = "emacs-reader";
      rev = "9d62d26fe4ae63e5cecf57bc399b20f7feefb620"; # replace with 'tag' for stable
      hash = "sha256-hkRa52PYfBG090jior3GPOeZyftwmpr2Q7jPKFHsR88=";
    };
    files = ''(:defaults "render-core.so")'';
    nativeBuildInputs = [ pkgs.pkg-config ];
    buildInputs = with pkgs; [ gcc mupdf gnumake pkg-config ];
    preBuild = "make clean all";
  })
#+end_src
*** TODO 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
** 编程工具
*** 我有可能使用的语言
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  ;; TODO: 这里未来需要改成在每个语言的设定的节点push进来
  (defvar idiig/language-list
    '("emacs-lisp" "python" "ditaa" "plantuml" "shell" "nix"
      "R" "haskell" "latex" "css" "lisp" "jq" "makefile" "go")
    "支持的编程语言列表。")

  (defun idiig/run-prog-mode-hooks ()
    "Runs `prog-mode-hook'. 针对一些本该为编程语言又没自动加载prog mode的语言hook.
  如：(add-hook 'python-hook 'idiig/run-prog-mode-hooks)
  "
    (run-hooks 'prog-mode-hook))
#+end_src

*** 语言服务器 (=lsp-Bridge=)
:PROPERTIES:
:CUSTOM_ID: lsp-bridge
:END:
语言服务器用于补全代码，提示文档，参照转跳等。这里我使用了 LSP-Bridge，
其主要优势是通过 python 后端调用语言服务器，不卡 emacs 进程达到高速的
补全。其他倾向的代替选项有 emacs 捆绑 =eglot= 。
**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  (lsp-bridge.override {
    # 指定使用 Python 3.11 而不是 3.12
    python3 = pkgs.python311;
  })
    markdown-mode
    yasnippet
#+end_src

这里由于默认的 python (3.12.9) 版本问题导致了下面的报错：

- 首先尝试导入 =SimpleXMLRPCServer= 模块失败，这是因为在 Python 3 中，
  该模块已被移至 =xmlrpc.server=
- 随后在导入 =xmlrpc.client= 时出现了一个奇怪的错误:
  ~'datetime.datetime' object has no attribute 'task'~

这可能是 Python 3.12.9 中的一个 bug，或者是 epc 包与 Python 3.12.9 不
兼容的结果。因此我们在 =lsp-bridge= 的环境中使用了 311 的版本。

#+begin_example
  Traceback (most recent call last):
    File "/nix/store/1bn994va1akp3m0jvg4fj9wzlqmn1kkq-python3-3.12.9-env/lib/python3.12/site-packages/epc/py3compat.py", line 26, in <module>
      import SimpleXMLRPCServer
  ModuleNotFoundError: No module named 'SimpleXMLRPCServer'

  During handling of the above exception, another exception occurred:

  Traceback (most recent call last):
    File "/nix/store/4mx09lzrlahhkgv7qb2q57xmnsfwcmlx-emacs-packages-deps/share/emacs/site-lisp/elpa/lsp-bridge-20250210.0/lsp_bridge.py", line 46, in <module>
      from epc.server import ThreadingEPCServer
    File "/nix/store/1bn994va1akp3m0jvg4fj9wzlqmn1kkq-python3-3.12.9-env/lib/python3.12/site-packages/epc/server.py", line 20, in <module>
      from .py3compat import SocketServer
    File "/nix/store/1bn994va1akp3m0jvg4fj9wzlqmn1kkq-python3-3.12.9-env/lib/python3.12/site-packages/epc/py3compat.py", line 28, in <module>
      import xmlrpc.server as SimpleXMLRPCServer
    File "/nix/store/26yi95240650jxp5dj78xzch70i1kzlz-python3-3.12.9/lib/python3.12/xmlrpc/server.py", line 107, in <module>
      from xmlrpc.client import Fault, dumps, loads, gzip_encode, gzip_decode
    File "/nix/store/26yi95240650jxp5dj78xzch70i1kzlz-python3-3.12.9/lib/python3.12/xmlrpc/client.py", line 272, in <module>
      if _try('%Y'):      # Mac OS X
         ^^^^^^^^^^
    File "/nix/store/26yi95240650jxp5dj78xzch70i1kzlz-python3-3.12.9/lib/python3.12/xmlrpc/client.py", line 269, in _try
      return _day0.strftime(fmt) == '0001'
             ^^^^^^^^^^^^^^^^^^^
  AttributeError: 'datetime.datetime' object has no attribute 'task'
#+end_example

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
***** 后续的设置宏，用于配置 Nix 环境下的 LSP 服务器
#+begin_src emacs-lisp
  (defvar idiig/lsp-extra-paths nil
    "Emacs 侧已配置的 LSP 可执行目录清单。会被写入到项目的 .emacs-lsp-paths。")

  (defmacro idiig//setup-nix-lsp-bridge-server (language server-name executable-path &optional lib-path)
    "配置 Nix 环境下的 LSP 服务器。
  LANGUAGE 是语言名称，如 'python'。
  SERVER-NAME 是服务器名称，如 'basedpyright'。
  EXECUTABLE-PATH 是服务器可执行文件的路径。
  LIB-PATH 是可选的库路径，添加到 LD_LIBRARY_PATH。"
    `(with-eval-after-load 'lsp-bridge
       ;; 设置 LSP 服务器
       (setq ,(intern (format "lsp-bridge-%s-lsp-server" language)) ,server-name)
       
       ;; 添加可执行文件路径到 exec-path
       ,(when executable-path
          `(progn
  	   (add-to-list 'exec-path ,executable-path)
  	   (add-to-list 'idiig/lsp-extra-paths ,executable-path)))
       
       ;; 添加库路径到 LD_LIBRARY_PATH
       ,(when lib-path
          `(setenv "LD_LIBRARY_PATH" 
                   (concat ,lib-path ":" 
                           (or (getenv "LD_LIBRARY_PATH") ""))))))
#+end_src

上面这个宏用于生成 LSP-Bridge 的设定，因为语言服务器本身需要用户自己安
装，而本配置又需要 Nix 保证复现，所以我们需要把 nix 路径的语言服务器传
递给 emacs ，而且语言服务器往往需要匹配的 C++ 的库。因此我希望通过上面
的代码生成系列配置，同时设定语言，语言服务器，语言服务器的可执行文件路
径，依赖的 C 库。宏使用如下：

#+begin_src emacs-lisp :noweb-ref -
  (idiig//setup-nix-lsp-bridge-server 
   "python" 
   "basedpyright" 
   "${pkgs.basedpyright}/bin" 
   "${pkgs.stdenv.cc.cc.lib}/lib")
#+end_src

宏展开后如下：

#+begin_src emacs-lisp :noweb-ref -
  (with-eval-after-load 'lsp-bridge
    (setq lsp-bridge-python-lsp-bridge-server "basedpyright")
    (add-to-list 'exec-path "${pkgs.basedpyright}/bin")
    (setenv "LD_LIBRARY_PATH" 
            (concat "${pkgs.stdenv.cc.cc.lib}/lib:" 
                    (or (getenv "LD_LIBRARY_PATH") ""))))
#+end_src

后面是 LSP-Bridge 本体的配置：

#+begin_src emacs-lisp
  (use-package lsp-bridge
    :defer t
    :diminish lsp-bridge-mode
    :bind
    (:map acm-mode-map
          ("C-j" . acm-select-next)
          ("C-k" . acm-select-prev))
    :custom
    (acm-enable-yas nil)   ; 补全不包括 Yasnippet
    (acm-enable-doc nil)   ; 不自动显示函数等文档
    (lsp-bridge-org-babel-lang-list idiig/language-list)  ; org支持的代码也使用桥
    (acm-enable-icon nil)  ; 不显示图标
    :hook 
    (prog-mode . (lambda ()
  		 (lsp-bridge-mode)))
    :init
    ;; 这里是为了让语言服务器找到正确的版本的 libstdc++.so.6 库
    (setenv "LD_LIBRARY_PATH" 
            (concat "${pkgs.stdenv.cc.cc.lib}/lib:" 
                    (or (getenv "LD_LIBRARY_PATH") ""))))
#+end_src

*注意* ：语言服务器不会自动安装，如果在新电脑中出现缺少个别语言服务器
的情况，我们可以手动安装。
***** 弹窗补全优先设置
#+begin_src emacs-lisp
  (with-eval-after-load 'lsp-bridge
    (defun idiig/acm-prefer-lsp-all ()
      (when (bound-and-true-p lsp-bridge-mode)
        ;; 让 search 后端慢一点再来（避免覆盖 LSP）
        (when (boundp 'acm-backend-search-delay)
          (setq-local acm-backend-search-delay 0.8))  ;; 你可调成 0.6~1.0

        ;; 提高 LSP 优先级，降低 search 优先级（若有这些变量）
        (when (boundp 'acm-backend-lsp-priority)
          (setq-local acm-backend-lsp-priority 100))
        (when (boundp 'acm-backend-search-priority)
          (setq-local acm-backend-search-priority 0))

        ;; 可选：减少噪声（若存在这些开关）
        (when (boundp 'acm-enable-dabbrev)
          (setq-local acm-enable-dabbrev nil))          ; 关闭 dabbrev 后端
        (when (boundp 'acm-backend-search-candidates-min-length)
          (setq-local acm-backend-search-candidates-min-length 3)))) ; 至少 3 字符再搜

    (add-hook 'lsp-bridge-mode-hook #'idiig/acm-prefer-lsp-all))
#+end_src
*** TODO Treesitter
用于解析语法和语法高亮
**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  # treesit  # 目前 treesit 已经内置
  treesit-auto
#+end_src

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (use-package treesit-auto
    :custom
    (treesit-auto-install 'prompt)   ; 设置安装 tree-sitter 语法时提示用户确认
    :hook
    (prog-mode . treesit-auto-mode)    ; 在所有编程模式下自动启用 treesit-auto-mode
    :config
    (treesit-auto-add-to-auto-mode-alist 'all))  ; 将所有已知的 tree-sitter 模式添加到自动模式列表中
#+end_src

这个配置设置了 =treesit-auto= 包，这是一个帮助管理和自动启用 Emacs 内
置 =tree-sitter= 模式的工具。会在启动 major mode 的时候自动替换为
=<major>-ts-mode= 。比如 python-mode 会变成 python-ts-mode。

*注意* ：treesit 不会自动安装，如果在新电脑中出现缺少 treesit 的情况，
我们可以手动 =treesit-auto-install-all= 。下载目前所有可能的语言的
treesit。

*** Snippet (=yasnippet=)
Snippet 用于快速插入模板
**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
这里 =yasnippet= 本体已经作为 =lsp-bridge= 的依赖被加入，我们这里只加
入一个 snippet 的合集 =yasnippert-snippets= 。
#+begin_src nix
  # yasnippet
  yasnippet-snippets
    consult-yasnippet
#+end_src

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  ;; (defvar idiig/snippet-dir (concat user-emacs-directory "snippets"))
  (use-package yasnippet
    :defer t
    :diminish yas-minor-mode
    :hook
    (prog-mode . yas-minor-mode)
    :init
    ;; (setq yas-snippet-dirs <path/to/snippets>)
    ;; (push idiig/snippet-dir yas-snippet-dirs)
    :config
    (yas-reload-all))
#+end_src

加载用于yasnippet的的合集

#+begin_src emacs-lisp
  (use-package consult-yasnippet
    :after
    (consult
     yas-minor-mode))
#+end_src

*** TAGS (=Citre=)
**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  citre
#+end_src
**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (use-package citre
    :commands (citre-jump
  	     citre-jump-back
  	     citre-ace-peek
  	     citre-update-this-tags-file)
    :custom
    (citre-readtags-program "${pkgs.universal-ctags}/bin/readtags")
    (citre-ctags-program "${pkgs.universal-ctags}/bin/ctags")
    (citre-gtags-program "${pkgs.global}/bin/gtags")
    (citre-global-program "${pkgs.global}/bin/global")
    (citre-project-root-function #'vc-dir-root)
    ;; (citre-default-create-tags-file-location 'global-cache)
    (citre-edit-ctags-options-manually nil)
    (citre-auto-enable-citre-mode-modes '(prog-mode))
    :init
    (require 'citre-config))
#+end_src
*** 基于 tresitter 的结构化编程
**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
#+end_src

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
#+end_src
*** 自动化环境管理 (=direnv=)
**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  direnv
#+end_src
**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
启用 direnv-mode 使用 flake 定环境变量。
#+begin_src emacs-lisp
  (use-package direnv
    :defer t
    :init
    (add-to-list 'exec-path "${pkgs.direnv}/bin")
    :config
    (direnv-mode))
#+end_src

但是项目中的环境变量往往会修改PATH，导致 LSP 等工具找不到可执行文件。
而我并不想在flake里写LSP相关的配置，因为倭人为LSP是为了了补全和跳转，
而不是为了运行程序和复现环境。因此我们需要把 Emacs 的 exec-path 也合并
进 PATH 里，供子进程继承。
#+begin_src emacs-lisp
  (require 'cl-lib)

  (defun idiig/project-root ()
    "返回当前 buffer 对应的项目根（优先含 .envrc，其次 .git）。"
    (or (locate-dominating-file default-directory ".envrc")
        (locate-dominating-file default-directory ".git")
        default-directory))

  (defun idiig/write-emacs-lsp-paths ()
    "将 `idiig/lsp-extra-paths` 写入项目根的 .emacs-lsp-paths。"
    (interactive)
    (when-let* ((root (idiig/project-root))
                (file (expand-file-name ".emacs-lsp-paths" root)))
      (let* ((dirs (->> idiig/lsp-extra-paths
                        (seq-filter #'file-directory-p)
                        (delete-dups))))
        (when dirs
          (with-temp-file file
            (dolist (p dirs) (insert p "\n")))))))

  ;; lsp-bridge 项目根识别（避免偶发 no views）
  ;; direnv 集成：allow/refresh 前写清单；完成后自动重启 lsp-bridge
  (with-eval-after-load 'direnv
    ;; before：生成/更新 .emacs-lsp-paths，供 .envrc 读取
    (advice-add 'direnv-allow :before (lambda (&rest _) (idiig/write-emacs-lsp-paths)))
    (when (fboundp 'direnv-update-environment)
      (advice-add 'direnv-update-environment :before
                  (lambda (&rest _) (idiig/write-emacs-lsp-paths))))

    ;; after：环境就绪后，如有需要自动重启 lsp-bridge
    (defun idiig/direnv--restart-lsp-bridge (&rest _)
      (when (and (featurep 'lsp-bridge)
                 (fboundp 'lsp-bridge-restart-process)
                 (cl-some (lambda (buf)
                            (with-current-buffer buf
                              (bound-and-true-p lsp-bridge-mode)))
                          (buffer-list)))
        (lsp-bridge-restart-process)))
    (advice-add 'direnv-allow :after #'idiig/direnv--restart-lsp-bridge)
    (when (fboundp 'direnv-update-environment)
      (advice-add 'direnv-update-environment :after #'idiig/direnv--restart-lsp-bridge)))
#+end_src
*** 终端 (=eat=)
**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  eat
#+end_src
**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  ;; For `eat-eshell-mode'.
  (add-hook 'eshell-load-hook #'eat-eshell-mode)

  ;; For `eat-eshell-visual-command-mode'.
  (add-hook 'eshell-load-hook #'eat-eshell-visual-command-mode)
#+end_src
** 编程与文档语言
*** Nix
**** 依赖
#+begin_src nix :noweb-ref epkgs
  nix-mode
#+end_src

加入 nix 的 major mode。
#+begin_src emacs-lisp :noweb-ref ecfg
  (idiig//setup-nix-lsp-bridge-server 
   "nix" 
   "nixd" 
   "${pkgs.nixd}/bin" 
   nil)
#+end_src

设置 nix 的语言服务器。注意这里使用的是在 LSP-Bridge 节中写的宏（参看
[[#lsp-bridge]]）。

**** 配置
*** Lisp
**** RERL
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
***** 依赖
#+begin_src nix
  slime
    geiser                        # for scheme
#+end_src
***** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (use-package slime
    :init
    (setq inferior-lisp-program
  	(or (executable-find "sbcl")
  	    "${pkgs.sbcl}/bin/sbcl"))
    :config
    (slime-setup '(slime-fancy)))
#+end_src
**** 方言
***** Elisp
****** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
- =M-:= 时的 eval expression minibuffer 的时候加入 prog mode。
#+begin_src emacs-lisp
  (add-hook 'eval-expression-minibuffer-setup 'idiig/run-prog-mode-hooks)
#+end_src

***** Clojure
****** 依赖
#+begin_src emacs-lisp :noweb-ref ecfg
  (idiig//setup-nix-lsp-bridge-server 
   "clojure" 				; language name
   "clojure-lsp" 				; lsp name
   "${pkgs.clojure-lsp}/bin"		; dependency nixpkg path
   nil)					; other dependencies
#+end_src

*** Python
**** 本体
***** 依赖
#+begin_src emacs-lisp :noweb-ref ecfg
  (idiig//setup-nix-lsp-bridge-server 
   "python" 
   "basedpyright" 
   "${pkgs.basedpyright}/bin" 
   "${pkgs.stdenv.cc.cc.lib}/lib")
#+end_src
***** 配置
**** 虚拟环境
*** Haskell
**** 本体
***** 依赖
Major mode:
#+begin_src nix :noweb-ref epkgs
  haskell-mode
#+end_src

#+begin_src emacs-lisp :noweb-ref ecfg
  (idiig//setup-nix-lsp-bridge-server 
   "haskell"
   "hls" 
   "${pkgs.haskell-language-server}/bin" 
   nil)
#+end_src
*** R
*** Go
**** 本体
***** 依赖
Major mode:
#+begin_src nix :noweb-ref epkgs
  go-mode
#+end_src

LSP:
#+begin_src emacs-lisp :noweb-ref ecfg
  (idiig//setup-nix-lsp-bridge-server 
   "go" 
   "gopls" 
   "${pkgs.gopls}/bin" 
   nil)
#+end_src
***** 配置
#+begin_src emacs-lisp :noweb-ref ecfg
  (defun idiig/go-prefer-lsp ()
    (when (derived-mode-p 'go-mode 'go-ts-mode)
      ;; 关闭文件内/跨缓冲词搜索后端（如果你的版本有这些开关）
      (when (boundp 'acm-enable-search-file-words)
        (setq-local acm-enable-search-file-words nil))
      (when (boundp 'acm-enable-dabbrev)
        (setq-local acm-enable-dabbrev nil))
      ;; 把搜索词的延迟调大，避免覆盖（若有这个变量）
      (when (boundp 'acm-backend-search-delay)
        (setq-local acm-backend-search-delay 0.8))
      ;; LSP 候选最短前缀更短一些（若有）
      (when (boundp 'acm-backend-lsp-candidate-min-length)
        (setq-local acm-backend-lsp-candidate-min-length 0))))
  (add-hook 'go-mode-hook #'idiig/go-prefer-lsp)
  (add-hook 'go-ts-mode-hook #'idiig/go-prefer-lsp)
#+end_src
*** Shell
**** 依赖
#+begin_src emacs-lisp :noweb-ref ecfg
  (idiig//setup-nix-lsp-bridge-server 
   "bash" 				; language name
   "bash-language-server" 		; lsp name
   "${pkgs.bash-language-server}/bin" 	; dependency nixpkg path
   nil)					; other dependencies
#+end_src

**** 配置
***** 用 =bash= 作为默认 shell
#+begin_src emacs-lisp :noweb-ref ecfg
  ;; (setq shell-command-switch "-ic")
  (setq-default explicit-shell-file-name "${pkgs.bashInteractive
  }/bin/bash")
  (setq shell-file-name "${pkgs.bashInteractive
  }/bin/bash")
#+end_src

*** jq
#+begin_src nix :noweb-ref epkgs
  jq-mode
#+end_src
*** Make
*** TeX
**** 依赖
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src nix :noweb-ref epkgs
  auctex
    auctex-latexmk
#+end_src

#+begin_src emacs-lisp
  (idiig//setup-nix-lsp-bridge-server 
   "tex" 
   "texlab" 
   "${pkgs.texlab}/bin" 
   nil)
#+end_src

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (add-hook 'TeX-mode-hook 'idiig/run-prog-mode-hooks)
#+end_src

#+begin_src emacs-lisp
  (use-package auctex
    :defer t)
#+end_src

*** Typst

*** Markdown

*** Quarto

*** XML
*** JSON
**** 依赖
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src nix :noweb-ref epkgs
  jsonian
    json-mode
#+end_src

#+begin_src emacs-lisp
  (idiig//setup-nix-lsp-bridge-server 
   "json" 
   "vscode-json-language-server" 
   "${pkgs.vscode-langservers-extracted}/bin" 
   nil)
#+end_src
**** 配置
#+begin_src emacs-lisp :noweb-ref ecfg
  (use-package jsonian
    :after so-long
    :custom
    (jsonian-no-so-long-mode))
#+end_src
*** Web

*** Java
**** 依赖
#+begin_src nix :noweb-ref 
  (pkgs.jre_minimal)
#+end_src

*** PlantUML
**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  plantuml-mode
#+end_src

#+begin_src emacs-lisp :noweb-ref ecfg
  (add-to-list 'exec-path "${pkgs.plantuml}/bin")
  (with-eval-after-load 'org
    (setq org-plantuml-jar-path "${pkgs.plantuml}/lib/plantuml.jar")
    (setq org-plantuml-executable-path "${pkgs.plantuml}/bin/plantuml")
    (setq org-plantuml-exec-mode 'plantuml))
#+end_src

*** GraphViz
**** 依赖
#+begin_src emacs-lisp :noweb-ref ecfg
  (add-to-list 'exec-path "${pkgs.graphviz}/bin")
#+end_src
** Org相关配置
*** Org本体
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
**** 绑定 prog mode
#+begin_src emacs-lisp
  (add-hook 'org-mode-hook 'idiig/run-prog-mode-hooks)
#+end_src
**** 代码块支持语言
***** 依赖
由于 =ob-nix=, =ob-go= 还没有默认。我们需要添加这些依赖
#+begin_src nix :noweb-ref epkgs
  ob-nix
    ob-go
#+end_src
***** 配置
#+begin_src emacs-lisp
  (defun idiig/load-org-babel-languages ()
    "根据 `idiig/language-list` 启用 `org-babel` 语言。"
    (let ((languages '()))
      (dolist (lang idiig/language-list)
        (push (cons (intern lang) t) languages)) ;; 将字符串转换为符号
      (org-babel-do-load-languages 'org-babel-load-languages languages)))

  (defun idiig/set-org-babel-language-commands ()
    "根据 `idiig/language-list` 甚至语言的命令。"
    (dolist (lang idiig/language-list)
      (let ((var-name (intern (format "org-babel-%s-command" lang))))
        (when (boundp var-name)
  	(set var-name (executable-find lang))))))

  (add-hook 'org-mode-hook #'idiig/load-org-babel-languages)
  (add-hook 'org-mode-hook #'idiig/set-org-babel-language-commands)

  ;; 特殊
  (setq org-babel-shell-command (executable-find "bash"))
#+end_src
**** 结构化插入Babel模板
=org-insert-structure-template= 后选择 =s= (src block) 时自动提示插入代码
块的语言。

更改这个函数：
- 新增一个功能，如果输入的语言不在列表里，则把语言加入列表。但仅限于当
  前org文档
- 新增一个功能，根据输入的语言更新推荐语言的排序。
#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (defun idiig/org-insert-structure-template-src-advice (orig-fun type)
      "Advice for org-insert-structure-template to handle src blocks."
      (if (string= type "src")  ; 判断条件为 "src"
  	(let ((selected-type (ido-completing-read "Source code type: " idiig/language-list)))
  	  (funcall orig-fun (format "src %s" selected-type)))
        (funcall orig-fun type)))

    (advice-add 'org-insert-structure-template :around #'idiig/org-insert-structure-template-src-advice))
#+end_src
**** 基础设定
***** 默认进入 org-mode 时的设定
- 显示图片
- 显示 LaTeX 公式
- 折叠显示所有顶层节点
- 展开显示当前节点内容
- 展开显示所有子节点但不展开下一级
  
#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (setq org-startup-with-inline-images t) ; 启动时显示图片
    (setq org-startup-with-latex-preview t) ; 启动时显示 LaTeX 公式
    (add-hook 'org-mode-hook
              (lambda ()
                (org-overview)		  ; 显示所有顶层节点
  	      (org-show-entry)		  ; 显示当前节点内容
                (org-show-children)	  ; 显示所有子节点但不展开
  	      (org-fold-hide-block-all)	  ; 隐藏所有代码块
  	      (org-fold-hide-drawer-all)))) ; 隐藏所有抽屉
#+end_src
***** 一些好用的调整
- 允许shift用于选择
- 增强 C-a/C-e 行为：无视 =**= 等 org 标签跳到开始和结尾
- 插入标题时考虑内容结构，在内容后插入
- 编辑折叠内容时显示并报错提醒
- 允许 =#+bind= 关键词：用于导出时绑定变量
- 远程图片文件可以通过 =C-u C-c C-x C-v= 被看到
  
#+begin_src emacs-lisp 
  (with-eval-after-load 'org		
    (setq org-support-shift-select 2
  	org-catch-invisible-edits 'show-and-error ; 编辑折叠内容时显示并报错提醒
  	org-special-ctrl-a/e t ; 增强 C-a/C-e，先跳到内容开始/结束，再跳到行首/尾
  	org-insert-heading-respect-content t ; 插入标题时考虑内容结构，在内容后插入
  	org-export-allow-bind-keywords t     ; 允许 =#+bind= 关键词
  	org-display-remote-inline-images t)) ; 远程图片文件可以通过 =C-u C-c C-x C-v= 被看到
#+end_src

***** 展开标题时折叠其他的标题
每次在 Org mode 中展开一个标题时，会自动折叠整个文档，只保留当前标题及
其直接子节点展开，同时保持父级标题可见。

#+begin_src emacs-lisp
  (defun idiig/org-show-current-only ()
    "收起全部，只展開當前 heading 的一層。"
    (when (org-at-heading-p)
      (save-excursion
        (org-overview)            ; 收起全部
        (org-show-entry)          ; 展開當前條目內容
        (org-show-children 1)     ; 展開當前層的子節點標題
        (while (org-up-heading-safe) ; 保證父鏈條也可見
          (org-show-entry)
          (org-show-children 1)))))

  (defun idiig/org-focus-after-cycle (&rest _args)
    "在 org-cycle 之後自動只展開當前 heading。"
    (when (and (org-at-heading-p)
               (memq org-cycle-subtree-status '(children subtree)))
      (idiig/org-show-current-only)))

  (add-hook 'org-cycle-hook #'idiig/org-focus-after-cycle)
#+end_src

**** 面貌
***** 基础美化
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (with-eval-after-load 'org
    ;; Edit settings
    (setq org-auto-align-tags nil		; 禁用标签自动对齐功能
  	org-tags-column 0		; 标签紧贴标题文本，不右对齐
  	
  	;; Org styling, hide markup etc.
  	org-hide-emphasis-markers t ; 隐藏强调标记符号 (*粗体* 显示为 粗体)
  	org-pretty-entities t)	  ; 美化显示实体字符 (\alpha 显示为 α)

    ;; Modes
    (auto-fill-mode 0)			; Disable auto-fill mode
    (visual-line-mode 1)			; Enable visual-line mode for soft wrapping

    ;; faces
    (set-face-attribute 'org-block nil
    		      :background "#fbf7f0"
  		      :height idiig/lower-font-height
  		      :box nil)
    (set-face-attribute 'org-code nil
  		      :height idiig/lower-font-height)
    (set-face-attribute 'org-tag nil
  		      :height idiig/lower-font-height)
    (set-face-attribute 'org-table nil
    		      :height idiig/lower-font-height)
    (set-face-attribute 'org-target nil
  		      :inherit 'variable-pitch
    		      :height idiig/lower-font-height)
    (set-face-attribute 'org-block-begin-line nil
    		      :inherit '(org-block)
  		      :background "#efe9dd"
    		      :underline nil
  		      :overline "gray40"
  		      :height idiig/lower-font-height
  		      :box nil
  		      :extend nil)
    (set-face-attribute 'org-block-end-line nil
    		      :inherit 'org-hide
    		      :height idiig/lower-font-height
  		      :overline "grey40"
    		      :extend t)
    (with-eval-after-load 'oc
      (set-face-attribute 'org-cite nil
    			:slant 'italic)))
#+end_src
日常编辑的时候，CJK文字过于紧凑，因此在这里添加增加文本内容的行高。注
意，由于我希望code block这些地方可以更小，因此一般的方法如 =(setq-local
line-spacing 0.3)= 这类做法会导致这些字体设置的更小的地方也发生行距的增
加，所以我的做法是使用 overlay 管理目标行的高度。未来可以改成不同的要
素不同的行高。

#+begin_src emacs-lisp
  (defvar idiig/org-line-height 1.8) ; 設定行高倍率
  (defvar idiig/org-target-faces '(org-cite
                                   org-cite-key
                                   org-verbatim
                                   org-footnote
  				 org-code
                                   ;; org-latex-and-related
                                   nil)) ;; 目標標題樣式列表，nil 代表普通文字

  ;; 清除覆蓋層
  (defun idiig/org-line-height-clear ()
    (remove-overlays (point-min) (point-max) 'idiig/org-overlay t))

  ;; 檢查是否為空行
  (defun idiig/org-empty-line-p ()
    (save-excursion
      (beginning-of-line)
      (looking-at-p "^[[:space:]]*$")))

  ;; 應用行高
  (defun idiig/org-line-height-apply ()
    (idiig/org-line-height-clear)
    (save-excursion
      (goto-char (point-min))
      (while (not (eobp))
        (let* ((line-start (line-beginning-position))
               (line-end (line-end-position))
               (invisible (get-char-property line-start 'invisible))
               (face (get-text-property line-start 'face))
               (has-face (or (memq face idiig/org-target-faces)
                            (and (listp face)
                                 (cl-some (lambda (f) (memq f idiig/org-target-faces)) face))))
               (is-empty (idiig/org-empty-line-p)))
          (when (and has-face (not invisible) (not is-empty))
            (let ((ov (make-overlay line-start (min (1+ line-end) (point-max)))))
              (overlay-put ov 'line-height idiig/org-line-height)
              (overlay-put ov 'priority 100)
              (overlay-put ov 'idiig/org-overlay t))))
        (forward-line 1))))

  ;; Hook 函數
  (defun idiig/org-line-height-hook (&optional _state)
    (run-with-idle-timer 0.07 nil
                         (lambda (buf)
                           (when (buffer-live-p buf)
                             (with-current-buffer buf
                               (idiig/org-line-height-apply))))
                         (current-buffer)))

  ;; 使用方式
  (add-hook 'org-mode-hook
            (lambda ()
              (idiig/org-line-height-apply)
              (add-hook 'org-cycle-hook #'idiig/org-line-height-hook nil t)))
#+end_src

***** 字体，缩进，换行设定
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (defun idiig/org-mode-face-settings ()
    "Set custom face attributes for Org mode headings in current buffer only."
    
    ;; Org styling, hide markup etc.
    org-hide-emphasis-markers t ; 隐藏强调标记符号 (*粗体* 显示为 粗体)
    org-pretty-entities t	      ; 美化显示实体字符 (\alpha 显示为 α)
    (auto-fill-mode 0)			; Disable auto-fill mode
    (require 'org-indent)			; Ensure org-indent is loaded
    (org-indent-mode)			; Enable org-indent mode
    (variable-pitch-mode 1)		; Enable variable-pitch mode
    (visual-line-mode 1)			; Enable visual-line mode for soft wrapping
    (setq header-line-format " ")
    
    ;; org headings 设置行间距
    (defface idiig-base-line
      '((t (:inherit 'variable-pitch
    		   :height 0.4)))
      "Used in text-mode and friends for exactly one space after a period.")
    
    (let ((faces '((org-level-1 . 1.2)
                   (org-level-2 . 1.1)
                   (org-level-3 . 1.05)
                   (org-level-4 . 1.0)
                   (org-level-5 . 1.1)
                   (org-level-6 . 1.1)
                   (org-level-7 . 1.1)
                   (org-level-8 . 1.1))))
      (dolist (face faces)
        (face-remap-add-relative (car face) nil
    			       :inherit 'idiig-base-line
    			       :weight 'bold
    			       :height (cdr face))))
    
    (set-face-attribute 'org-block nil
    		      :height idiig/lower-font-height
  		      :background "#efe9dd"
  		      :box nil)
    (set-face-attribute 'org-table nil
    		      :height idiig/lower-font-height)
    (set-face-attribute 'org-formula nil
    		      :inherit 'fixed-pitch)
    (set-face-attribute 'org-code nil
    		      :inherit '(shadow fixed-pitch)
  		      :height idiig/font-height)
    (set-face-attribute 'org-verbatim nil
    		      :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-special-keyword nil
    		      :height idiig/lower-font-height)
    (set-face-attribute 'org-meta-line nil
    		      :height idiig/lower-font-height)
    (set-face-attribute 'org-property-value nil
    		      :inherit '(shadow fixed-pitch)
  		      :height idiig/lower-font-height)
    (set-face-attribute 'org-tag nil
  		      :inherit '(shadow fixed-pitch)
    		      :height idiig/lower-font-height)
    (set-face-attribute 'org-checkbox nil
    		      :height idiig/lower-font-height)
    (set-face-attribute 'org-drawer nil
    		      :height idiig/lower-font-height
    		      :extend nil)
    (set-face-attribute 'org-block-begin-line nil
    		      :inherit '(org-block)
    		      :height idiig/font-height
    		      ;; :underline "gray40"
  		      :underline nil
  		      :overline "gray40"
  		      :box nil
  		      :extend nil)
    (set-face-attribute 'org-block-end-line nil
    		      :inherit 'org-hide
    		      :height idiig/lower-font-height 
    		      :extend )
    (set-face-attribute 'org-link nil
    		      :inherit 'mode-line
  		      :height idiig/font-height)
    (set-face-attribute 'org-indent nil
    		      :inherit '(org-hide fixed-pitch)
  		      :height idiig/font-height)
    (set-face-attribute 'org-target nil
    		      :inherit '(shadow fixed-pitch)
    		      :height idiig/lower-font-height)
    (set-face-attribute 'org-cite nil
    		      :inherit 'variable-pitch
  		      :slant 'italic)

    ;; Make the document title a bit bigger
    (set-face-attribute 'org-document-title nil
    		      :inherit 'variable-pitch
    		      :weight 'bold
    		      :height 1.3)

    (setq-local line-spacing 0.3)
    
    (with-eval-after-load 'diminish
      (diminish 'org-indent-mode)
      (diminish 'buffer-face-mode)))

  ;; (add-hook 'org-mode-hook 'idiig/org-mode-face-settings)
#+end_src
***** 数学渲染
#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (add-to-list
     'org-preview-latex-process-alist
     '(idiig-dvisvgm
       :programs ("${pkgs.texliveMedium}/bin/latex" "${pkgs.texliveMedium}/bin/dvisvgm")
       :description "latex -> dvi -> svg (nix-store)"
       :message "use latex and dvisvgm from nix-store."
       :image-input-type "dvi"
       :image-output-type "svg"
       :image-size-adjust (0.8 . 1.0)
       :latex-compiler ("${pkgs.texliveMedium}/bin/latex -interaction nonstopmode -output-directory %o %f")
       :image-converter ("${pkgs.texliveMedium}/bin/dvisvgm %f --no-fonts --exact-bbox --scale=%S --output=%O")))

    (setq org-latex-create-formula-image-program 'idiig-dvisvgm))
#+end_src
***** Bullets
****** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  org-bullets
#+end_src
****** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (use-package org-bullets
    :after org
    ;; :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

  ;; (with-eval-after-load 'org
  ;;   (setq org-ellipsis " ▾"
  ;;         org-hide-emphasis-markers t))
#+end_src
***** 表格
****** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  valign
#+end_src
****** 配置
#+begin_src emacs-lisp
  (use-package valign
    :diminish valign-mode
    :hook (org-mode . valign-mode))
#+end_src
*** 括号匹配 
#+begin_src emacs-lisp
  ;; Org mode: pair $ for inline math, * for bold, / for italic, = for code
  (with-eval-after-load elec-pair
    (add-hook 'org-mode-hook
              (lambda ()
                (idiig/add-local-electric-pairs
                 '((?$ . ?$)		; Inline math $...$
  		 (?* . ?*)		; Bold *...*
  		 (?/ . ?/)		; Italic /.../
  		 (?= . ?=)		; Verbatim =...=
  		 (?~ . ?~))))))		; Code ~...~
#+end_src
*** 文献引用处理器 (=citeproc-el=)
**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  citeproc
#+end_src
**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (setq org-cite-export-processors
        '((latex biblatex)
          (html csl)
          (odt  csl)
          (t    biblatex))))
#+end_src
*** 出入引用配置 (=oc=, =oc-basic=)
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
=org-cite= 增强：插入后选择样式和参数。
**** 配置
#+begin_src emacs-lisp
  (with-eval-after-load 'oc
    (require 'oc-basic)
    (require 'subr-x)

    ;; 样式选择和参数输入
    (defun my/oc--ask-style-and-affixes ()
      "询问 citation 样式和附加参数。"
      (let* ((style-help "
  Style examples:
    cite/a/cf → Citeauthor – Aa, Bb, and Cc
    cite/a/c  → Citeauthor – Aa et al.
    cite/na   → citeyear – 2022
    cite/na/b → citeyearpar – (2022)
    cite/t/c  → Citet – Aa et al. (2022)
    cite/t/cf → citep* – Aa, Bb, and Cc (2022)
    cite/bc   → Cite – Aa et al. 2022
    cite/cf   → Citep – (Aa et al. 2022)")
             (presets '(("cite/a/cf" . ("a"  . "cf"))
                        ("cite/a/c"  . ("a"  . "c"))
                        ("cite/na"   . ("na" . ""))
                        ("cite/na/b" . ("na" . "b"))
                        ("cite/t/c"  . ("t"  . "c"))
                        ("cite/t/cf" . ("t"  . "cf"))
                        ("cite/bc"   . ("bc" . ""))
                        ("cite/cf"   . ("cf" . ""))))
             (choice (completing-read
                      "Citation style (? for help): "
                      (append (mapcar #'car presets) '("custom" "?"))
                      nil t nil nil "cite/cf"))
             (l "") (b ""))
        
        ;; 显示帮助
        (when (string= choice "?")
          (message "%s" style-help)
          (sit-for 3)
          (setq choice (completing-read "Citation style: "
                                        (append (mapcar #'car presets) '("custom"))
                                        nil t nil nil "cite/cf")))
        
        ;; 获取样式
        (if (not (string= choice "custom"))
            (let ((p (cdr (assoc choice presets))))
              (setq l (car p) b (cdr p)))
          (setq l (completing-read "Style (l): " '("a" "na" "t" "bc" "c" "cf" "") nil t ""))
          (setq b (completing-read "Variant (b): " '("b" "c" "cf" "") nil t "")))
        
        ;; 构建完整样式和参数
        (let* ((style (string-join (seq-filter (lambda (x) (and x (not (string-empty-p x))))
                                               (list l b))
                                   "/"))
               (prefix  (read-string "Prefix (optional): "))
               (locator (read-string "Locator (optional): "))
               (suffix  (read-string "Suffix (optional): ")))
          (list style prefix locator suffix))))

    ;; 修改插入点的 citation
    (defun my/oc--rewrite-cite-at-point (style prefix locator suffix)
      "在当前位置修改 citation 的样式和参数。"
      (save-excursion
        (let* ((ctx (org-element-context))
               (cite (if (eq (org-element-type ctx) 'citation)
                         ctx
                       (when (re-search-backward "\\[cite\\>" (max (point-min) (- (point) 1000)) t)
                         (org-with-point-at (match-beginning 0)
                           (org-element-citation-parser))))))
          (when cite
            (let* ((beg (org-element-begin cite))
                   (end (org-element-end   cite))
                   (has-style (save-excursion (goto-char beg) (looking-at-p "\\[cite/")))
                   (has-colon (save-excursion
                                (goto-char beg)
                                (re-search-forward "\\[cite\\(?:/[^:]]+\\)?\\(:\\)" end t))))
              
              ;; 添加样式
              (when (and (not has-style) (not (string-empty-p style)))
                (goto-char (+ beg 5))
                (insert "/" style)
                (setq end (+ end (length style) 1)))
              
              ;; 添加前缀
              (when (not (string-empty-p prefix))
                (unless has-colon
                  (goto-char beg)
                  (re-search-forward "\\[cite\\(?:/[^:]]+\\)?" end t)
                  (insert ":")
                  (setq end (1+ end)))
                (goto-char beg)
                (re-search-forward ":" end t)
                (insert prefix " ")
                (setq end (+ end (length prefix) 1)))
              
              ;; 添加定位符
              (when (not (string-empty-p locator))
                (goto-char beg)
                (when (re-search-forward "@[^; \t\n]+" end t)
                  (insert " " locator)
                  (setq end (+ end (length locator) 1))))
              
              ;; 添加后缀
              (when (not (string-empty-p suffix))
                (goto-char (1- end))
                (insert " " suffix)))))))

    ;; 主 advice：插入后弹出二次对话
    (defun my/oc-insert-then-ask (orig-fn arg)
      "插入引用后询问样式和参数。"
      (let ((ret (funcall orig-fn arg)))
        (run-at-time
         0 nil
         (lambda ()
           (condition-case err
               (pcase-let ((`(,style ,prefix ,locator ,suffix)
                            (my/oc--ask-style-and-affixes)))
                 (my/oc--rewrite-cite-at-point style prefix locator suffix))
             (quit  (message "Citation style canceled"))
             (error (message "Error setting citation style: %s" (error-message-string err))))))
        ret))

    ;; 挂载 advice
    (advice-add 'org-cite-insert :around #'my/oc-insert-then-ask))
#+end_src
*** 展示工具
**** =org-present=
用 =org-present= 作幻灯片发表。手动开启。
***** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  org-present
#+end_src
**** =ox-reveal=
***** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  ox-reveal
#+end_src
***** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (use-package ox-reveal
    :commands (org-export-dispatch)
    :after org
    :init
    (setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/")
    (setq org-reveal-mathjax t))
#+end_src
**** =dslide=
***** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  dslide
#+end_src
**** =org-modern=
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  org-modern
#+end_src
** AI辅助功能
*** API config
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
从 SOPS 加密的 YAML 文件中安全地获取密钥值。核心功能：从加密的配置文件中读取敏感信息（如 API tokens、密码等），避免在代码中硬编码明文密钥。
#+begin_src emacs-lisp
  (defun idiig/get-sops-secret-value (key &optional path)
    "Get secret value from SOPS-encrypted file.
  KEY is the key to lookup in the YAML file.
  PATH is the path to the secrets file (default: ~/.config/secrets.yaml).

  If the secrets file doesn't exist, display a helpful message with setup instructions."
    (let ((secrets-file (expand-file-name (or path "~/.config/secrets.yaml"))))
      (if (file-exists-p secrets-file)
          (let ((result (string-trim
                         (shell-command-to-string
  			(format "${pkgs.sops}/bin/sops -d %s | ${pkgs.yq-go}/bin/yq -r '.%s'" 
  				(shell-quote-argument secrets-file)
  				key)))))
            (if (or (string-empty-p result)
                    (string= result "null"))
                (error "Key '%s' not found in %s" key secrets-file)
              result))
        (error "Secrets file not found: %s

  To set up SOPS secrets:

  1. Install required tools:
     - sops: nix-env -iA nixpkgs.sops (or brew install sops)
     - yq: nix-env -iA nixpkgs.yq-go (or brew install yq)
     - age: nix-env -iA nixpkgs.age (or brew install age)

  2. Generate an age key:
     mkdir -p ~/.config/sops/age
     age-keygen -o ~/.config/sops/age/keys.txt

  3. Create .sops.yaml config:
     cat > ~/.config/.sops.yaml << EOF
     creation_rules:
       - path_regex: secrets\\.yaml$
         age: $(grep 'public key:' ~/.config/sops/age/keys.txt | cut -d: -f2 | tr -d ' ')
     EOF

  4. Create and edit your secrets file:
     sops %s

  5. Add your secrets in YAML format:
     gh_pat_mcp: your_github_token_here
     openai_key: your_openai_key_here

  For more info: https://github.com/getsops/sops" secrets-file))))
#+end_src
*** Copilot
**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  copilot
#+end_src
**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (use-package copilot
    :config
    (define-key copilot-completion-map (kbd "<tab>") 'copilot-accept-completion)
    (add-to-list 'copilot-indentation-alist '(prog-mode 2))
    (add-to-list 'copilot-indentation-alist '(org-mode 2))
    (add-to-list 'copilot-indentation-alist '(text-mode 2))
    (add-to-list 'copilot-indentation-alist '(lisp-mode 2))
    (add-to-list 'copilot-indentation-alist '(emacs-lisp-mode 2))

    (setq copilot-max-char 99999999))
#+end_src
*** Copilot Chat
**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  copilot-chat
#+end_src
**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (use-package copilot-chat
    :after (copilot)
    :custom
    (copilot-chat-use-polymode nil))
#+end_src
*** MCP
**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  mcp
#+end_src
**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
TODO: fix: filesystem Received notification:
method=notifications/cancelled, params=(:requestId 0 :reason McpError:
MCP error -32001: Request timed out)

#+begin_src emacs-lisp
  (use-package mcp
    :after gptel
    :custom
    (mcp-hub-servers
     `(("github" . (:command "${pkgs.nodejs}/bin/npx"
  			   :args ("-y" "@modelcontextprotocol/server-github")
  			   :env (:GITHUB_PERSONAL_ACCESS_TOKEN ,(idiig/get-sops-secret-value "gh_pat_mcp"))))
       ("duckduckgo" . (:command "${pkgs.uv}/bin/uvx"
  			       :args ("--python" "${pkgs.python313}/bin/python3.13"
  				      "duckduckgo-mcp-server")))
       ("nixos" . (:command "${pkgs.uv}/bin/uvx"
  			  :args ("--python" "${pkgs.python313}/bin/python3.13"
  				 "mcp-nixos")))
       ("fetch" . (:command "${pkgs.uv}/bin/uvx"
  			  :args ("--python" "${pkgs.python313}/bin/python3.13"
  				 "mcp-server-fetch")))
       ("filesystem" . (:command "${pkgs.nodejs}/bin/npx"
  			       :args ("-y" "@modelcontextprotocol/server-filesystem"
  				      ,(getenv "HOME"))))
       ("sequential-thinking" . (:command "${pkgs.nodejs}/bin/npx"
  					:args ("-y" "@modelcontextprotocol/server-sequential-thinking")))
       ("context7" . (:command "${pkgs.nodejs}/bin/npx"
  			     :args ("-y" "@upstash/context7-mcp")
  			     :env (:DEFAULT_MINIMUM_TOKENS "6000")))))
    :config (require 'mcp-hub)
    :hook (after-init . mcp-hub-start-all-server))
#+end_src
*** gptel
**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+BEGIN_SRC nix
  gptel
    gptel-fn-complete
    gptel-magit
#+END_SRC
**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
***** =gptel= 本体
#+begin_src emacs-lisp
  (use-package gptel
    :commands (gptel-mode
  	     gptel-chat
  	     gptel-complete
  	     gptel-menu
  	     gptel-fn-complete)
    :init
    (defvar idiig/copilot-model-list
      '(gpt-5-codex
        claude-sonnet-4.5
        claude-haiku-4.5
        gpt-5-mini
        grok-code-fast-1)
      "List of AI models available for Copilot.")
    :custom
    (gptel-model 'claude-sonnet-4.5)
    (gptel-default-mode 'org-mode)
    (gptel-use-curl t)
    (gptel-use-tools t)
    (gptel-confirm-tool-calls 'always)
    (gptel-include-tool-results 'auto)
    :config
    (require 'gptel-integrations)
    (require 'gptel-org)
    (setq gptel--system-message 
          (concat gptel--system-message " Make sure to use Chinese language."))
    (setq gptel-backend 
          (gptel-make-gh-copilot "Copilot"
                                 :stream t
                                 :models idiig/copilot-model-list))
    :hook (org-mode . (lambda ()
                        (when (and buffer-file-name
                                   (string-match-p "\\.ai\\.org\\'" buffer-file-name))
                          (gptel-mode 1)))))
#+end_src
***** 利用gptel的补全
#+begin_src emacs-lisp
  (use-package gptel-fn-complete
    :after gptel
    :commands (gptel-fn-complete)
    :init
    (defvar idiig/xref-map
      (let ((map (make-sparse-keymap)))
        (define-key map (kbd "c") #'gptel-fn-complete)
        (define-key map (kbd ".") #'xref-find-definitions)
        (define-key map (kbd ",") #'xref-go-back)
        (define-key map (kbd "/") #'xref-find-references)
        map)
      "Key customizations for AI and xref.")
    :bind
    ("C-c ." . idiig/xref-map))

#+end_src
***** git统合
#+begin_src emacs-lisp
  (use-package gptel-magit
    :after gptel
    :commands (gptel-magit-install)
    :hook (magit-mode . gptel-magit-install))
#+end_src
*** AI-pairing programming (=Aidermacs=)
**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
***** aidermacs.el
#+BEGIN_SRC nix
  aidermacs
#+END_SRC

***** Aider 目录路径
#+begin_src emacs-lisp  :noweb-ref ecfg
  (add-to-list 'exec-path "${pkgs.aider-chat}/bin")
#+end_src

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

=Aidermacs= 是一个用于在 Emacs 中使用 =Aider= 的 AI 辅助编程工具，集成了多
种 AI 模型服务，帮助用户在编程过程中获得智能建议和辅助。

***** API Key 环境变量
它需要 API Key 来使用 OpenAI 或者其他模型服务。目前我主要支持的模型服
务提供商有 OpenAI、Anthropic 和 Google。

#+begin_src emacs-lisp
  (defvar idiig/supported-providers '("openai" "anthropic" "google")
    "List of supported AI providers for Aider.")

  (defun idiig/provider-env-var (provider)
    "Return the environment variable name for the given PROVIDER.
  Uppercase the provider name and append '_API_KEY'."
    (let ((provider-lower (downcase provider)))
      (if (member provider-lower idiig/supported-providers)
          (concat (upcase provider-lower) "_API_KEY")
        (error "Unsupported provider: %s" provider))))

  (defun idiig/api-path (provider dir)
    "Return the file path for the API key of PROVIDER in directory DIR."
    (expand-file-name provider dir))

  (defun idiig/read-file-contents (file-path)
    "Return the contents of FILE-PATH as a string, with error handling."
    (condition-case err
        (if (file-exists-p file-path)
            (string-trim (with-temp-buffer
                           (insert-file-contents file-path)
                           (buffer-string)))
          (error "File does not exist: %s" file-path))
      (error
       (message "Error reading file %s: %s" file-path (error-message-string err))
       nil)))

  (defun idiig/setup-single-provider (provider api-dir)
    "Set up API key for a single PROVIDER from API-DIR.
  Return t on success, nil on failure."
    (let* ((provider-env (idiig/provider-env-var provider))
           (provider-path (idiig/api-path provider api-dir))
           (api-key (idiig/read-file-contents provider-path)))
      (if api-key
          (progn
            (setenv provider-env api-key)
            (message "Set %s from %s" provider-env provider-path)
            t)
        (progn
          (message "Failed to read API key for %s from %s" provider provider-path)
          nil))))

  (defun idiig/get-default-api-dir ()
    "Get the default API directory.
  Check if 'api-key' or 'api-keys' folder exists in current directory.
  Return the path if found, otherwise return current directory."
    (let ((current-dir default-directory)
          (possible-dirs '("api-key" "api-keys")))
      (or (seq-find (lambda (dir)
                      (let ((full-path (expand-file-name dir current-dir)))
                        (and (file-directory-p full-path) full-path)))
                    possible-dirs)
          ;; If none found, query user for directory using `read-directory-name`
  	(read-directory-name "Select API keys directory: " current-dir nil t))))

  (defun idiig/setup-api-keys (&optional api-dir)
    "Set up API keys for Aider from directory containing API files.
  If API-DIR is provided, use it directly. Otherwise, check if current
  folder has 'api-key' or 'api-keys' folder and use it as default.
  Interactively prompts for the directory with smart default."
    (interactive)
    (let* ((default-dir (idiig/get-default-api-dir))
           (prompt (if (string= default-dir default-directory)
                       "Select API keys directory: "
                     (format "Select API keys directory (default: %s): " 
                             (file-name-nondirectory (directory-file-name default-dir)))))
           (selected-dir (if (called-interactively-p 'any)
                             (read-directory-name prompt default-dir)
                           (or api-dir default-dir)))
           (results (mapcar (lambda (provider)
                              (idiig/setup-single-provider provider selected-dir))
                            idiig/supported-providers))
           (success-count (length (seq-filter #'identity results)))
           (total-count (length idiig/supported-providers)))
      
      ;; Provide comprehensive feedback
      (if (= success-count total-count)
          (message "Successfully set all %d API keys from directory: %s" 
                   total-count selected-dir)
        (message "Set %d of %d API keys from directory: %s (check messages for details)"
                 success-count total-count selected-dir))
      
      ;; Return success status for programmatic use
      (= success-count total-count)))
#+end_src

***** =Aidermacs= 配置
启用 =C-c a= 快捷键打开菜单。默认使用 =sonnet= 模型。

#+begin_src emacs-lisp
  (use-package aidermacs
    :bind (("C-c a" . aidermacs-transient-menu))
    :config
    (idiig/setup-api-keys)
    :custom
    (aidermacs-default-chat-mode 'architect)
    (aidermacs-default-model "sonnet"))
#+end_src

*** TODO COMMENT AI-Client (=claude-code=)
**** 依赖
#+begin_src nix :noweb-ref epkgs
  claude-code
#+end_src
**** 配置
#+begin_src emacs-lisp :noweb-ref ecfg
  ;; Add to your init.el
  (use-package claude-code
    :init
    (add-to-list 'exec-path "${pkgs.claude-code}/bin")
    :bind (("C-c c" . claude-code-transient)))
#+end_src

** 模态编辑 (=meow=)
*** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  meow
    meow-tree-sitter
#+end_src

*** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (use-package meow
    :init
    ;; https://github.com/meow-edit/meow/blob/master/KEYBINDING_QWERTY.org
    (require 'meow)
    (defun meow-setup ()
      (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
      (meow-motion-define-key
       '("j" . meow-next)
       '("k" . meow-prev)
       '("<escape>" . ignore))
      (meow-leader-define-key
       ;; Use SPC (0-9) for digit arguments.
       '("1" . meow-digit-argument)
       '("2" . meow-digit-argument)
       '("3" . meow-digit-argument)
       '("4" . meow-digit-argument)
       '("5" . meow-digit-argument)
       '("6" . meow-digit-argument)
       '("7" . meow-digit-argument)
       '("8" . meow-digit-argument)
       '("9" . meow-digit-argument)
       '("0" . meow-digit-argument)
       '("/" . meow-keypad-describe-key)
       '("?" . meow-cheatsheet))
      (meow-normal-define-key
       '("0" . meow-expand-0)
       '("9" . meow-expand-9)
       '("8" . meow-expand-8)
       '("7" . meow-expand-7)
       '("6" . meow-expand-6)
       '("5" . meow-expand-5)
       '("4" . meow-expand-4)
       '("3" . meow-expand-3)
       '("2" . meow-expand-2)
       '("1" . meow-expand-1)
       '("-" . negative-argument)
       '(";" . meow-reverse)
       '("," . meow-inner-of-thing)
       '("." . meow-bounds-of-thing)
       '("[" . meow-beginning-of-thing)
       '("]" . meow-end-of-thing)
       '("a" . meow-append)
       '("A" . meow-open-below)
       '("b" . meow-back-word)
       '("B" . meow-back-symbol)
       '("c" . meow-change)
       '("d" . meow-delete)
       '("D" . meow-backward-delete)
       '("e" . meow-next-word)
       '("E" . meow-next-symbol)
       '("f" . meow-find)
       '("g" . meow-cancel-selection)
       '("G" . meow-grab)
       '("h" . meow-left)
       '("H" . meow-left-expand)
       '("i" . meow-insert)
       '("I" . meow-open-above)
       '("j" . meow-next)
       '("J" . meow-next-expand)
       '("k" . meow-prev)
       '("K" . meow-prev-expand)
       '("l" . meow-right)
       '("L" . meow-right-expand)
       '("m" . meow-join)
       '("n" . meow-search)
       '("o" . meow-block)
       '("O" . meow-to-block)
       '("p" . meow-yank)
       '("q" . meow-quit)
       '("Q" . meow-goto-line)
       '("r" . meow-replace)
       '("R" . meow-swap-grab)
       '("s" . meow-kill)
       '("t" . meow-till)
       '("u" . meow-undo)
       '("U" . meow-undo-in-selection)
       '("v" . meow-visit)
       '("w" . meow-mark-word)
       '("W" . meow-mark-symbol)
       '("x" . meow-line)
       '("X" . meow-goto-line)
       '("y" . meow-save)
       '("Y" . meow-sync-grab)
       '("z" . meow-pop-selection)
       '("'" . repeat)
       '("<escape>" . ignore)))
    (meow-setup)
    :config
    (meow-global-mode 1))
#+end_src

#+RESULTS:
: meow-visit

给meow增加treesitter的功能：
#+begin_src emacs-lisp
  (require 'meow-tree-sitter)
  (meow-tree-sitter-register-defaults)  
#+end_src

在 meow-edit 退出 insert-state 时，当前输入方式自动被关闭，而再次进入
insert-state 时重新打开输入方式：
#+begin_src emacs-lisp
  (defvar-local the-late-input-method nil)
  (add-hook 'meow-insert-enter-hook
  	  (lambda ()
  	    (activate-input-method the-late-input-method)))
  (add-hook 'meow-insert-exit-hook
  	  (lambda ()
  	    (setq the-late-input-method current-input-method)
  	    (deactivate-input-method)))
#+end_src

** 多线程丰富功能 (=EAF=)
EAF（Emacs Application Framework）是一个在 Emacs 中运行的应用框架，我
偶尔使用这个框架来使用浏览器和 PDF 阅读器等应用。
*** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  (eaf.withApplications [ eaf-browser eaf-pdf-viewer ])
#+end_src

*** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  (require 'eaf)
  (require 'eaf-browser)
  (require 'eaf-pdf-viewer)
  (add-to-list 'exec-path "${pkgs.wmctrl}/bin")
  (setq eaf-webengine-default-zoom 2.0
          eaf-browse-blank-page-url "https://www.kagi.com"
          eaf-browser-auto-import-chrome-cookies nil   ; 非自动 cookies
          eaf-browser-enable-autofill t                ; 自动填充密码
          eaf-browser-enable-tampermonkey t)	     ; 使用油猴
#+end_src

** 特殊扩展
扩展主要针对不存在于 =nixpkgs= 中的包，这里我基本上使用了[[https://codeberg.org/heraplem/nix-emacs-extra/src/branch/emacs-application-framework/packages/eaf][这个链接的代
码和方法]]，由于Nix水平有限，我在代码中增加了一些注释提示自己：

#+begin_src nix :tangle externals/default.nix
  { inputs, pkgs, emacsPackages }: let
    inherit (builtins) readDir;
    inherit (pkgs) runCommand;
    inherit (pkgs.lib) attrNames attrsToList filter functionArgs hasAttr mergeAttrsList pipe readFile remove;
    packagesDir = ./.;
    packageSources = inputs // {
      # nano = inputs.nano-emacs;
    };
    importFile = dir: let
      packageFunction = import "${packagesDir}/${dir}";
    in emacsPackages.callPackage packageFunction (
      pipe ({
        elispFileVersion = file: let
          output = runCommand "${baseNameOf file}-version" { } ''
            ${emacsPackages.emacs}/bin/emacs -Q --batch \
              --eval "(require 'lisp-mnt)" \
              --eval '(setq pkg-version (lm-version "${file}"))' \
              --eval '(find-file (getenv "out"))' \
              --eval '(insert pkg-version)' \
              --eval '(save-buffer)'
          '';
        in readFile output;
        pkgFileVersion = file: let
          output = runCommand "${baseNameOf file}-version" { } ''
            ${emacsPackages.emacs}/bin/emacs -Q --batch \
              --eval '(find-file "${file}")' \
              --eval '(setq pkg-version (caddr (read (current-buffer))))' \
              --eval '(find-file (getenv "out"))' \
              --eval '(insert pkg-version)' \
              --eval '(save-buffer)'
          '';
        in readFile output;
        normalizeVersion = name: version: let
          output = runCommand "${name}-normalized-version" { } ''
            ${emacsPackages.emacs}/bin/emacs -Q --batch \
              --load package \
              --eval '(setq pkg-version (package-version-join (version-to-list "${version}")))' \
              --eval '(find-file (getenv "out"))' \
              --eval '(insert pkg-version)' \
              --eval '(save-buffer)'
          '';
        in readFile output;
        genericBuild = emacsPackages.callPackage "${inputs.nixpkgs}/pkgs/applications/editors/emacs/build-support/generic.nix" { };
        elpa2nix = "${inputs.nixpkgs}/pkgs/applications/editors/emacs/build-support/elpa2nix.el";
        melpa2nix = "${inputs.nixpkgs}/pkgs/applications/editors/emacs/build-support/melpa2nix.el";
      } // (if hasAttr dir packageSources then { package_src = packageSources.${dir}; } else { })
      ) [
        attrsToList
        # => [ 
        #      { name = "elispFileVersion"; value = <function>; }
        #      { name = "pkgFileVersion"; value = <function>; }
        #      { name = "normalizeVersion"; value = <function>; }
        #      { name = "genericBuild"; value = <function>; }
        #      { name = "elpa2nix"; value = "/path/to/elpa2nix.el"; }
        #      { name = "melpa2nix"; value = "/path/to/melpa2nix.el"; }
        #    ]
        (filter ({ name, ... }: hasAttr name (functionArgs packageFunction)))
        # => 假设 packageFunction 需要 elispFileVersion 和 genericBuild
        # => [ 
        #      { name = "elispFileVersion"; value = <function>; }
        #      { name = "genericBuild"; value = <function>; }
        #    ]
        (map ({ name, value }: { ${name} = value; }))
        # => [
        #      { elispFileVersion = <function>; }
        #      { genericBuild = <function>; }
        #    ]
        mergeAttrsList
        # => { 
        #      elispFileVersion = <function>;
        #      genericBuild = <function>;
        #    }
        # 一般来讲，我们会这么写 import XXX.nix { inherit attr; };
        # 这里相当于最后得到一个传入 XXX.nix 的一个参数集
      ]
    );  # Nix 中 pipe 的写法是 pipe <初始对象> [ <函数1> <函数2> ... ]
  in pipe packagesDir [                            # => ./. (当前包目录)
    readDir                                        # => { "package1" = "directory"; "package2" = "directory"; "default.nix" = "regular"; ... }
    attrNames                                      # => [ "package1" "package2" "default.nix" ... ]
    (remove "default.nix")                         # => [ "package1" "package2" ... ]
    (map (dir: { "${dir}" = importFile dir; }))    # => [ { "package1" = <derivation>; } { "package2" = <derivation>; } ... ]
    mergeAttrsList                                 # => { "package1" = <derivation>; "package2" = <derivation>; ... }
  ]
#+end_src

*** COMMENT EAF
EAF 是一个可编程扩展的框架，它自带一系列丰富的应用。
**** 外部元
eaf还没有在 =nixpkgs= 中被打包，所以需要自己打包依赖。
***** eaf本体
- 以下代码是外部元的链接
#+begin_src nix :noweb-ref externals
  eaf = {
    url = "github:emacs-eaf/emacs-application-framework";
    flake = false;
  };
#+end_src

- 以下代码是eaf的打包文件
#+begin_src nix :tangle externals/eaf/default.nix
  { package_src
  , elispFileVersion
  , lib
  , stdenv
  , writeText
  , melpaBuild
  , elpa2nix
  , melpa2nix
  , makeWrapper

  , python3
  , qt6

  , withSwayWMSupport ? stdenv.isLinux
  , jq ? null

  , withUnitySupport ? stdenv.isLinux
  , xdotool ? null

  , withX11Support ? true
  , wmctrl ? null
  }: let
    inherit (lib) readFile;
    
    python = python3.withPackages (pkgs: [
      pkgs.easyocr
      pkgs.epc
      pkgs.lxml
      pkgs.pygetwindow
      pkgs.pyqt6
      pkgs.pyqt6-sip
      pkgs.pyqt6-webengine
      pkgs.qrcode
      pkgs.requests
      pkgs.sexpdata
    ]);
  in (melpaBuild (finalAttrs: {
    pname = "eaf";
    version = elispFileVersion "${finalAttrs.src}/eaf.el";
    src = package_src;

    # 在这里添加makeWrapper作为构建依赖
    nativeBuildInputs = [ makeWrapper ];

    patchPhase = ''
      runHook prePatch

      sed -i s#'defcustom eaf-python-command .*'#'defcustom eaf-python-command "${python.interpreter}"'# eaf.el
      ${if withSwayWMSupport then "substituteInPlace eaf.el --replace jq ${jq}/bin/jq" else ""}
      ${if withUnitySupport then "substituteInPlace eaf.el --replace xdotool ${xdotool}/bin/xdotool" else ""}
      ${if withX11Support then "substituteInPlace eaf.el --replace wmctrl ${wmctrl}/bin/wmctrl" else ""}

      mv core/eaf-epc.el .
      mv extension/* .

      runHook postPatch
    '';

    elpa2nix = writeText "elpa2nix.el" ''
      ${readFile elpa2nix}
      (defun byte-recompile-directory (&rest _))
    '';
    melpa2nix = writeText "melpa2nix.el" ''
      ${readFile melpa2nix}
      (defun byte-recompile-directory (&rest _))
    '';
  })).overrideAttrs (old: {
    # 确保nativeBuildInputs被正确继承并添加makeWrapper
    nativeBuildInputs = (old.nativeBuildInputs or []) ++ [ makeWrapper ];
    
    # Override genericBuild's postInstall
    postInstall = ''
      DST=$out/share/emacs/site-lisp/elpa/$ename-$melpaVersion/

      mv eaf.py $DST
      mv applications.json $DST
      mv core $DST

      # 创建包装脚本目录
      mkdir -p $DST/bin

      # 直接创建包装脚本，使用PyQt6模块路径下的Qt库
      QT_LIB_PATH=$(${python}/bin/python -c "import os, PyQt6; print(os.path.join(os.path.dirname(PyQt6.__file__), 'Qt6/lib'))" 2>/dev/null)
      QT_PLUGIN_PATH=$(${python}/bin/python -c "import os, PyQt6; print(os.path.join(os.path.dirname(PyQt6.__file__), 'Qt6/plugins'))" 2>/dev/null)

     # 如果找不到常规路径，尝试其他可能的位置
     if [ ! -d "$QT_LIB_PATH" ] || [ ! -d "$QT_PLUGIN_PATH" ]; then
       QT_BASE_DIR=$(${python}/bin/python -c "import os, sys, PyQt6; print(os.path.normpath(os.path.join(os.path.dirname(PyQt6.__file__), '..', '..')))" 2>/dev/null)
       QT_LIB_PATH="$QT_BASE_DIR/lib"
       QT_PLUGIN_PATH="$QT_BASE_DIR/share/qt6/plugins"
     fi

     # 创建Python包装脚本
     makeWrapper ${python}/bin/python $DST/bin/eaf-python \
       --set LD_LIBRARY_PATH "$QT_LIB_PATH" \
       --set QT_PLUGIN_PATH "$QT_PLUGIN_PATH" \
       --set QT_QPA_PLATFORM_PLUGIN_PATH "$QT_PLUGIN_PATH/platforms" \
       --unset QT_XCB_GL_INTEGRATION \
       --unset XDG_DATA_DIRS

     # 修改eaf.el使用包装的Python
     sed -i s#'defcustom eaf-python-command .*'#'defcustom eaf-python-command "'$DST/bin/eaf-python'"'# $DST/eaf.el
  '';
  })
#+end_src

***** eaf浏览器
- 外部元链接
#+begin_src nix :noweb-ref externals
  eaf-browser = {
    url = "github:emacs-eaf/eaf-browser";
    flake = false;
  };
#+end_src

- 打包代码
#+begin_src nix :tangle externals/eaf-browser/default.nix
  { package_src
  , elispFileVersion
  , melpaBuild
  , buildNpmPackage
  , jq
  }: melpaBuild (finalAttrs: let
    version = elispFileVersion "${finalAttrs.src}/eaf-browser.el";
    nodeName = "browser";
    nodeModules = buildNpmPackage rec {
      pname = nodeName;
      inherit version;
      src = package_src;
      npmDepsHash = "sha256-MUf+fJdEfzU/0e4he7mVURE1osP+Jm28LduCEtcJAPg=";
      prePatch = ''
        find . -mindepth 1 -maxdepth 1 ! -name "*.json" -exec rm -rf {} ';'
        ${jq}/bin/jq 'setpath(["name"]; "${pname}") | setpath(["version"]; "${version}")' package.json > package.json.tmp
        mv package.json.tmp package.json
      '';
      dontNpmBuild = true;
    };
  in {
    pname = "eaf-browser";
    inherit version;
    src = package_src;
    postInstall = ''
      DST=$out/share/emacs/site-lisp/elpa/$ename-$melpaVersion/
      mv buffer.py $DST
      mv easylist.txt $DST
      ln -s ${nodeModules}/lib/node_modules/${nodeName}/node_modules $DST/node_modules
    '';
  })
#+end_src

***** eaf阅读器
- 外部元的链接
#+begin_src nix :noweb-ref externals
  eaf-pdf-viewer = {
    url = "github:emacs-eaf/eaf-pdf-viewer";
    flake = false;
  };
#+end_src

- 打包代码
#+begin_src nix :tangle -
#+end_src

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  eaf
    eaf-browser
    # (pkgs.crow-translate) ; not available for MacOS 
    # eaf-pdf-viewer
#+end_src

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  ;; (defvar idiig/eaf-path (concat user-emacs-directory "site-lisp/emacs-application-framework"))
  ;; (add-to-list 'load-path idiig/eaf-path)
  ;; (setq eaf-python-command (concat idiig/eaf-path "/eaf/bin/python"))

  (require 'eaf)
  (require 'eaf-browser)
  ;; (require 'eaf-pdf-viewer)

  (setq eaf-webengine-default-zoom 2.0
        eaf-browse-blank-page-url "https://kagi.com"
        eaf-browser-auto-import-chrome-cookies nil   ; 非自动 cookies
        eaf-browser-enable-autofill t                ; 自动填充密码
        eaf-browser-enable-tampermonkey t            ; 使用油猴
        )
#+end_src
