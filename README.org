#+TITLE: 基于 Nix Flakes 的 Emacs 配置

* 本配置的用法
:PROPERTIES:
:header-args: :tangle no
:END:

这份配置文件使用Nix Flakes管理包。使用Nix的这类系统管理的包的目的主要
是因为

- emacs内置的包管理器无法处理系统工具的依存：如 =ripgrep=, 特定版本的
  =python=

- 使用gitsubmodule相同

- 完全使用Nix的话，写配置和尝试包的体验感比较差

这份配置的解决法如下：

- 通过org-babel同时写作Nix和elisp。前者用于版本和包的管理，后者用于包
  的配置

- 可以在elisp中用 =$pkgs.git= 的方式直接引用Nix的包
  
- 提供一个函数加入一个新包时使用这个函数更新包列表
  
* 实现方式
:PROPERTIES:
:header-args: :tangle no
:END:

下面以配置 =Magit= 为例说明这个配置的方法。这里和大多数的配置一样我们
把整体目的一致的包放在一个集群实现。每个集群主要分成两个子节点，一个用
于安装包和依赖项，一个用于配置。配置部分可以细分为键位绑定，custom，
hook，config，自定义的函数。

依赖的部分可以从 =pkgs= [fn:pkgs: =nixpkgs.legacyPackages.${system}= ]
同时安装emacs外部的依赖。然后从 =epkgs= [fn:epkgs:
=pkgs.emacs.pkgs.withPackages= ]

这里稍微多做一些解释。在配置节里面，我们利用了org-babel的一些特性。首
先我们在一个汇总代码块中使用了 =:noweb=yes= [fn:noweb: 关于文学编程中
=noweb= 的解释可以参考 [[https://www.cs.tufts.edu/~nr/noweb/][这个链接]] 。本身我们还有一个 =:session= 的方式更
适合一些数据科学的工作流。这里我们主要为了和 =:tangle= 引起使用。]，然
后在后面的代码块中我们使用 =:noweb-ref= 参照汇总代码块，最后后续的这些
代码块都会在tangle时合并到第一个代码块中。这个被tangle的代码块在后续过
程中会被nix依赖代码读入作为配置。

* 如何使用？
:PROPERTIES:
:header-args: :tangle no
:END:

用emacs打开本文档， =M-x org-babel-tangle= 或使用快捷键 =C-c C-v t= 生
成flake.nix。接下去运行可以通过如下方式：

** 调试
#+begin_src sh
  nix run <path/to/this/config>
  source ~/.bashrc
  emacs
#+end_src

** 版本回滚

- 使用git：
#+begin_src sh
  git checkout <previous-commit>
  nix run
  source ~/.bashrc
  emacs
#+end_src

- 备份lock文件：
#+begin_src sh
  # 查看以前的版本
  nix flake metadata

  # 备份版本
  cp flake.lock flake.lock.bachup
  # 使用特定锁文件版本
  nix run --recreate-lock-file --inputs-from ./flake.lock.backup
#+end_src

* 配置本体
:PROPERTIES:
:header-args: :tangle no
:END:
** Flake 入口
包的安装基于下面的 =flake.nix= 和 =init.nix= 。

#+BEGIN_SRC nix :tangle flake.nix :noweb yes
  {
    description = "idiig's Emacs Configuration with Nix Flakes";

    inputs = {
      nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
      flake-utils.url = "github:numtide/flake-utils";
      emacs-overlay.url = "github:nix-community/emacs-overlay";
      <<externals>>
    };

    outputs = inputs@{ self, nixpkgs, flake-utils, emacs-overlay, ... }:
      let
        # 用于安装非 nixpkgs 元的外部包的函数
        mkPackages = pkgs: emacsPackages: import ./externals {
          inherit inputs pkgs emacsPackages;
        };
      in
        flake-utils.lib.eachDefaultSystem (system:
  	      let
            
  		      pkgs = import nixpkgs {
  			      inherit system;
  			      overlays = [ emacs-overlay.overlay ];
  		      };

  		      # 主配置文件
  		      emacsConfig = pkgs.writeText "init.el" ''
  	    <<ecfg>>
  	    '';

  		      # early-init 配置文件
  		      emacsEarlyInitConfig = pkgs.writeText "early-init.el" ''
  	    <<emacs-early-init-config>>
  	    '';

            # 首先定义你的基础 Emacs
            emacs = pkgs.emacs30-gtk3;

            # 定义覆盖函数
            overrides = final: prev: mkPackages pkgs final;
            
            # 创建扩展的包集合并选择包
            emacsWithPackages = ((pkgs.emacsPackagesFor emacs).overrideScope overrides).withPackages (epkgs: with epkgs; [
              <<epkgs>>
            ]);
            
  	      in {
  		      packages.default = pkgs.writeShellScriptBin "script" ''
  	      #!/usr/bin/env bash
  	      set -e

  	      # 导出配置到 nix-emacs
  	      EMACS_DIR="$HOME/nix-emacs"
  	      mkdir -p "$EMACS_DIR"
  	      ${pkgs.rsync}/bin/rsync ${emacsConfig} "$EMACS_DIR/init.el"
  	      ${pkgs.rsync}/bin/rsync ${emacsEarlyInitConfig} "$EMACS_DIR/early-init.el"

  	      # 路径
  	      <<sys-path>>

  	      # 更新 Emacs 路径（兼容 macOS 和 Linux）
          if sed --version 2>/dev/null | grep "(GNU sed)"; then
  		      sed -i '/^alias ne=/d' "$HOME/.bashrc"
  	      else
  		      sed -i \"\" '/^alias ne=/d' "$HOME/.bashrc"
  	      fi

  	      echo "alias ne='${emacsWithPackages}/bin/emacs --init-dir \"$EMACS_DIR\"'" >> "$HOME/.bashrc"

  	      # 提示用户手动 source 而不是直接执行，以避免 shell 继承问题
  	      echo "请手动运行 'source ~/.bashrc' 以使 alias 生效"
  	      echo "Emacs 配置已同步到 $EMACS_DIR"
  	      '';  
  	      });
  }
#+END_SRC

** Early init
:PROPERTIES:
:header-args: :noweb-ref emacs-early-init-config
:END:
#+begin_src emacs-lisp
  ;; 增加 GC 阈值，加快启动
  (setq gc-cons-threshold 402653184 gc-cons-percentage 0.6)

  ;; 启动完成后恢复正常 GC 设定
  (add-hook 'emacs-startup-hook
  	  (lambda ()
  	    (setq gc-cons-threshold 10485760
  		  gc-cons-percentage 0.1)))

  ;; 禁用bidi，加速大文件
  (setq-default bidi-display-reordering nil)
  (setq bidi-inhibit-bpa t
        long-line-threshold 1000
        large-hscroll-threshold 1000
        syntax-wholeline-max 1000)
#+end_src

** Emacs基建
*** Mac OS 键位设定
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  ;; 在mac中使用Command key作为meta
  (setq mac-option-key-is-meta nil
        mac-command-key-is-meta t
        mac-command-modifier 'meta
        mac-option-modifier 'none)

  ;; 便于使用mac的JIS日语键盘
  (global-set-key (kbd "C-¥") 'toggle-input-method)
#+end_src

*** 包管理和其他基础

这里我考虑了到底是否要使用 =use-package= 。因为我现在在使用 org mode
写配置文件的目的是希望可以穿插自然语言的代码描述，所以需要拆分代码。
=use-package= 这种一体成型的写法不是很适合这种风格。但考虑了实际写的过
程，我觉得大多数情况可以在配置代码前面作完整的整理，而不需要过于细粒度
的代码表述，然后在迁移的过程可能也比较简单。所以我最后还是决定改成使用
=use-package= 了。

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

- =use-package= ：用简介的宏语言描述包
- =diminish= ：用于隐藏一些 minor mode
  
#+begin_src nix
  use-package
    diminish
#+end_src

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  (require 'use-package)
  (require 'diminish)
#+end_src

*** 更好的默认设置
**** 本体的设定
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  ;; 关闭警告声
  (setq ring-bell-function 'ignore)

  ;; 确认使用y或n，而不是yes或no。
  (defalias 'yes-or-no-p 'y-or-n-p)

  ;; 不自动生成备份文件
  (setq make-backup-files nil)

  ;; 选中文字能被整体替换（与其他文本编辑器相同）
  (delete-selection-mode 1)

  ;; 文件最后添加新行
  (setq require-final-newline t)

  ;; 文件在外部更新时buffer更新
  (global-auto-revert-mode 1)
#+end_src

**** UI
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  ;; 基础设置
  (tool-bar-mode -1) ;; 关闭工具栏
  (scroll-bar-mode -1) ;; 关闭文件滑动控件
  (setq inhibit-splash-screen 1) ;; 关闭启动帮助画面
  (setq initial-frame-alist (quote ((fullscreen . maximized)))) ;; 全屏
  (setq initial-scratch-message nil) ;; 关闭scratch message
  (setq inhibit-startup-message t) ;; 关闭启动信息
  (setq frame-title-format
        ;; 窗口显示文件路径/buffer名
        '("" " idiig - "
          (:eval (if (buffer-file-name)
                     (abbreviate-file-name (buffer-file-name)) "%b"))))
  (setq ns-use-proxy-icon nil)  ;; 删除frame icon
#+end_src

- 主题
#+begin_src emacs-lisp
  (require-theme 'modus-themes)
#+end_src

**** 光标跳到新窗口
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

emacs在打开新的窗口时，默认光标维持在原来的窗口。比如当你使用
=describe-function= 时，光标不会跳到函数的简介窗口。在这类窗口我们本身
可以按 =q= 来退出和关闭窗口。所以跳转到新窗口非常便利。

- 专用buffer（display-buffer行为；主要影响 Emacs 自动创建的窗口（如
  help、compilation 等）。注意这里也会影响到 =magit= 这类 transient 窗
  口
  
#+begin_src emacs-lisp
  (setq switch-to-buffer-obey-display-actions t)
  (setq switch-to-buffer-in-dedicated-window 'pop)
  (customize-set-variable 'display-buffer-base-action
  			'((display-buffer-reuse-window display-buffer-same-window)
  			  (reusable-frames . t)))
#+end_src

- split-window时转跳到新窗口
  
#+begin_src emacs-lisp
  (defadvice split-window-below (after split-window-below-and-switch activate)
    "切换到新分割的窗口"
    (when (called-interactively-p 'any)
      (other-window 1)))

  (defadvice split-window-right (after split-window-right-and-switch activate)
    "切换到新分割的窗口"
    (when (called-interactively-p 'any)
      (other-window 1)))
#+end_src

**** 窗口的放大缩小转变为持续的行为
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

而不是要一直要重复 =C-x= 按键。后续行为使用默认 =^, V, {, }= 。

这里我没用 =C-x v= 是因为这个键位目前用于 =vc= 。

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x V") 'shrink-window)

  (defun idiig/window-adjust-advice (orig-fun &rest args)
    "使用 Emacs 风格按键 (^, V, {, }, +) 持续调整窗口大小。"
    (let* ((ev last-command-event)
  	 (echo-keystrokes nil))
      ;; 执行初始调整
      (apply orig-fun args)

      ;; 设置 transient map
      (let ((delta (car args))) 
        (set-transient-map
         (let ((map (make-sparse-keymap)))
  	 ;; 垂直调整
  	 (define-key map (kbd "^")
  		     `(lambda () (interactive) (enlarge-window ,delta nil)))
  	 (define-key map (kbd "V")
  		     `(lambda () (interactive) (shrink-window ,delta nil)))

  	 ;; 水平调整
  	 (define-key map (kbd "{")
  		     `(lambda () (interactive) (shrink-window ,delta t)))
  	 (define-key map (kbd "}")
  		     `(lambda () (interactive) (enlarge-window ,delta t)))

  	 ;; 平衡窗口
  	 (define-key map (kbd "+")
  		     (lambda () (interactive) (balance-windows)))
  	 ;; 最大化窗口
  	 (define-key map (kbd "M")
  		     (lambda () (interactive) (maximize-window)))
  	 ;; 最小化窗口
  	 (define-key map (kbd "m")
  		     (lambda () (interactive) (minimize-window)))
  	 map)
         nil nil
         "Use %k for further adjustment"))))

  ;; ;; 如果需要移除 advice:
  ;; (advice-remove 'enlarge-window #'idiig/window-adjust-advice)
  ;; (advice-remove 'shrink-window #'idiig/window-adjust-advice)
  ;; (advice-remove 'enlarge-window-horizontally #'idiig/window-adjust-advice)
  ;; (advice-remove 'shrink-window-horizontally #'idiig/window-adjust-advice)

  ;; 添加 advice
  (advice-add 'enlarge-window :around #'idiig/window-adjust-advice)
  (advice-add 'shrink-window :around #'idiig/window-adjust-advice)
  (advice-add 'enlarge-window-horizontally :around #'idiig/window-adjust-advice)
  (advice-add 'shrink-window-horizontally :around #'idiig/window-adjust-advice)
  (advice-add 'maximize-window :around #'idiig/window-adjust-advice)
  (advice-add 'minimize-window :around #'idiig/window-adjust-advice)
#+end_src

**** 文件的保存与新建
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  ;; 不存在文档时询问是否新建
  (add-hook 'before-save-hook
            (lambda ()
              (when buffer-file-name
                (let ((dir (file-name-directory buffer-file-name)))
                  (when (and (not (file-exists-p dir))
                             (y-or-n-p (format "Directory %s does not exist. Create it?" dir)))
                    (make-directory dir t))))))

  ;; 找文件时若无母文档则新建 
  (defadvice find-file (before make-directory-maybe
                               (filename &optional wildcards) activate)
    "Create parent directory if not exists while visiting file."
    (unless (file-exists-p filename)
      (let ((dir (file-name-directory filename)))
        (when dir
          (unless (file-exists-p dir)
            (make-directory dir t))))))
#+end_src

**** 最近文件
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

打开最近文件。

#+begin_src emacs-lisp
  (use-package recentf
    :defer t
    :commands
    (consult-recent-file)
    :init
    (setq recentf-save-file (expand-file-name "recentf" user-emacs-directory)
          recentf-max-saved-items 500
          recentf-max-menu-items 10)
    (setq recentf-exclude
          '("COMMIT_MSG"
            "COMMIT_EDITMSG"
            "github.*txt$"
            "/tmp/"
            "/sudo:"
            "/TAGS$"
            "/GTAGS$"
            "/GRAGS$"
            "/GPATH$"
            "\\.mkv$"
            "\\.mp[34]$"
            "\\.avi$"
            "\\.sub$"
            "\\.srt$"
            "\\.ass$"
            ".*png$"
            "Nutstore/org-files/"
            "bookmarks"))
    (setq recentf-max-saved-items 2048)
    (recentf-mode 1))

  ;; cleanup recent files
  (defun idiig/cleanup-recentf ()
    (progn
      (and (fboundp 'recentf-cleanup)
           (recentf-cleanup))))
  (add-hook 'kill-emacs-hook #'idiig/cleanup-recentf)
#+end_src

- 自动保存文件设置
  
#+begin_src emacs-lisp
  (use-package savehist
    :init
    (setq savehist-additional-variables
          ;; search entries
          '(search-ring regexp-search-ring)
          ;; 每一分钟保存一次
          savehist-autosave-interval 60
          ;; keep the home clean
          savehist-file (expand-file-name "savehist" user-emacs-directory))
    (savehist-mode t))
#+end_src

- 书签功能，打开时自动到原先编辑的位置

#+begin_src emacs-lisp
  (use-package bookmark
    :init
    (setq bookmark-default-file (expand-file-name "bookmarks" user-emacs-directory)
          bookmark-save-flag 1))
#+end_src

- 保存文件的编辑位置

#+begin_src emacs-lisp
  (use-package saveplace
    :init
    (setq save-place-file (expand-file-name "place" user-emacs-directory))
    (save-place-mode 1))
#+end_src

**** 便利的光标首尾移动
***** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  mwim
#+end_src
***** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

*mwim*: 跳到代码之前而非最前，或者代码后面而不是最后

#+begin_src emacs-lisp
  (use-package mwim
    :bind
    ("C-a" . mwim-beginning-of-code-or-line-or-comment)
    ("C-e" . mwim-end-of-code-or-line)
    :commands
    (mwim-beginning-of-code-or-line-or-comment
     mwim-end-of-code-or-line))
#+end_src

**** 折行与复原
***** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  unfill
#+end_src
***** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
- 物理折行与复原
#+begin_src emacs-lisp
  (use-package unfill
    :bind
    ("M-q" . unfill-toggle)
    :commands
    (unfill-toggle))
#+end_src
**** 更好的minibuffer
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
***** 原生设定
#+begin_src emacs-lisp
  (use-package emacs
    :init
    (progn
      ;; 为`completing-read-multiple'添加提示，比如[CRM<separator>]
      (defun crm-indicator (args)
        (cons (format "[CRM%s] %s"
                      (replace-regexp-in-string
                       "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                       crm-separator)
                      (car args))
              (cdr args)))
      (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

      ;; 不允许鼠标出现在minibuffer的提示中
      (setq minibuffer-prompt-properties
            '(read-only t cursor-intangible t face minibuffer-prompt))
      (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

      ;; 在emacs 28以后，非当前mode的指令都会被隐藏，vertico的指令也会隐藏
      (setq read-extended-command-predicate
            #'command-completion-default-include-p)

      ;; minibuffer可循环
      (setq enable-recursive-minibuffers t)))

  ;; http://trey-jackson.blogspot.com/2010/04/emacs-tip-36-abort-minibuffer-when.html
  ;; 使用鼠标时关闭minibuffer
  (defun idiig/stop-using-minibuffer ()
    "kill the minibuffer"
    (when (and (>= (recursion-depth) 1) (active-minibuffer-window))
      (abort-recursive-edit)))
  (add-hook 'mouse-leave-buffer-hook 'idiig/stop-using-minibuffer)

#+end_src

***** 基础五件套
****** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

#+begin_src nix
  vertico
    orderless
    marginalia
    embark
    consult
    embark-consult
#+end_src

****** 配置

- *Vertico*: 提供minibuffer补全UI

#+begin_src emacs-lisp
  (use-package vertico
    :after consult
    :custom
    (vertico-count 9)
    (vertico-cycle t)
    :init
    (vertico-mode))
#+end_src

- *Orderless*: 提供补全格式选择

#+begin_src emacs-lisp
  (use-package orderless
    :after
    (consult)
    :config
    (setq search-default-mode t)
    (defvar +orderless-dispatch-alist
      '((?% . char-fold-to-regexp)
        (?! . orderless-without-literal)
        (?`. orderless-initialism)
        (?= . orderless-literal)
        (?~ . orderless-flex)))

    (defun +orderless--suffix-regexp ()
      (if (and (boundp 'consult--tofu-char) (boundp 'consult--tofu-range))
          (format "[%c-%c]*$"
                  consult--tofu-char
                  (+ consult--tofu-char consult--tofu-range -1))
        "$"))
    ;; Recognizes the following patterns:
    ;; * ~flex flex~
    ;; * =literal literal=
    ;; * %char-fold char-fold%
    ;; * `initialism initialism`
    ;; * !without-literal without-literal!
    ;; * .ext (file extension)
    ;; * regexp$ (regexp matching at end)
    (defun +orderless-dispatch (word _index _total)
      (cond
       ;; Ensure that $ works with Consult commands, which add disambiguation suffixes
       ((string-suffix-p "$" word)
        `(orderless-regexp . ,(concat (substring word 0 -1) (+orderless--suffix-regexp))))
       ;; File extensions
       ((and (or minibuffer-completing-file-name
                 (derived-mode-p 'eshell-mode))
             (string-match-p "\\`\\.." word))
        `(orderless-regexp . ,(concat "\\." (substring word 1) (+orderless--suffix-regexp))))
       ;; Ignore single !
       ((equal "!" word) `(orderless-literal . ""))
       ;; Prefix and suffix
       ((if-let (x (assq (aref word 0) +orderless-dispatch-alist))
            (cons (cdr x) (substring word 1))
          (when-let (x (assq (aref word (1- (length word))) +orderless-dispatch-alist))
            (cons (cdr x) (substring word 0 -1)))))))
    
    ;; Define orderless style with initialism by default ; add migemo feature for japanese
    (orderless-define-completion-style +orderless-with-initialism
      (orderless-matching-styles '(orderless-initialism
                                   orderless-literal
                                   orderless-regexp)))
    
    (setq completion-styles '(orderless basic)
          completion-category-defaults nil
          ;;; Enable partial-completion for files.
          ;;; Either give orderless precedence or partial-completion.
          ;;; Note that completion-category-overrides is not really an override,
          ;;; but rather prepended to the default completion-styles.
          ;; completion-category-overrides '((file (styles orderless partial-completion))) ;; orderless is tried first
          completion-category-overrides '((file (styles partial-completion)) ;; partial-completion is tried first
                                          (buffer (styles +orderless-with-initialism))
                                          (consult-location (styles +orderless-with-initialism))
                                          ;; enable initialism by default for symbols
                                          (command (styles +orderless-with-initialism))
                                          (variable (styles +orderless-with-initialism))
                                          (symbol (styles +orderless-with-initialism)))
          orderless-component-separator #'orderless-escapable-split-on-space ;; allow escaping space with backslash!
          orderless-style-dispatchers '(+orderless-dispatch)))
#+end_src

- *Maginalia*: 增强minubuffer的annotation

#+begin_src emacs-lisp
  (use-package marginalia
    :after vertico
    ;; 只在minibuffer启用快捷键
    :bind (:map minibuffer-local-map ("M-A" . marginalia-cycle))
    :init
    (setq marginalia-align-offset 5)
    :config
    (marginalia-mode))
#+end_src

- *Consult*:
  
#+begin_src emacs-lisp
  (use-package consult
    :hook (after-init . (lambda () (require 'consult)))
    :bind (([remap M-x] . execute-extended-command)
           ([remap goto-line] . consult-goto-line)
           ([remap switch-to-buffer] . consult-buffer)
           ([remap find-file] . find-file)
  	 ([remap imenu] . consult-imenu)
           ("C-c r" . consult-recent-file)
           ("C-c y" . consult-yasnippet)
           ("C-c f" . consult-find)
           ("C-c s" . consult-line)
           ("C-c o" . consult-file-externally)
           ("C-c p f" . consult-ripgrep)
           (:map minibuffer-local-map
                 ("C-c h" . consult-history)
                 ("C-s" . #'previous-history-element)))
    :init
    (add-to-list 'exec-path "${pkgs.fd}/bin")
    (add-to-list 'exec-path "${pkgs.ripgrep}/bin")
    (defun idiig/consult-buffer-region-or-symbol ()
      "consult-line当前字符或选中区域."
      (interactive)
      (let ((input (if (region-active-p)
                       (buffer-substring-no-properties
                        (region-beginning) (region-end))
                     (thing-at-point 'symbol t))))
        (consult-line input)))
    (defun idiig/consult-project-region-or-symbol (&optional default-inputp)
      "consult-ripgrep 当前字符或选中区域."
      (interactive)
      (let ((input (if (region-active-p)
                       (buffer-substring-no-properties
                        (region-beginning) (region-end))
                     (thing-at-point 'symbol t))))
        (consult-ripgrep default-inputp input)))
    :config
    (progn
      ;; (defvar my-consult-line-map
      ;;   (let ((map (make-sparse-keymap)))
      ;;     (define-key map "C-s" #'previous-history-element)
      ;;     map))
      ;; (consult-customize consult-line :keymap my-consult-line-map)
      ;; ;; 禁止自动显示consult文件的内容
      (setq consult-preview-key "C-v")
      ;; 应用 Orderless 的正则解析到 consult-grep/ripgrep/find
      (defun consult--orderless-regexp-compiler (input type &rest _config)
        (setq input (orderless-pattern-compiler input))
        (cons
         (mapcar (lambda (r) (consult--convert-regexp r type)) input)
         (lambda (str) (orderless--highlight input str))))
      ;; 表示的buffer种类
      (defcustom consult-buffer-sources
        '(consult--source-hidden-buffer
          consult--source-buffer
          consult--source-file
          consult--source-bookmark
          consult--source-project-buffer
          consult--source-project-file)
        "Sources used by `consult-buffer'. See `consult--multi' for a description of the source values."
        :type '(repeat symbol))
      ;; ？提示检索buffer类型；f<SPC>=file, p<SPC>=project, etc..
      (define-key consult-narrow-map
  		(vconcat consult-narrow-key "?") #'consult-narrow-help)))
#+end_src

- *Embark*: minibuffer action 和自适应的context menu

#+begin_src emacs-lisp
  (use-package embark
    :after vertico
    :bind
    (("C-h B" . embark-bindings)  ;; alternative for `describe-bindings'
     (:map minibuffer-local-map
           ("C-;" . embark-act)         ;; 对函数进行设置操作 
           ("M-." . embark-dwim)        ;; 实施 
           ("C-c C-e" . embark-export)  ;; occur
           )) 
    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)
    :config
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))

  ;; embark-export弹出occur和grep mode的buffer
  (use-package embark-consult
    :ensure t
    :after (consult))
#+end_src

**** 撤销（vundo）

我原来使用 undotree ，现在使用 vundo。这些用于视觉化撤销树。这里我之绑
定了 =C-x u= ， =C-/= 我依然用的原生的 Undo，这样适合区分使用。

***** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

#+BEGIN_SRC nix 
  vundo
#+END_SRC

***** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  (use-package vundo
    :defer t
    :commands
    (vundo)
    :bind
    ("C-x u" . vundo))
#+end_src

**** 检索（ctrlf）

针对当前buffer利用 =Ctrlf= 而不在使用swiper和helm这类型的检索方式。
***** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

#+BEGIN_SRC nix 
  ctrlf
#+END_SRC

***** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

****** 启动 =ctrf=
#+begin_src emacs-lisp
  (require 'ctrlf)
  (ctrlf-mode +1)
#+end_src

****** 识别拼音
这里我写了一个函数 =pyim-cregex-build-lazy= 。这个函数的工作逻辑如下：

- 如果还没有初始化拼音数据，就先进行预热预热时会加载 "a"、"e"、"o" 这
  三个字符的拼音映射数据设置初始化标志，避免重复初始化
  - 接着分两种情况处理：
    1. 情况1 :: 单个字符且不是 a/e/o
       + 使用 regexp-quote 直接转义字符
       + 例如：输入 "z" → 直接匹配字符 "z"
       + 避免触发拼音转换，提高性能
    2. 情况2 :: 其他所有情况
       + 使用 pyim-cregexp-build 进行拼音转换，包括：
         1) 单个字符 "a"、"e"、"o"（常用韵母）
         2) 多个字符组合（如 "zh"、"zhong"）
- 设计目的
  1. 性能优化 :: 避免输入大多数单个字符时的拼音转换开销
  2. 保持功能 :: 在需要拼音搜索时正常工作
  3. 用户体验 :: 减少首次输入时的卡顿感
    
#+begin_src emacs-lisp
  (with-eval-after-load 'pyim
    
    (defvar pyim-ctrlf-initialized nil
      "Flag to track if pyim data has been initialized for ctrlf.")
    
    (defvar pyim-ctrlf-cache (make-hash-table :test 'equal)
      "Cache for pyim-cregexp-build results.")
    
    (defconst pyim-ctrlf-vowels-with-mapping '("a" "e" "o")
      "Vowels that have direct Chinese character mappings.")
    
    (defconst pyim-ctrlf-double-consonants '("zh" "ch" "sh")
      "Double-letter consonants that should use regex-quote for exact matching.")
    
    (defun pyim-cregexp-build-lazy (str)
      "Lazy wrapper for pyim-cregexp-build with caching."
      (unless pyim-ctrlf-initialized
        (message "Initializing pyim data for ctrlf...")
        ;; 预缓存常用字符的结果
        (dolist (vowel pyim-ctrlf-vowels-with-mapping)
          (let ((result (pyim-cregexp-build vowel)))
            (puthash vowel result pyim-ctrlf-cache)))
        (setq pyim-ctrlf-initialized t)
        (message "Pyim data initialized."))
      
      ;; 判断是否使用 regex-quote
      (if (or (and (= (length str) 1)
                   (not (member str pyim-ctrlf-vowels-with-mapping)))
              (member str pyim-ctrlf-double-consonants))
          (regexp-quote str)
        ;; 使用缓存或计算新结果
        (or (gethash str pyim-ctrlf-cache)
            (let ((result (pyim-cregexp-build str)))
              (puthash str result pyim-ctrlf-cache)
              result))))

    (add-to-list 'ctrlf-style-alist
                 '(pinyin-regexp . (:prompt "pinyin-regexp"
                                    :translator pyim-cregexp-build-lazy
                                    :case-fold ctrlf-no-uppercase-regexp-p
                                    :fallback (isearch-forward-regexp
                                               . isearch-backward-regexp)))))
#+end_src

**** 括号匹配
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (use-package emacs
    :init
    ;; 启用自动括号配对
    (electric-pair-mode t)
    
    :config
    ;; 配置 electric-pair-mode 行为
    (setq electric-pair-preserve-balance nil)
    ;; 使用保守的抑制策略
    ;; https://www.reddit.com/r/emacs/comments/4xhxfw/how_to_tune_the_behavior_of_eletricpairmode/
    (setq electric-pair-inhibit-predicate 'electric-pair-conservative-inhibit)
    
    ;; 保存默认的配对括号设置，以便创建模式特定的本地设置
    (defconst idiig/default-electric-pairs electric-pair-pairs)
    
    ;; 为特定模式添加本地电子配对
    (defun idiig/add-local-electric-pairs (pairs)
      "为当前缓冲区添加本地电子配对括号。
       
       参数:
         PAIRS: 要添加的括号对列表
       
       示例用法:
         (add-hook 'jupyter-org-interaction-mode-hook
                   (lambda () (idiig/add-local-electric-pairs '((?$ . ?$)))))"
      (setq-local electric-pair-pairs (append idiig/default-electric-pairs pairs))
      (setq-local electric-pair-text-pairs electric-pair-pairs))
    
    ;; 禁止自动配对尖括号 <>
    (add-function :before-until electric-pair-inhibit-predicate
                  (lambda (c) (eq c ?<)))
    
    ;; 增强的括号匹配高亮——即使光标在括号内也能高亮匹配的括号
    (define-advice show-paren-function (:around (fn) fix-show-paren-function)
      "即使光标不直接位于括号上，也能高亮匹配的括号。"
      (cond ((looking-at-p "\\s(") (funcall fn))
            (t (save-excursion
                 (ignore-errors (backward-up-list))
                 (funcall fn)))))
    
    ;; 启用括号匹配高亮
    (show-paren-mode t))
#+end_src

**** 语言无关的结构化编程
***** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  puni
#+end_src

***** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp :noweb yes
  (use-package puni
    :defer t
    :bind
    (:map puni-mode-map
    	([remap puni-kill-line] . idiig/puni-kill-line)
    	("C--" . idiig/puni-contract-region)
    	("C-=" . puni-expand-region))
    :init
    ;; The autoloads of Puni are set up so you can enable `puni-mode` or
    ;; `puni-global-mode` before `puni` is actually loaded. Only after you press
    ;; any key that calls Puni commands, it's loaded.
    (puni-global-mode)
    (add-hook 'term-mode-hook #'puni-disable-puni-mode)
    :config
    <<idiig/puni-kill-line>>
    <<idiig/puni-contract-region>>
    <<idiig/puni-expand-region-advice>>
  )
#+end_src
****** =puni-kill-line=
基于 =puni= 更改 =kill-line= ，在删除行的时候可以确认是否被包围在某个环境
中。如果被包围在某个环境中则删除到该环境的最后，如果没有则正常执行
=kill-line= 。
#+begin_src emacs-lisp :noweb-ref idiig/puni-kill-line
  (defun idiig/puni-kill-line (&optional n)
    "Kill a line forward while keeping expressions balanced.
  If forward kill is not possible, try backward. If still nothing
  can be deleted, kill the balanced expression around point."
    (interactive "p")
    (let ((bounds (puni-bounds-of-list-around-point)))
      (cond
       ;; Case 1: No list bounds found, try deleting surrounding sexp
       ((null bounds)
        (when-let ((sexp-bounds (puni-bounds-of-sexp-around-point)))
          (puni-delete-region (car sexp-bounds) (cdr sexp-bounds) 'kill)))

       ;; Case 2: Point is at end of bounds, try backward kill
       ((eq (point) (cdr bounds))
        (puni-backward-kill-line))

       ;; Case 3: Default forward kill
       (t
        (puni-kill-line n)))))
#+end_src
****** =idiig/puni-contract-region=
如无选中则保持 negative-argument,如有选中则缩小范围
#+begin_src emacs-lisp  :noweb-ref idiig/puni-contract-region 
  (defun idiig/puni-contract-region (&optional arg)
    "如无选中则保持 negative-argument,如有选中则缩小范围"
    (interactive "p")
    (if (region-active-p)
        (call-interactively #'puni-contract-region)
      (negative-argument arg)))
#+end_src

#+begin_src emacs-lisp
  ;; 添加 advice
  (with-eval-after-load 'puni
    (defun idiig/puni-expand-region-advice (orig-fun &rest args)
      "使用选中后的操作"
      
      (let* ((ev last-command-event)
             (echo-keystrokes nil))
        ;; 执行初始调整
        (apply orig-fun args)

        ;; 设置 transient map
        (let ((delta (car args))) 
  	(set-transient-map
  	 (let ((map (make-sparse-keymap)))
             ;; 持续扩大
             (define-key map (kbd "=") 'puni-expand-region)
             ;; 缩小范围
             (define-key map (kbd "-") 'puni-contract-region)
  	   ;; 其他操作
  	   ;; 检索
             (define-key map (kbd "/") 'idiig/consult-project-region-or-symbol)
             (define-key map (kbd "b") 'idiig/consult-buffer-region-or-symbol)
  	   ;; 加包围
  	   (define-key map (kbd ")") 'puni-wrap-round)
             (define-key map (kbd "]") 'puni-wrap-square)
  	   (define-key map (kbd "}") 'puni-wrap-curly)
  	   (define-key map (kbd ">") 'puni-wrap-angle)
  	   map)
  	 nil nil
  	 "Use %k for further adjustment"))))
    (advice-add 'puni-expand-region :around #'idiig/puni-expand-region-advice))
#+end_src

**** 覆盖 =<Backspace>= 和 =<DEL>= 等删除动作
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
***** =backward-hungry-delete=
向后删除时向后贪婪地删除连续的空白值。同时考虑对称的结构。
- 首先检查光标前面是否有连续的空白字符。
- 使用 =looking-back= 用于判断满足以下任何一个条件：
  - 光标之前在当前行是否有符合正则表达式 =(+ blank)= 的字符序列。
  - 光标是否在行首 =(bolp)= 。
- 如果有连续的空白字符或在行首：
  - 使用 =skip-chars-backward= 向后跳过这些字符，并记录开始位置 =start= 。
  - 然后 =delete-region= 用于删除从 =start= 到当前光标位置之间的字符。
#+begin_src emacs-lisp
  (defun idiig/backward-hungry-delete-advice (orig-fun &rest args)
    "Advice function to provide hungry delete functionality."
    (if (or (looking-back (rx (+ blank))) (bolp))
        (let ((start (save-excursion (skip-chars-backward " \t\f\n\r\v") (point))))
          (delete-region start (point)))
      (apply orig-fun args)))

  (defun idiig/apply-backward-hungry-delete-advice ()
    "Reapply the hungry delete advice to the current DEL key binding function."
    (let ((current-fun (key-binding (kbd "DEL"))))
      (advice-remove current-fun #'idiig/backward-hungry-delete-advice)    ; 移除旧的 advice
      (advice-add current-fun :around #'idiig/backward-hungry-delete-advice))) ; 应用新的 advice

  ;; 在 emacs-startup 时应用 advice
  (add-hook 'emacs-startup-hook #'idiig/apply-backward-hungry-delete-advice)

  ;; 如果你有其他 hook 如打开某种模式时，需要重新应用 advice，可添加对应 hook，例如：
  ;; (add-hook 'your-major-mode-hook #'idiig/reapply-backward-hungry-delete-advice)
#+end_src
***** =forward-hungry-delete=
向前删除时向前贪婪地删除连续的空白值。同时考虑对称的结构。
- 检查光标后的字符：
  - 使用 =looking-at= 判断光标后面的字符是否是一个或多个空白字符或换行符。
  - 如果匹配到，使用 =skip-chars-forward= 跳过所有这些字符并记录结束位置。
  - 使用 =delete-region= 删除从当前光标位置到记录的结束位置之间的所有空白。
- 字符删除逻辑：
  - 如果光标后没有多余的空白字符，使用 =dotimes= 循环和 =puni-forward-delete-char= 删除 =n= 个普通字符。
  - =unless (eobp)=: 确保在没有到达缓冲区末尾时进行字符删除，防止出现试图超出缓冲区范围的错误。
#+begin_src emacs-lisp
  (defun idiig/forward-hungry-delete-advice (orig-fun &rest args)
    "Advice function to provide forward hungry delete functionality."
    (if (looking-at (rx (or (1+ blank) "\n")))
        (let ((end (save-excursion
                     (skip-chars-forward " \t\f\v\n\r")
                     (point))))
          (delete-region (point) end))
      (apply orig-fun args)))

  (defun idiig/apply-forward-hungry-delete-advice ()
    "Apply the forward hungry delete advice to the current forward delete key binding function."
    (let ((current-fun (key-binding (kbd "C-d"))))
      (advice-remove current-fun #'idiig/forward-hungry-delete-advice) ; 移除旧的 advice
      (advice-add current-fun :around #'idiig/forward-hungry-delete-advice))) ; 应用新的 advice

  ;; 在 emacs-startup 时应用 advice
  (add-hook 'emacs-startup-hook #'idiig/apply-forward-hungry-delete-advice)

  ;; 如果你有其他 hook 需要重新应用 advice，可添加对应 hook，例如：
  ;; (add-hook 'your-major-mode-hook #'idiig/apply-forward-hungry-delete-advice)
#+end_src
***** =puni-backward-kill-word-or-region=
如无选中则杀掉前面的单词，如有选中则杀掉选中区域。
#+begin_src emacs-lisp
  (defun idiig/backward-kill-word-or-region-advice (orig-fun &rest args)
    "Enhance the C-w function to handle region more flexibly."
    (if (region-active-p)
        ;; 当有选中区域时，使用传递的参数调用原始C-w功能（例如 `puni-kill-region`）
        (apply orig-fun args)
      ;; 当没有选中区域时，执行删除单词操作
      (let ((backward-kill-word-fun (or (key-binding (kbd "M-<DEL>"))
                                        (key-binding (kbd "S-<delete>"))
                                        'backward-kill-word))) ; 默认删除单词函数
        (if (fboundp backward-kill-word-fun)
            (call-interactively backward-kill-word-fun) ; 交互式调用删除单词
          (message "No word kill bound function found for M-<DEL> or S-<delete>")))))

  (defun idiig/apply-backward-kill-word-or-region-advice ()
    "Advice C-w to optionally kill region or word."
    ;; 通过 `key-binding` 得到当前与 C-w 绑定的函数
    (let ((current-fun (key-binding (kbd "C-w"))))
      (advice-remove current-fun #'idiig/backward-kill-word-or-region-advice)
      (advice-add current-fun :around #'idiig/backward-kill-word-or-region-advice)))

  ;; 在 emacs 启动时应用这个 advice
  (add-hook 'emacs-startup-hook #'idiig/apply-backward-kill-word-or-region-advice)
#+end_src
** CJK字体
这里我统一使用的是Sarasa的等宽字体，可以避免2个问题：

- 输入latin以后输入cjk文字以后，由于字体高度不等导致行高抖动

- 方便org等表格等宽表示

*** 依赖
:PROPERTIES:
:header-args: :noweb-ref sys-path
:END:
#+begin_src sh
  if [ "$(uname)" = "Darwin" ]; then
      # macOS
      mkdir -p "$HOME/Library/Fonts/"
      ${pkgs.rsync}/bin/rsync -av ${pkgs.sarasa-gothic}/share/fonts/truetype/ "$HOME/Library/Fonts/"
  else
      # Assume Linux
      mkdir -p "$HOME/.local/share/fonts/truetype/"
      ${pkgs.rsync}/bin/rsync -av ${pkgs.sarasa-gothic}/share/fonts/truetype/ "$HOME/.local/share/fonts/sarasa-gothic/"
      fc-cache -f -v ~/.local/share/fonts/
  fi
#+end_src

*** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  (add-hook 'after-init-hook
  	  (lambda ()
  	    (let* ((screen-height (display-pixel-height))
  		   (font-height (if (> screen-height 1200) 230 130))  ;; 根据屏幕高度调整
  		   (minibuffer-font-height (- font-height 0))
  		   (my-font "Sarasa Mono SC"))
  	      (set-face-attribute 'default nil :family my-font :height font-height)
  	      ;; 设置 mode-line 字体
  	      (set-face-attribute 'mode-line nil :family my-font :height font-height)
  	      (set-face-attribute 'mode-line-inactive nil :family my-font :height font-height)
  	      ;; 设置 minibuffer 字体
  	      (set-face-attribute 'minibuffer-prompt nil :family my-font :height minibuffer-font-height))))

  ;; 工具栏，菜单保持默认字体
  (set-face-attribute 'menu nil :inherit 'unspecified)
  (set-face-attribute 'tool-bar nil :inherit 'unspecified)
#+end_src

** 日文
*** 输入法

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

#+BEGIN_SRC nix 
  ddskk
#+END_SRC

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  (use-package ddskk
    :defer t
    :bind (("C-x j" . skk-mode))
    :config
    (setq skk-server-inhibit-startup-server nil)
    (setq skk-server-host "localhost")
    (setq skk-server-portnum 55100)
    (setq skk-share-private-jisyo t)

    ;; 候补显示设置
    (setq skk-show-inline t)
    (setq skk-show-tooltip t)
    (setq skk-show-candidates-always-pop-to-buffer t)
    (setq skk-henkan-show-candidates-rows 2)

    ;; 行为设置
    (setq skk-egg-like-newline t)
    (setq skk-delete-implies-kakutei nil)
    (setq skk-use-look t)
    (setq skk-auto-insert-paren t)
    (setq skk-henkan-strict-okuri-precedence t)

    ;; 片假名转换设置
    (setq skk-search-katakana 'jisx0201-kana)

    ;; 加载额外功能
    (require 'skk-hint)
    :hook
    (skk-load . (lambda ()
                  (require 'context-skk))))
#+end_src

*** TODO 检索（Migemo）

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

** 中文
*** 输入法

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

#+BEGIN_SRC nix 
  pyim
    pyim-basedict
#+END_SRC

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

***** 基础设定
#+begin_src emacs-lisp
  (use-package pyim
    :diminish pyim-isearch-mode
    :commands
    (toggle-input-method)
    :custom
    (default-input-method "pyim")
    (pyim-dcache-directory (concat user-emacs-directory "pyim/dcache"))
    (pyim-default-scheme 'quanpin)
    (pyim-page-tooltip 'popup)
    (pyim-page-length 4))

  ;; 加载并启用基础词库
  (use-package pyim-basedict
    :after pyim
    :config
    (pyim-basedict-enable))
#+end_src

***** TODO 正则表达交互

目前支持

- 在minibuffer中用 =C-Ret= 把单字拼音转换为该读音本身代表的中文正则表达
- =M-x idiig/toggle-pyim-region= 用于开关中文的forward-word和backward
- 激活进入pyim时，自动开启中文的forward和backward
  
#+begin_src emacs-lisp
  (with-eval-after-load 'pyim
    (require 'pyim-cstring-utils)

    ;; C-return 把当前选中的位置转换为正则表达
    (define-key minibuffer-local-map (kbd "C-<return>") 'pyim-cregexp-convert-at-point)

    (defvar idiig/pyim-region-enabled nil
      "记录pyim区域功能是否启用的状态变量。")

    (defun idiig/toggle-pyim-region ()
      "切换pyim的单词移动功能。
  当启用时，会将forward-word和backward-word重映射为pyim的相应函数；
  当禁用时，会恢复原来的映射。"
      (interactive)
      (if idiig/pyim-region-enabled
  	(progn
  	  (idiig/disable-pyim-region)
  	  (setq idiig/pyim-region-enabled nil)
  	  (message "已禁用pyim区域功能"))
        (progn
  	(idiig/enable-pyim-region)
  	(setq idiig/pyim-region-enabled t)
  	(message "已启用pyim区域功能"))))

    (defun idiig/enable-pyim-region (&rest _)
      "启用pyim的单词移动建议。"
      (global-set-key [remap forward-word] 'pyim-forward-word)
      (global-set-key [remap backward-word] 'pyim-backward-word))

    (defun idiig/disable-pyim-region (&rest _)
      "禁用pyim的单词移动建议。"
      (global-unset-key [remap forward-word])
      (global-unset-key [remap backward-word]))

    ;; ;; 挂钩到 pyim 的启用/禁用钩子上
    ;; (advice-remove 'pyim-deactivate #'idiig/disable-pyim-region)
    ;; (advice-remove 'pyim-activate #'idiig/enable-pyim-region)
    ;; (advice-add 'pyim-deactivate :after #'idiig/disable-pyim-region)
    (advice-add 'pyim-activate :after #'idiig/enable-pyim-region))
#+end_src

#+RESULTS:

***** Orderless交互

#+begin_src emacs-lisp
  ;; 确保在 orderless 加载后再加载这些配置
  (with-eval-after-load 'orderless
    ;; 拼音检索字符串功能
    (defun zh-orderless-regexp (orig_func component)
      (call-interactively #'pyim-activate)
      (call-interactively #'pyim-deactivate)
      (let ((result (funcall orig_func component)))
        (pyim-cregexp-build result)))
    (advice-add 'orderless-regexp :around #'zh-orderless-regexp))
#+end_src

** Git（Magit）
用 Magit 进行项目与版本的管理
*** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

#+BEGIN_SRC nix
  magit
#+END_SRC

*** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

**** Magit

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind ("C-x g" . magit-status)
    :commands magit-status
    :init
    ;; 使用nix路径中的git
    (add-to-list 'exec-path "${pkgs.git}/bin"))
#+END_SRC

** 文档写作
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
*** 文档后缀
  
#+begin_src emacs-lisp
  (defvar idiig/writing-environment-list '("\\.org\\'"
                                           "\\.md\\'"
                                           "\\.qmd\\'"
                                           "\\.rmd\\'"
                                           "\\.typ\\'"
                                           "\\.tex\\'"
                                           "\\.bib\\'"
                                           "\\.txt\\'"))
#+end_src

*** 文档状态折行
  
#+begin_src emacs-lisp
  (defun idiig/in-writing-environment-p ()
    "Check if current buffer file matches any pattern in idiig/writing-environment-list."
    (when (buffer-file-name)
      (cl-some (lambda (pattern)
                 (string-match-p pattern (buffer-file-name)))
               idiig/writing-environment-list)))

  (add-hook 'find-file-hook
            (lambda ()
              (when (idiig/in-writing-environment-p)
                (visual-line-mode 1))))

  (with-eval-after-load 'diminish
    (diminish 'visual-line-mode))
#+end_src

*** 在选中区域的状态下 =C-w= 删除选中的区域

在没选中的状态下删除上一个单词。

#+begin_src emacs-lisp
  (with-eval-after-load 'puni
    (defun idiig/backward-kill-word-or-region (&optional arg)
      (interactive "p")
      (if (region-active-p)
  	(call-interactively #'puni-kill-active-region)
        (backward-kill-word arg)))

    (global-set-key (kbd "C-w") 'idiig/backward-kill-word-or-region))
#+end_src

*** =C-M-\= 全局缩进

全局缩进

#+begin_src emacs-lisp
  (defun idiig/indent-buffer()
    (interactive)
    (indent-region (point-min) (point-max)))

  (defun idiig/indent-region-or-buffer()
    (interactive)
    (save-excursion
      (if (region-active-p)
          (progn
            (indent-region (region-beginning) (region-end)))
        (progn
          (idiig/indent-buffer)))))

  (global-set-key (kbd "C-M-\\") 'idiig/indent-region-or-buffer)
  (global-set-key (kbd "C-M-¥") 'idiig/indent-region-or-buffer)  ;; JIS keyboard
#+end_src

*** =Shift-Ret= 下方插入空白行

#+begin_src emacs-lisp
  (global-set-key [(shift return)] 'idiig/smart-open-line)
#+end_src

*** =M--= 匹配到括号 

TODO: 把 evil-jump-item 换成别的函数。

#+begin_src emacs-lisp
  (defun idiig/goto-match-paren (arg)
    "Go to the matching if on (){}[], similar to vi style of % "
    (interactive "p")
    ;; first, check for "outside of bracket" positions expected by forward-sexp, etc
    (cond ((looking-at "[\[\(\{]") (evil-jump-item))
          ((looking-back "[\]\)\}]" 1) (evil-jump-item))
          ;; now, try to succeed from inside of a bracket
          ((looking-at "[\]\)\}]") (forward-char) (evil-jump-item))
          ((looking-back "[\[\(\{]" 1) (backward-char) (evil-jump-item))
          (t nil)))

  (bind-key* "M--" 'idiig/goto-match-paren)
#+end_src

*** 点后插入空白

#+begin_src emacs-lisp
  (defun idiig/insert-space-after-point ()
    (interactive)
    (save-excursion (insert " ")))

  (bind-key* "C-." 'idiig/insert-space-after-point)
#+end_src

** 编程工具
*** 我有可能使用的语言
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  ;; TODO: 这里未来需要改成在每个语言的设定的节点push进来
  (defvar idiig/language-list
    '("emacs-lisp" "python" "ditaa" "plantuml" "shell" "nix"
      "R" "haskell" "latex"  "css")
    "支持的编程语言列表。")

  (defun idiig/run-prog-mode-hooks ()
    "Runs `prog-mode-hook'. 针对一些本该为编程语言又没自动加载prog mode的语言hook.
  如：(add-hook 'python-hook 'idiig/run-prog-mode-hooks)
  "
    (run-hooks 'prog-mode-hook))
#+end_src

*** 语言服务器（LSP-Bridge)
:PROPERTIES:
:CUSTOM_ID: lsp-bridge
:END:

语言服务器用于补全代码，提示文档，参照转跳等。这里我使用了 LSP-Bridge，
其主要优势是通过 python 后端调用语言服务器，不卡 emacs 进程达到高速的
补全。其他倾向的代替选项有 emacs 捆绑 =eglot= 。

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

#+begin_src nix
  (lsp-bridge.override {
    # 指定使用 Python 3.11 而不是 3.12
    python3 = pkgs.python311;
  })
    markdown-mode
    yasnippet
#+end_src

这里由于默认的 python (3.12.9) 版本问题导致了下面的报错：

- 首先尝试导入 =SimpleXMLRPCServer= 模块失败，这是因为在 Python 3 中，
  该模块已被移至 =xmlrpc.server=
- 随后在导入 =xmlrpc.client= 时出现了一个奇怪的错误:
  ~'datetime.datetime' object has no attribute 'task'~

这可能是 Python 3.12.9 中的一个 bug，或者是 epc 包与 Python 3.12.9 不
兼容的结果。因此我们在 =lsp-bridge= 的环境中使用了 311 的版本。

#+begin_example
  Traceback (most recent call last):
    File "/nix/store/1bn994va1akp3m0jvg4fj9wzlqmn1kkq-python3-3.12.9-env/lib/python3.12/site-packages/epc/py3compat.py", line 26, in <module>
      import SimpleXMLRPCServer
  ModuleNotFoundError: No module named 'SimpleXMLRPCServer'

  During handling of the above exception, another exception occurred:

  Traceback (most recent call last):
    File "/nix/store/4mx09lzrlahhkgv7qb2q57xmnsfwcmlx-emacs-packages-deps/share/emacs/site-lisp/elpa/lsp-bridge-20250210.0/lsp_bridge.py", line 46, in <module>
      from epc.server import ThreadingEPCServer
    File "/nix/store/1bn994va1akp3m0jvg4fj9wzlqmn1kkq-python3-3.12.9-env/lib/python3.12/site-packages/epc/server.py", line 20, in <module>
      from .py3compat import SocketServer
    File "/nix/store/1bn994va1akp3m0jvg4fj9wzlqmn1kkq-python3-3.12.9-env/lib/python3.12/site-packages/epc/py3compat.py", line 28, in <module>
      import xmlrpc.server as SimpleXMLRPCServer
    File "/nix/store/26yi95240650jxp5dj78xzch70i1kzlz-python3-3.12.9/lib/python3.12/xmlrpc/server.py", line 107, in <module>
      from xmlrpc.client import Fault, dumps, loads, gzip_encode, gzip_decode
    File "/nix/store/26yi95240650jxp5dj78xzch70i1kzlz-python3-3.12.9/lib/python3.12/xmlrpc/client.py", line 272, in <module>
      if _try('%Y'):      # Mac OS X
         ^^^^^^^^^^
    File "/nix/store/26yi95240650jxp5dj78xzch70i1kzlz-python3-3.12.9/lib/python3.12/xmlrpc/client.py", line 269, in _try
      return _day0.strftime(fmt) == '0001'
             ^^^^^^^^^^^^^^^^^^^
  AttributeError: 'datetime.datetime' object has no attribute 'task'
#+end_example

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  (defmacro idiig//setup-nix-lsp-bridge-server (language server-name executable-path &optional lib-path)
    "配置 Nix 环境下的 LSP 服务器。
  LANGUAGE 是语言名称，如 'python'。
  SERVER-NAME 是服务器名称，如 'basedpyright'。
  EXECUTABLE-PATH 是服务器可执行文件的路径。
  LIB-PATH 是可选的库路径，添加到 LD_LIBRARY_PATH。"
    `(with-eval-after-load 'lsp-bridge
       ;; 设置 LSP 服务器
       (setq ,(intern (format "lsp-bridge-%s-lsp-server" language)) ,server-name)
       
       ;; 添加可执行文件路径到 exec-path
       ,(when executable-path
          `(add-to-list 'exec-path ,executable-path))
       
       ;; 添加库路径到 LD_LIBRARY_PATH
       ,(when lib-path
          `(setenv "LD_LIBRARY_PATH" 
                   (concat ,lib-path ":" 
                           (or (getenv "LD_LIBRARY_PATH") ""))))))
#+end_src

上面这个宏用于生成 LSP-Bridge 的设定，因为语言服务器本身需要用户自己安
装，而本配置又需要 Nix 保证复现，所以我们需要把 nix 路径的语言服务器传
递给 emacs ，而且语言服务器往往需要匹配的 C++ 的库。因此我希望通过上面
的代码生成系列配置，同时设定语言，语言服务器，语言服务器的可执行文件路
径，依赖的 C 库。宏使用如下：

#+begin_src emacs-lisp :noweb-ref -
  (idiig//setup-nix-lsp-bridge-server 
   "python" 
   "basedpyright" 
   "${pkgs.basedpyright}/bin" 
   "${pkgs.stdenv.cc.cc.lib}/lib")
#+end_src

宏展开后如下：

#+begin_src emacs-lisp :noweb-ref -
  (with-eval-after-load 'lsp-bridge
    (setq lsp-bridge-python-lsp-bridge-server "basedpyright")
    (add-to-list 'exec-path "${pkgs.basedpyright}/bin")
    (setenv "LD_LIBRARY_PATH" 
            (concat "${pkgs.stdenv.cc.cc.lib}/lib:" 
                    (or (getenv "LD_LIBRARY_PATH") ""))))
#+end_src

后面是 LSP-Bridge 本体的配置：

#+begin_src emacs-lisp
  (use-package lsp-bridge
    :defer t
    :diminish lsp-bridge-mode
    :bind
    (:map acm-mode-map
          ("C-j" . acm-select-next)
          ("C-k" . acm-select-prev))
    :custom
    (acm-enable-yas nil)   ; 补全不包括 Yasnippet
    (acm-enable-doc nil)   ; 不自动显示函数等文档
    (lsp-bridge-org-babel-lang-list idiig/language-list)  ; org支持的代码也使用桥
    (acm-enable-icon nil)  ; 不显示图标
    :hook 
    (prog-mode . (lambda ()
  		 (lsp-bridge-mode)))
    :init
    ;; 这里是为了让语言服务器找到正确的版本的 libstdc++.so.6 库
    (setenv "LD_LIBRARY_PATH" 
            (concat "${pkgs.stdenv.cc.cc.lib}/lib:" 
                    (or (getenv "LD_LIBRARY_PATH") ""))))
#+end_src

*注意* ：语言服务器不会自动安装，如果在新电脑中出现缺少个别语言服务器
的情况，我们可以手动安装。

*** TODO Treesitter

用于解析语法和语法高亮

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  # treesit  # 目前 treesit 已经内置
  treesit-auto
#+end_src

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  (use-package treesit-auto
    :custom
    (treesit-auto-install 'prompt)   ; 设置安装 tree-sitter 语法时提示用户确认
    :hook
    (prog-mode . treesit-auto-mode)    ; 在所有编程模式下自动启用 treesit-auto-mode
    :config
    (treesit-auto-add-to-auto-mode-alist 'all))  ; 将所有已知的 tree-sitter 模式添加到自动模式列表中
#+end_src

这个配置设置了 =treesit-auto= 包，这是一个帮助管理和自动启用 Emacs 内
置 =tree-sitter= 模式的工具。会在启动 major mode 的时候自动替换为
=<major>-ts-mode= 。比如 python-mode 会变成 python-ts-mode。

*注意* ：treesit 不会自动安装，如果在新电脑中出现缺少 treesit 的情况，
我们可以手动 =treesit-auto-install-all= 。下载目前所有可能的语言的
treesit。

*** Snippet（Yasnippet）

Snippet 用于快速插入模板

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

这里 =yasnippet= 本体已经作为 =lsp-bridge= 的依赖被加入，我们这里只加
入一个 snippet 的合集 =yasnippert-snippets= 。

#+begin_src nix
  # yasnippet
  yasnippet-snippets
    consult-yasnippet
#+end_src

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  ;; (defvar idiig/snippet-dir (concat user-emacs-directory "snippets"))
  (use-package yasnippet
    :defer t
    :diminish yas-minor-mode
    :hook
    (prog-mode . yas-minor-mode)
    :init
    ;; (setq yas-snippet-dirs <path/to/snippets>)
    ;; (push idiig/snippet-dir yas-snippet-dirs)
    :config
    (yas-reload-all))
#+end_src

加载用于yasnippet的的合集

#+begin_src emacs-lisp
  (use-package consult-yasnippet
    :after
    (consult
     yas-minor-mode))
#+end_src

*** 基于 tresitter 的结构化编程

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
#+end_src

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
#+end_src

** 编程与文档语言
*** Nix

**** 依赖
#+begin_src nix :noweb-ref epkgs
  nix-mode
#+end_src

加入 nix 的 major mode。

#+begin_src emacs-lisp :noweb-ref ecfg
  (idiig//setup-nix-lsp-bridge-server 
   "nix" 
   "nixd" 
   "${pkgs.nixd}/bin" 
   nil)
#+end_src

设置 nix 的语言服务器。注意这里使用的是在 LSP-Bridge 节中写的宏（参看
[[#lsp-bridge]]）。

**** 配置

*** Python

**** 依赖

#+begin_src emacs-lisp :noweb-ref ecfg
  (idiig//setup-nix-lsp-bridge-server 
   "python" 
   "basedpyright" 
   "${pkgs.basedpyright}/bin" 
   "${pkgs.stdenv.cc.cc.lib}/lib")
#+end_src

**** 配置

*** R

*** Elisp
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

- =M-:= 时的 eval expression minibuffer 的时候加入 prog mode。
#+begin_src emacs-lisp
  (add-hook 'eval-expression-minibuffer-setup 'idiig/run-prog-mode-hooks)
#+end_src

*** Shell

用 =bash= 作为默认 shell
#+begin_src emacs-lisp :noweb-ref ecfg
  ;; (setq shell-command-switch "-ic")
  (setq-default explicit-shell-file-name "${pkgs.bashInteractive
  }/bin/bash")
  (setq shell-file-name "${pkgs.bashInteractive
  }/bin/bash")
#+end_src

*** Make

*** TeX

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src nix :noweb-ref epkgs
  auctex
    auctex-latexmk
#+end_src

#+begin_src emacs-lisp
  (idiig//setup-nix-lsp-bridge-server 
   "tex" 
   "texlab" 
   "${pkgs.texlab}/bin" 
   nil)
#+end_src

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  (add-hook 'TeX-mode-hook 'idiig/run-prog-mode-hooks)
#+end_src

#+begin_src emacs-lisp
  (use-package auctex
    :defer t)
#+end_src

*** Typst

*** Markdown

*** Quarto

*** XML

*** Web

*** Java
**** 依赖
#+begin_src nix :noweb-ref 
  (pkgs.jre_minimal)
#+end_src

*** PlantUML

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

#+begin_src nix
  plantuml-mode
#+end_src

#+begin_src emacs-lisp :noweb-ref ecfg
  (add-to-list 'exec-path "${pkgs.plantuml}/bin")
  (with-eval-after-load 'org
    (setq org-plantuml-jar-path "${pkgs.plantuml}/lib/plantuml.jar")
    (setq org-plantuml-executable-path "${pkgs.plantuml}/bin/plantuml")
    (setq org-plantuml-exec-mode 'plantuml))
#+end_src

*** GraphViz

**** 依赖
#+begin_src emacs-lisp :noweb-ref ecfg
  (add-to-list 'exec-path "${pkgs.graphviz}/bin")
#+end_src

** Org Mode相关配置
*** Org本体
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
**** 绑定 prog mode

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook 'idiig/run-prog-mode-hooks)
#+end_src

**** 函数与advice
=org-insert-structure-template= 后选择 =s= (src block) 时自动提示插入代码块的语言。

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (defun idiig/org-insert-structure-template-src-advice (orig-fun type)
      "Advice for org-insert-structure-template to handle src blocks."
      (if (string= type "src")  ; 判断条件为 "src"
  	(let ((selected-type (ido-completing-read "Source code type: " idiig/language-list)))
  	  (funcall orig-fun (format "src %s" selected-type)))
        (funcall orig-fun type)))

    (advice-add 'org-insert-structure-template :around #'idiig/org-insert-structure-template-src-advice))
#+end_src

**** 代码块支持语言
***** 依赖
由于 =ob-nix= 还没有默认。我们需要添加这些依赖

#+begin_src nix :noweb-ref epkgs
  ob-nix
#+end_src

***** 配置
#+begin_src emacs-lisp
  (defun idiig/load-org-babel-languages ()
    "根据 `idiig/language-list` 启用 `org-babel` 语言。"
    (let ((languages '()))
      (dolist (lang idiig/language-list)
        (push (cons (intern lang) t) languages)) ;; 将字符串转换为符号
      (org-babel-do-load-languages 'org-babel-load-languages languages)))

  (defun idiig/set-org-babel-language-commands ()
    "根据 `idiig/language-list` 甚至语言的命令。"
    (dolist (lang idiig/language-list)
      (let ((var-name (intern (format "org-babel-%s-command" lang))))
        (when (boundp var-name)
  	(set var-name (executable-find lang))))))

  (add-hook 'org-mode-hook #'idiig/load-org-babel-languages)
  (add-hook 'org-mode-hook #'idiig/set-org-babel-language-commands)

  ;; 特殊
  (setq org-babel-shell-command (executable-find "bash"))
#+end_src

#+begin_src emacs-lisp
#+end_src
**** TODO 基础设定

- 允许shift用于选择
#+begin_src emacs-lisp 
  (with-eval-after-load 'org
    (setq org-support-shift-select 2))
#+end_src

- 远程图片文件可以通过 =C-u C-c C-x C-v= 被看到
#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (setq org-display-remote-inline-images t))
#+end_src

**** 面貌
***** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

#+begin_src nix
  org-bullets
#+end_src

***** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

- 列表的 Bullet 
#+begin_src emacs-lisp
  (use-package org-bullets
    :after org
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

  (with-eval-after-load 'org
    (setq org-ellipsis " ▾"
          org-hide-emphasis-markers t))
#+end_src

字体，缩进，换行设定

#+begin_src emacs-lisp
  (defun idiig/org-mode-face-settings ()
    "Set custom face attributes for Org mode headings in current buffer only."

    (auto-fill-mode 0)
    (require 'org-indent)
    (org-indent-mode)
    (variable-pitch-mode 1)
    (visual-line-mode 1)
    
    (let ((my-font "Sarasa Mono SC")
  	(faces '((org-level-1 . 1.2)
                   (org-level-2 . 1.1)
                   (org-level-3 . 1.05)
                   (org-level-4 . 1.0)
                   (org-level-5 . 1.1)
                   (org-level-6 . 1.1)
                   (org-level-7 . 1.1)
                   (org-level-8 . 1.1))))
      (dolist (face faces)
        (face-remap-add-relative (car face) :family my-font :weight 'regular :height (cdr face))))
    
    (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-indent nil :inherit '(org-hide fixed-pitch))
    (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)

    (with-eval-after-load 'diminish
      (diminish 'org-indent-mode)
      (diminish 'buffer-face-mode)))

  (add-hook 'org-mode-hook 'idiig/org-mode-face-settings)
#+end_src
*** Citation 工具： =citeproc-el=
**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  citeproc
#+end_src
**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (setq org-cite-export-processors
        '((latex biblatex)
          (html csl)
          (odt  csl)
          (t    biblatex))))
#+end_src
*** 幻灯片
用 =org-tree-slide= 作幻灯片发表
**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  org-tree-slide
#+end_src

** AI辅助功能

*** 文档写作

**** gptel.el

***** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

#+BEGIN_SRC nix
  gptel
#+END_SRC

***** TODO 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (add-hook 'org-mode-hook
            (lambda ()
              (when (string-match-p "\\.ai\\.org\\'" (buffer-file-name))
                (gptel-mode 1))))
#+end_src

*** Aider

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

***** TODO Aider.el
#+BEGIN_SRC nix
  # aider
#+END_SRC

***** Aider 目录路径
#+begin_src emacs-lisp  :noweb-ref ecfg
  (add-to-list 'exec-path "${pkgs.aider-chat}/bin")
#+end_src

**** TODO 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

** 模态编辑（Meow）
*** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  meow
    meow-tree-sitter
#+end_src

*** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  (use-package meow
    :init
    ;; https://github.com/meow-edit/meow/blob/master/KEYBINDING_QWERTY.org
    (require 'meow)
    (defun meow-setup ()
      (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
      (meow-motion-define-key
       '("j" . meow-next)
       '("k" . meow-prev)
       '("<escape>" . ignore))
      (meow-leader-define-key
       ;; Use SPC (0-9) for digit arguments.
       '("1" . meow-digit-argument)
       '("2" . meow-digit-argument)
       '("3" . meow-digit-argument)
       '("4" . meow-digit-argument)
       '("5" . meow-digit-argument)
       '("6" . meow-digit-argument)
       '("7" . meow-digit-argument)
       '("8" . meow-digit-argument)
       '("9" . meow-digit-argument)
       '("0" . meow-digit-argument)
       '("/" . meow-keypad-describe-key)
       '("?" . meow-cheatsheet))
      (meow-normal-define-key
       '("0" . meow-expand-0)
       '("9" . meow-expand-9)
       '("8" . meow-expand-8)
       '("7" . meow-expand-7)
       '("6" . meow-expand-6)
       '("5" . meow-expand-5)
       '("4" . meow-expand-4)
       '("3" . meow-expand-3)
       '("2" . meow-expand-2)
       '("1" . meow-expand-1)
       '("-" . negative-argument)
       '(";" . meow-reverse)
       '("," . meow-inner-of-thing)
       '("." . meow-bounds-of-thing)
       '("[" . meow-beginning-of-thing)
       '("]" . meow-end-of-thing)
       '("a" . meow-append)
       '("A" . meow-open-below)
       '("b" . meow-back-word)
       '("B" . meow-back-symbol)
       '("c" . meow-change)
       '("d" . meow-delete)
       '("D" . meow-backward-delete)
       '("e" . meow-next-word)
       '("E" . meow-next-symbol)
       '("f" . meow-find)
       '("g" . meow-cancel-selection)
       '("G" . meow-grab)
       '("h" . meow-left)
       '("H" . meow-left-expand)
       '("i" . meow-insert)
       '("I" . meow-open-above)
       '("j" . meow-next)
       '("J" . meow-next-expand)
       '("k" . meow-prev)
       '("K" . meow-prev-expand)
       '("l" . meow-right)
       '("L" . meow-right-expand)
       '("m" . meow-join)
       '("n" . meow-search)
       '("o" . meow-block)
       '("O" . meow-to-block)
       '("p" . meow-yank)
       '("q" . meow-quit)
       '("Q" . meow-goto-line)
       '("r" . meow-replace)
       '("R" . meow-swap-grab)
       '("s" . meow-kill)
       '("t" . meow-till)
       '("u" . meow-undo)
       '("U" . meow-undo-in-selection)
       '("v" . meow-visit)
       '("w" . meow-mark-word)
       '("W" . meow-mark-symbol)
       '("x" . meow-line)
       '("X" . meow-goto-line)
       '("y" . meow-save)
       '("Y" . meow-sync-grab)
       '("z" . meow-pop-selection)
       '("'" . repeat)
       '("<escape>" . ignore)))
    (meow-setup)
    :config
    (meow-global-mode 1))
#+end_src

#+RESULTS:
: meow-visit

给meow增加treesitter的功能：
#+begin_src emacs-lisp
  (require 'meow-tree-sitter)
  (meow-tree-sitter-register-defaults)  
#+end_src

在 meow-edit 退出 insert-state 时，当前输入方式自动被关闭，而再次进入
insert-state 时重新打开输入方式：
#+begin_src emacs-lisp
  (defvar-local the-late-input-method nil)
  (add-hook 'meow-insert-enter-hook
  	  (lambda ()
  	    (activate-input-method the-late-input-method)))
  (add-hook 'meow-insert-exit-hook
  	  (lambda ()
  	    (setq the-late-input-method current-input-method)
  	    (deactivate-input-method)))
#+end_src

** 扩展

扩展主要针对不存在于 =nixpkgs= 中的包，这里我基本上使用了[[https://codeberg.org/heraplem/nix-emacs-extra/src/branch/emacs-application-framework/packages/eaf][这个链接的代
码和方法]]，由于Nix水平有限，我在代码中增加了一些注释提示自己：

#+begin_src nix :tangle externals/default.nix
  { inputs, pkgs, emacsPackages }: let
    inherit (builtins) readDir;
    inherit (pkgs) runCommand;
    inherit (pkgs.lib) attrNames attrsToList filter functionArgs hasAttr mergeAttrsList pipe readFile remove;
    packagesDir = ./.;
    packageSources = inputs // {
      # nano = inputs.nano-emacs;
    };
    importFile = dir: let
      packageFunction = import "${packagesDir}/${dir}";
    in emacsPackages.callPackage packageFunction (
      pipe ({
        elispFileVersion = file: let
          output = runCommand "${baseNameOf file}-version" { } ''
            ${emacsPackages.emacs}/bin/emacs -Q --batch \
              --eval "(require 'lisp-mnt)" \
              --eval '(setq pkg-version (lm-version "${file}"))' \
              --eval '(find-file (getenv "out"))' \
              --eval '(insert pkg-version)' \
              --eval '(save-buffer)'
          '';
        in readFile output;
        pkgFileVersion = file: let
          output = runCommand "${baseNameOf file}-version" { } ''
            ${emacsPackages.emacs}/bin/emacs -Q --batch \
              --eval '(find-file "${file}")' \
              --eval '(setq pkg-version (caddr (read (current-buffer))))' \
              --eval '(find-file (getenv "out"))' \
              --eval '(insert pkg-version)' \
              --eval '(save-buffer)'
          '';
        in readFile output;
        normalizeVersion = name: version: let
          output = runCommand "${name}-normalized-version" { } ''
            ${emacsPackages.emacs}/bin/emacs -Q --batch \
              --load package \
              --eval '(setq pkg-version (package-version-join (version-to-list "${version}")))' \
              --eval '(find-file (getenv "out"))' \
              --eval '(insert pkg-version)' \
              --eval '(save-buffer)'
          '';
        in readFile output;
        genericBuild = emacsPackages.callPackage "${inputs.nixpkgs}/pkgs/applications/editors/emacs/build-support/generic.nix" { };
        elpa2nix = "${inputs.nixpkgs}/pkgs/applications/editors/emacs/build-support/elpa2nix.el";
        melpa2nix = "${inputs.nixpkgs}/pkgs/applications/editors/emacs/build-support/melpa2nix.el";
      } // (if hasAttr dir packageSources then { package_src = packageSources.${dir}; } else { })
      ) [
        attrsToList
        # => [ 
        #      { name = "elispFileVersion"; value = <function>; }
        #      { name = "pkgFileVersion"; value = <function>; }
        #      { name = "normalizeVersion"; value = <function>; }
        #      { name = "genericBuild"; value = <function>; }
        #      { name = "elpa2nix"; value = "/path/to/elpa2nix.el"; }
        #      { name = "melpa2nix"; value = "/path/to/melpa2nix.el"; }
        #    ]
        (filter ({ name, ... }: hasAttr name (functionArgs packageFunction)))
        # => 假设 packageFunction 需要 elispFileVersion 和 genericBuild
        # => [ 
        #      { name = "elispFileVersion"; value = <function>; }
        #      { name = "genericBuild"; value = <function>; }
        #    ]
        (map ({ name, value }: { ${name} = value; }))
        # => [
        #      { elispFileVersion = <function>; }
        #      { genericBuild = <function>; }
        #    ]
        mergeAttrsList
        # => { 
        #      elispFileVersion = <function>;
        #      genericBuild = <function>;
        #    }
        # 一般来讲，我们会这么写 import XXX.nix { inherit attr; };
        # 这里相当于最后得到一个传入 XXX.nix 的一个参数集
      ]
    );  # Nix 中 pipe 的写法是 pipe <初始对象> [ <函数1> <函数2> ... ]
  in pipe packagesDir [                            # => ./. (当前包目录)
    readDir                                        # => { "package1" = "directory"; "package2" = "directory"; "default.nix" = "regular"; ... }
    attrNames                                      # => [ "package1" "package2" "default.nix" ... ]
    (remove "default.nix")                         # => [ "package1" "package2" ... ]
    (map (dir: { "${dir}" = importFile dir; }))    # => [ { "package1" = <derivation>; } { "package2" = <derivation>; } ... ]
    mergeAttrsList                                 # => { "package1" = <derivation>; "package2" = <derivation>; ... }
  ]
#+end_src

*** EAF

EAF 是一个可编程扩展的框架，它自带一系列丰富的应用。

**** 外部元

eaf还没有在 =nixpkgs= 中被打包，所以需要自己打包依赖。

***** eaf本体

- 以下代码是外部元的链接
  
#+begin_src nix :noweb-ref externals
  eaf = {
    url = "github:emacs-eaf/emacs-application-framework";
    flake = false;
  };
#+end_src

- 以下代码是eaf的打包文件
  
#+begin_src nix :tangle externals/eaf/default.nix
  { package_src
  , elispFileVersion
  , lib
  , stdenv
  , writeText
  , melpaBuild
  , elpa2nix
  , melpa2nix
  , makeWrapper

  , python3
  , qt6

  , withSwayWMSupport ? stdenv.isLinux
  , jq ? null

  , withUnitySupport ? stdenv.isLinux
  , xdotool ? null

  , withX11Support ? true
  , wmctrl ? null
  }: let
    inherit (lib) readFile;
    
    python = python3.withPackages (pkgs: [
      pkgs.easyocr
      pkgs.epc
      pkgs.lxml
      pkgs.pygetwindow
      pkgs.pyqt6
      pkgs.pyqt6-sip
      pkgs.pyqt6-webengine
      pkgs.qrcode
      pkgs.requests
      pkgs.sexpdata
    ]);
  in (melpaBuild (finalAttrs: {
    pname = "eaf";
    version = elispFileVersion "${finalAttrs.src}/eaf.el";
    src = package_src;

    # 在这里添加makeWrapper作为构建依赖
    nativeBuildInputs = [ makeWrapper ];

    patchPhase = ''
      runHook prePatch

      sed -i s#'defcustom eaf-python-command .*'#'defcustom eaf-python-command "${python.interpreter}"'# eaf.el
      ${if withSwayWMSupport then "substituteInPlace eaf.el --replace jq ${jq}/bin/jq" else ""}
      ${if withUnitySupport then "substituteInPlace eaf.el --replace xdotool ${xdotool}/bin/xdotool" else ""}
      ${if withX11Support then "substituteInPlace eaf.el --replace wmctrl ${wmctrl}/bin/wmctrl" else ""}

      mv core/eaf-epc.el .
      mv extension/* .

      runHook postPatch
    '';

    elpa2nix = writeText "elpa2nix.el" ''
      ${readFile elpa2nix}
      (defun byte-recompile-directory (&rest _))
    '';
    melpa2nix = writeText "melpa2nix.el" ''
      ${readFile melpa2nix}
      (defun byte-recompile-directory (&rest _))
    '';
  })).overrideAttrs (old: {
    # 确保nativeBuildInputs被正确继承并添加makeWrapper
    nativeBuildInputs = (old.nativeBuildInputs or []) ++ [ makeWrapper ];
    
    # Override genericBuild's postInstall
    postInstall = ''
      DST=$out/share/emacs/site-lisp/elpa/$ename-$melpaVersion/

      mv eaf.py $DST
      mv applications.json $DST
      mv core $DST

      # 创建包装脚本目录
      mkdir -p $DST/bin

      # 直接创建包装脚本，使用PyQt6模块路径下的Qt库
      QT_LIB_PATH=$(${python}/bin/python -c "import os, PyQt6; print(os.path.join(os.path.dirname(PyQt6.__file__), 'Qt6/lib'))" 2>/dev/null)
      QT_PLUGIN_PATH=$(${python}/bin/python -c "import os, PyQt6; print(os.path.join(os.path.dirname(PyQt6.__file__), 'Qt6/plugins'))" 2>/dev/null)

     # 如果找不到常规路径，尝试其他可能的位置
     if [ ! -d "$QT_LIB_PATH" ] || [ ! -d "$QT_PLUGIN_PATH" ]; then
       QT_BASE_DIR=$(${python}/bin/python -c "import os, sys, PyQt6; print(os.path.normpath(os.path.join(os.path.dirname(PyQt6.__file__), '..', '..')))" 2>/dev/null)
       QT_LIB_PATH="$QT_BASE_DIR/lib"
       QT_PLUGIN_PATH="$QT_BASE_DIR/share/qt6/plugins"
     fi

     # 创建Python包装脚本
     makeWrapper ${python}/bin/python $DST/bin/eaf-python \
       --set LD_LIBRARY_PATH "$QT_LIB_PATH" \
       --set QT_PLUGIN_PATH "$QT_PLUGIN_PATH" \
       --set QT_QPA_PLATFORM_PLUGIN_PATH "$QT_PLUGIN_PATH/platforms" \
       --unset QT_XCB_GL_INTEGRATION \
       --unset XDG_DATA_DIRS

     # 修改eaf.el使用包装的Python
     sed -i s#'defcustom eaf-python-command .*'#'defcustom eaf-python-command "'$DST/bin/eaf-python'"'# $DST/eaf.el
  '';
  })
#+end_src


***** eaf浏览器

- 外部元链接
  
#+begin_src nix :noweb-ref externals
  eaf-browser = {
    url = "github:emacs-eaf/eaf-browser";
    flake = false;
  };
#+end_src

- 打包代码
  
#+begin_src nix :tangle externals/eaf-browser/default.nix
  { package_src
  , elispFileVersion
  , melpaBuild
  , buildNpmPackage
  , jq
  }: melpaBuild (finalAttrs: let
    version = elispFileVersion "${finalAttrs.src}/eaf-browser.el";
    nodeName = "browser";
    nodeModules = buildNpmPackage rec {
      pname = nodeName;
      inherit version;
      src = package_src;
      npmDepsHash = "sha256-MUf+fJdEfzU/0e4he7mVURE1osP+Jm28LduCEtcJAPg=";
      prePatch = ''
        find . -mindepth 1 -maxdepth 1 ! -name "*.json" -exec rm -rf {} ';'
        ${jq}/bin/jq 'setpath(["name"]; "${pname}") | setpath(["version"]; "${version}")' package.json > package.json.tmp
        mv package.json.tmp package.json
      '';
      dontNpmBuild = true;
    };
  in {
    pname = "eaf-browser";
    inherit version;
    src = package_src;
    postInstall = ''
      DST=$out/share/emacs/site-lisp/elpa/$ename-$melpaVersion/
      mv buffer.py $DST
      mv easylist.txt $DST
      ln -s ${nodeModules}/lib/node_modules/${nodeName}/node_modules $DST/node_modules
    '';
  })
#+end_src


***** eaf阅读器

- 外部元的链接
  
#+begin_src nix :noweb-ref externals
  eaf-pdf-viewer = {
    url = "github:emacs-eaf/eaf-pdf-viewer";
    flake = false;
  };
#+end_src

- 打包代码
  
#+begin_src nix :tangle -
#+end_src

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

#+begin_src nix
  eaf
    eaf-browser
    # (pkgs.crow-translate) ; not available for MacOS 
    # eaf-pdf-viewer
#+end_src

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  ;; (defvar idiig/eaf-path (concat user-emacs-directory "site-lisp/emacs-application-framework"))
  ;; (add-to-list 'load-path idiig/eaf-path)
  ;; (setq eaf-python-command (concat idiig/eaf-path "/eaf/bin/python"))

  (require 'eaf)
  (require 'eaf-browser)
  ;; (require 'eaf-pdf-viewer)

  (setq eaf-webengine-default-zoom 2.0
        eaf-browse-blank-page-url "https://kagi.com"
        eaf-browser-auto-import-chrome-cookies nil   ; 非自动 cookies
        eaf-browser-enable-autofill t                ; 自动填充密码
        eaf-browser-enable-tampermonkey t            ; 使用油猴
        )
#+end_src
