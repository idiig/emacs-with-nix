#+TITLE: 基于 Nix Flakes 的 Emacs 配置

* 实现方式
:PROPERTIES:
:header-args: :tangle no
:END:

下面以配置 =Magit= 为例说明这个配置的方法。这里和大多数的配置一样我们
把整体目的一致的包放在一个集群实现。每个集群主要分成两个子节点，一个用
于安装包和依赖项，一个用于配置。配置部分可以细分为键位绑定，custom，
hook，config，自定义的函数。

依赖的部分可以从 =pkgs= [fn:pkgs: =nixpkgs.legacyPackages.${system}= ]
同时安装emacs外部的依赖。然后从 =epkgs= [fn:epkgs:
=pkgs.emacs.pkgs.withPackages= ]

这里稍微多做一些解释。在配置节里面，我们利用了org-babel的一些特性。首
先我们在一个汇总代码块中使用了 =:noweb=yes= [fn:noweb: 关于文学编程中
=noweb= 的解释可以参考 [[https://www.cs.tufts.edu/~nr/noweb/][这个链接]] 。本身我们还有一个 =:session= 的方式更
适合一些数据科学的工作流。这里我们主要为了和 =:tangle= 引起使用。]，然
后在后面的代码块中我们使用 =:noweb-ref= 参照汇总代码块，最后后续的这些
代码块都会在tangle时合并到第一个代码块中。这个被tangle的代码块在后续过
程中会被nix依赖代码读入作为配置。

* 如何使用？
:PROPERTIES:
:header-args: :tangle no
:END:

用emacs打开本文档， =M-x org-babel-tangle= 或使用快捷键 =C-c C-v t= 生
成flake.nix。接下去运行可以通过如下方式：

** 调试
#+begin_src sh
  nix run <path/to/this/config>
  source ~/.bashrc
  emacs
#+end_src

** 版本回滚

- 使用git：
#+begin_src sh
  git checkout <previous-commit>
  nix run
  source ~/.bashrc
  emacs
#+end_src

- 备份lock文件：
#+begin_src sh
  # 查看以前的版本
  nix flake metadata

  # 备份版本
  cp flake.lock flake.lock.bachup
  # 使用特定锁文件版本
  nix run --recreate-lock-file --inputs-from ./flake.lock.backup
#+end_src

* 配置本体
:PROPERTIES:
:header-args: :tangle no
:END:

** Flake 入口

包的安装基于下面的 =flake.nix= 和 =init.nix= 。

#+BEGIN_SRC nix :tangle flake.nix :noweb yes
  {
    description = "idiig's Emacs Configuration with Nix Flakes";

    inputs = {
      nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
      flake-utils.url = "github:numtide/flake-utils";
      emacs-overlay.url = "github:nix-community/emacs-overlay";
      <<externals>>
    };

    outputs = inputs@{ self, nixpkgs, flake-utils, emacs-overlay, ... }:
      let
        # 用于安装非 nixpkgs 元的外部包的函数
        mkPackages = pkgs: emacsPackages: import ./externals {
          inherit inputs pkgs emacsPackages;
        };
      in
        flake-utils.lib.eachDefaultSystem (system:
  	      let
            
  		      pkgs = import nixpkgs {
  			      inherit system;
  			      overlays = [ emacs-overlay.overlay ];
  		      };

  		      # 主配置文件
  		      emacsConfig = pkgs.writeText "init.el" ''
  	    <<ecfg>>
  	    '';

  		      # early-init 配置文件
  		      emacsEarlyInitConfig = pkgs.writeText "early-init.el" ''
  	    <<emacs-early-init-config>>
  	    '';

            # 首先定义你的基础 Emacs
            emacs = pkgs.emacs30-gtk3;

            # 定义覆盖函数
            overrides = final: prev: mkPackages pkgs final;
            
            # 创建扩展的包集合并选择包
            emacsWithPackages = ((pkgs.emacsPackagesFor emacs).overrideScope overrides).withPackages (epkgs: with epkgs; [
              <<epkgs>>
            ]);
            
  	      in {
  		      packages.default = pkgs.writeShellScriptBin "script" ''
  	      #!/usr/bin/env bash
  	      set -e

  	      # 导出配置到 nix-emacs
  	      EMACS_DIR="$HOME/nix-emacs"
  	      mkdir -p "$EMACS_DIR"
  	      ${pkgs.rsync}/bin/rsync ${emacsConfig} "$EMACS_DIR/init.el"
  	      ${pkgs.rsync}/bin/rsync ${emacsEarlyInitConfig} "$EMACS_DIR/early-init.el"

  	      # 路径
  	      <<dependencies>>

  	      # 更新 Emacs 路径（兼容 macOS 和 Linux）
          if sed --version 2>/dev/null | grep "(GNU sed)"; then
  		      sed -i '/^alias ne=/d' "$HOME/.bashrc"
  	      else
  		      sed -i \"\" '/^alias ne=/d' "$HOME/.bashrc"
  	      fi

  	      echo "alias ne='${emacsWithPackages}/bin/emacs --init-dir \"$EMACS_DIR\"'" >> "$HOME/.bashrc"

  	      # 提示用户手动 source 而不是直接执行，以避免 shell 继承问题
  	      echo "请手动运行 'source ~/.bashrc' 以使 alias 生效"
  	      echo "Emacs 配置已同步到 $EMACS_DIR"
  	      '';  
  	      });
  }
#+END_SRC

** Early init
:PROPERTIES:
:header-args: :noweb-ref emacs-early-init-config
:END:

#+begin_src emacs-lisp
  ;; 增加 GC 阈值，加快启动
  (setq gc-cons-threshold 402653184 gc-cons-percentage 0.6)

  ;; 启动完成后恢复正常 GC 设定
  (add-hook 'emacs-startup-hook
	    (lambda ()
	      (setq gc-cons-threshold 10485760
		    gc-cons-percentage 0.1)))

  ;; 禁用bidi，加速大文件
  (setq-default bidi-display-reordering nil)
  (setq bidi-inhibit-bpa t
	long-line-threshold 1000
	large-hscroll-threshold 1000
	syntax-wholeline-max 1000)
#+end_src

** Emacs基建
*** Mac OS 键位设定
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  ;; 在mac中使用Command key作为meta
  (setq mac-option-key-is-meta nil
	mac-command-key-is-meta t
	mac-command-modifier 'meta
	mac-option-modifier 'none)

  ;; 便于使用mac的JIS日语键盘
  (global-set-key (kbd "C-¥") 'toggle-input-method)
#+end_src

*** 包管理和其他基础

这里我考虑了到底是否要使用 =use-package= 。因为我现在在使用 org mode
写配置文件的目的是希望可以穿插自然语言的代码描述，所以需要拆分代码。
=use-package= 这种一体成型的写法不是很适合这种风格。但考虑了实际写的过
程，我觉得大多数情况可以在配置代码前面作完整的整理，而不需要过于细粒度
的代码表述，然后在迁移的过程可能也比较简单。所以我最后还是决定改成使用
=use-package= 了。

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

- =use-package= ：用简介的宏语言描述包
- =diminish= ：用于隐藏一些 minor mode
  
#+begin_src nix
  use-package
    diminish
#+end_src

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  (require 'use-package)
  (require 'diminish)
#+end_src

*** 更好的默认设置

**** 本体的设定
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  ;; 关闭警告声
  (setq ring-bell-function 'ignore)

  ;; 确认使用y或n，而不是yes或no。
  (defalias 'yes-or-no-p 'y-or-n-p)

  ;; 不自动生成备份文件
  (setq make-backup-files nil)

  ;; 选中文字能被整体替换（与其他文本编辑器相同）
  (delete-selection-mode 1)

  ;; 文件最后添加新行
  (setq require-final-newline t)

  ;; 文件在外部更新时buffer更新
  (global-auto-revert-mode 1)
#+end_src

**** UI
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  ;; 基础设置
  (tool-bar-mode -1) ;; 关闭工具栏
  (scroll-bar-mode -1) ;; 关闭文件滑动控件
  (setq inhibit-splash-screen 1) ;; 关闭启动帮助画面
  (setq initial-frame-alist (quote ((fullscreen . maximized)))) ;; 全屏
  (setq initial-scratch-message nil) ;; 关闭scratch message
  (setq inhibit-startup-message t) ;; 关闭启动信息
  (setq frame-title-format
        ;; 窗口显示文件路径/buffer名
        '("" " idiig - "
          (:eval (if (buffer-file-name)
                     (abbreviate-file-name (buffer-file-name)) "%b"))))
  (setq ns-use-proxy-icon nil)  ;; 删除frame icon
#+end_src

- 主题

#+begin_src emacs-lisp
  (require-theme 'modus-themes)
#+end_src

**** 光标跳到新窗口
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

emacs在打开新的窗口时，默认光标维持在原来的窗口。比如当你使用
=describe-function= 时，光标不会跳到函数的简介窗口。在这类窗口我们本身
可以按 =q= 来退出和关闭窗口。所以跳转到新窗口非常便利。

- 专用buffer（display-buffer行为；主要影响 Emacs 自动创建的窗口（如
  help、compilation 等）。注意这里也会影响到 =magit= 这类 transient 窗
  口
  
#+begin_src emacs-lisp
  (setq switch-to-buffer-obey-display-actions t)
  (setq switch-to-buffer-in-dedicated-window 'pop)
  (customize-set-variable 'display-buffer-base-action
			  '((display-buffer-reuse-window display-buffer-same-window)
			    (reusable-frames . t)))
#+end_src

- split-window时转跳到新窗口
  
#+begin_src emacs-lisp
  (defadvice split-window-below (after split-window-below-and-switch activate)
    "切换到新分割的窗口"
    (when (called-interactively-p 'any)
      (other-window 1)))

  (defadvice split-window-right (after split-window-right-and-switch activate)
    "切换到新分割的窗口"
    (when (called-interactively-p 'any)
      (other-window 1)))
#+end_src

**** 窗口的放大缩小转变为持续的行为
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

而不是要一直要重复 =C-x= 按键。后续行为使用默认 =^, V, {, }= 。

这里我没用 =C-x v= 是因为这个键位目前用于 =vc= 。

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x V") 'shrink-window)

  (defun idiig/window-adjust (orig-fun &rest args)
    "使用 Emacs 风格按键 (^, V, {, }, +) 持续调整窗口大小。"
    (let* ((ev last-command-event)
  	   (echo-keystrokes nil))
      ;; 执行初始调整
      (apply orig-fun args)

      ;; 设置 transient map
      (let ((delta (car args))) 
  	(set-transient-map
  	 (let ((map (make-sparse-keymap)))
  	   ;; 垂直调整
  	   (define-key map (kbd "^")
  		       `(lambda () (interactive) (enlarge-window ,delta nil)))
  	   (define-key map (kbd "V")
  		       `(lambda () (interactive) (shrink-window ,delta nil)))

  	   ;; 水平调整
  	   (define-key map (kbd "{")
  		       `(lambda () (interactive) (shrink-window ,delta t)))
  	   (define-key map (kbd "}")
  		       `(lambda () (interactive) (enlarge-window ,delta t)))

  	   ;; 平衡窗口
  	   (define-key map (kbd "+")
  		       (lambda () (interactive) (balance-windows)))
  	   map)
  	 nil nil
  	 "Use %k for further adjustment"))))

  ;; ;; 如果需要移除 advice:
  ;; (advice-remove 'enlarge-window #'idiig/window-adjust)
  ;; (advice-remove 'shrink-window #'idiig/window-adjust)
  ;; (advice-remove 'enlarge-window-horizontally #'idiig/window-adjust)
  ;; (advice-remove 'shrink-window-horizontally #'idiig/window-adjust)

  ;; 添加 advice
  (advice-add 'enlarge-window :around #'idiig/window-adjust)
  (advice-add 'shrink-window :around #'idiig/window-adjust)
  (advice-add 'enlarge-window-horizontally :around #'idiig/window-adjust)
  (advice-add 'shrink-window-horizontally :around #'idiig/window-adjust)
#+end_src

**** 文件的保存与新建
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  ;; 不存在文档时询问是否新建
  (add-hook 'before-save-hook
            (lambda ()
              (when buffer-file-name
                (let ((dir (file-name-directory buffer-file-name)))
                  (when (and (not (file-exists-p dir))
                             (y-or-n-p (format "Directory %s does not exist. Create it?" dir)))
                    (make-directory dir t))))))

  ;; 找文件时若无母文档则新建 
  (defadvice find-file (before make-directory-maybe
                               (filename &optional wildcards) activate)
    "Create parent directory if not exists while visiting file."
    (unless (file-exists-p filename)
      (let ((dir (file-name-directory filename)))
        (when dir
          (unless (file-exists-p dir)
            (make-directory dir t))))))
#+end_src

**** 最近文件
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

打开最近文件。

#+begin_src emacs-lisp
  (use-package recentf
    :defer t
    :commands
    (consult-recent-file)
    :init
    (setq recentf-save-file (expand-file-name "recentf" user-emacs-directory)
          recentf-max-saved-items 500
          recentf-max-menu-items 10)
    (setq recentf-exclude
          '("COMMIT_MSG"
            "COMMIT_EDITMSG"
            "github.*txt$"
            "/tmp/"
            "/sudo:"
            "/TAGS$"
            "/GTAGS$"
            "/GRAGS$"
            "/GPATH$"
            "\\.mkv$"
            "\\.mp[34]$"
            "\\.avi$"
            "\\.sub$"
            "\\.srt$"
            "\\.ass$"
            ".*png$"
            "Nutstore/org-files/"
            "bookmarks"))
    (setq recentf-max-saved-items 2048)
    (recentf-mode 1))

  ;; cleanup recent files
  (defun idiig/cleanup-recentf ()
    (progn
      (and (fboundp 'recentf-cleanup)
           (recentf-cleanup))))
  (add-hook 'kill-emacs-hook #'idiig/cleanup-recentf)
#+end_src

- 自动保存文件设置
  
#+begin_src emacs-lisp
  (use-package savehist
    :init
    (setq savehist-additional-variables
          ;; search entries
          '(search-ring regexp-search-ring)
          ;; 每一分钟保存一次
          savehist-autosave-interval 60
          ;; keep the home clean
          savehist-file (expand-file-name "savehist" user-emacs-directory))
    (savehist-mode t))
#+end_src

- 书签功能，打开时自动到原先编辑的位置

#+begin_src emacs-lisp
  (use-package bookmark
    :config
    (setq bookmark-default-file (expand-file-name "bookmarks" user-emacs-directory)
          bookmark-save-flag 1))
#+end_src

- 保存文件的编辑位置

#+begin_src emacs-lisp
  (use-package saveplace
    :config
    (setq save-place-file (expand-file-name "place" user-emacs-directory))
    (save-place-mode 1))
#+end_src

**** 便利的光标移动与删除规则

***** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

#+begin_src nix
  hungry-delete
    mwim
#+end_src

***** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

- *hungry delete*: 连续删除空白

#+begin_src emacs-lisp
  (use-package hungry-delete
    :after puni
    :diminish hungry-delete-mode
    :init (setq hungry-delete-except-modes
                '(help-mode minibuffer-mode minibuffer-inactive-mode calc-mode))
    :config
    (setq-default hungry-delete-chars-to-skip " \t\f\v")  ;; 删除的空白符号 
    (global-hungry-delete-mode t))
#+end_src

- *mwim*: 跳到代码之前而非最前，或者代码后面而不是最后

#+begin_src emacs-lisp
  (use-package mwim
    :bind
    ("C-a" . mwim-beginning-of-code-or-line-or-comment)
    ("C-e" . mwim-end-of-code-or-line)
    :commands
    (mwim-beginning-of-code-or-line-or-comment
     mwim-end-of-code-or-line))
#+end_src

**** 折行与复原

***** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

#+begin_src nix
  unfill
#+end_src

***** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

- 物理折行与复原
#+begin_src emacs-lisp
  (use-package unfill
    :bind
    ("M-q" . unfill-toggle)
    :commands
    (unfill-toggle))
#+end_src

**** 更好的minibuffer
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

***** 原生设定

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (progn
      ;; 为`completing-read-multiple'添加提示，比如[CRM<separator>]
      (defun crm-indicator (args)
        (cons (format "[CRM%s] %s"
                      (replace-regexp-in-string
                       "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                       crm-separator)
                      (car args))
              (cdr args)))
      (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

      ;; 不允许鼠标出现在minibuffer的提示中
      (setq minibuffer-prompt-properties
            '(read-only t cursor-intangible t face minibuffer-prompt))
      (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

      ;; 在emacs 28以后，非当前mode的指令都会被隐藏，vertico的指令也会隐藏
      (setq read-extended-command-predicate
            #'command-completion-default-include-p)

      ;; minibuffer可循环
      (setq enable-recursive-minibuffers t)))

  ;; http://trey-jackson.blogspot.com/2010/04/emacs-tip-36-abort-minibuffer-when.html
  ;; 使用鼠标时关闭minibuffer
  (defun idiig/stop-using-minibuffer ()
    "kill the minibuffer"
    (when (and (>= (recursion-depth) 1) (active-minibuffer-window))
      (abort-recursive-edit)))
  (add-hook 'mouse-leave-buffer-hook 'idiig/stop-using-minibuffer)

#+end_src

***** 基础五件套

****** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

#+begin_src nix
  vertico
    orderless
    marginalia
    embark
    consult
    embark-consult
#+end_src

****** 配置

- *Vertico*: 提供minibuffer补全UI

#+begin_src emacs-lisp
  (use-package vertico
    :after consult
    :custom
    (vertico-count 9)
    (vertico-cycle t)
    :init
    (vertico-mode))
#+end_src

- *Orderless*: 提供补全格式选择

#+begin_src emacs-lisp
  (use-package orderless
    :after
    (consult)
    :config
    (setq search-default-mode t)
    (defvar +orderless-dispatch-alist
      '((?% . char-fold-to-regexp)
        (?! . orderless-without-literal)
        (?`. orderless-initialism)
        (?= . orderless-literal)
        (?~ . orderless-flex)))

    (defun +orderless--suffix-regexp ()
      (if (and (boundp 'consult--tofu-char) (boundp 'consult--tofu-range))
          (format "[%c-%c]*$"
                  consult--tofu-char
                  (+ consult--tofu-char consult--tofu-range -1))
        "$"))
    ;; Recognizes the following patterns:
    ;; * ~flex flex~
    ;; * =literal literal=
    ;; * %char-fold char-fold%
    ;; * `initialism initialism`
    ;; * !without-literal without-literal!
    ;; * .ext (file extension)
    ;; * regexp$ (regexp matching at end)
    (defun +orderless-dispatch (word _index _total)
      (cond
       ;; Ensure that $ works with Consult commands, which add disambiguation suffixes
       ((string-suffix-p "$" word)
        `(orderless-regexp . ,(concat (substring word 0 -1) (+orderless--suffix-regexp))))
       ;; File extensions
       ((and (or minibuffer-completing-file-name
                 (derived-mode-p 'eshell-mode))
             (string-match-p "\\`\\.." word))
        `(orderless-regexp . ,(concat "\\." (substring word 1) (+orderless--suffix-regexp))))
       ;; Ignore single !
       ((equal "!" word) `(orderless-literal . ""))
       ;; Prefix and suffix
       ((if-let (x (assq (aref word 0) +orderless-dispatch-alist))
            (cons (cdr x) (substring word 1))
          (when-let (x (assq (aref word (1- (length word))) +orderless-dispatch-alist))
            (cons (cdr x) (substring word 0 -1)))))))
    
    ;; Define orderless style with initialism by default ; add migemo feature for japanese
    (orderless-define-completion-style +orderless-with-initialism
      (orderless-matching-styles '(orderless-initialism
                                   orderless-literal
                                   orderless-regexp)))
    
    (setq completion-styles '(orderless basic)
          completion-category-defaults nil
          ;;; Enable partial-completion for files.
          ;;; Either give orderless precedence or partial-completion.
          ;;; Note that completion-category-overrides is not really an override,
          ;;; but rather prepended to the default completion-styles.
          ;; completion-category-overrides '((file (styles orderless partial-completion))) ;; orderless is tried first
          completion-category-overrides '((file (styles partial-completion)) ;; partial-completion is tried first
                                          (buffer (styles +orderless-with-initialism))
                                          (consult-location (styles +orderless-with-initialism))
                                          ;; enable initialism by default for symbols
                                          (command (styles +orderless-with-initialism))
                                          (variable (styles +orderless-with-initialism))
                                          (symbol (styles +orderless-with-initialism)))
          orderless-component-separator #'orderless-escapable-split-on-space ;; allow escaping space with backslash!
          orderless-style-dispatchers '(+orderless-dispatch)))
#+end_src

- *Maginalia*: 增强minubuffer的annotation

#+begin_src emacs-lisp
  (use-package marginalia
    :after vertico
    ;; 只在minibuffer启用快捷键
    :bind (:map minibuffer-local-map ("M-A" . marginalia-cycle))
    :init
    (setq marginalia-align-offset 5)
    :config
    (marginalia-mode))
#+end_src

- *Consult*:
  
#+begin_src emacs-lisp
  (use-package consult
    :hook (after-init . (lambda () (require 'consult)))
    :bind (([remap M-x] . execute-extended-command)
           ([remap goto-line] . consult-goto-line)
           ([remap switch-to-buffer] . consult-buffer)
           ([remap find-file] . find-file)
  	 ([remap imenu] . consult-imenu)
           ("C-x C-r" . consult-recent-file)
           ("C-c y" . consult-yasnippet)
           ("C-c f" . consult-find)
           ("C-s" . consult-line)
           ("C-c o" . consult-file-externally)
           ("C-x p f" . consult-ripgrep)
           (:map minibuffer-local-map
                 ("C-c h" . consult-history)
                 ("C-s" . #'previous-history-element)))
    :init
    (defun idiig/consult-buffer-region-or-symbol ()
      "consult-line当前字符或选中区域."
      (interactive)
      (let ((input (if (region-active-p)
                       (buffer-substring-no-properties
                        (region-beginning) (region-end))
                     (thing-at-point 'symbol t))))
        (consult-line input)))
    (defun idiig/consult-project-region-or-symbol (&optional default-inputp)
      "consult-ripgrep 当前字符或选中区域."
      (interactive)
      (let ((input (if (region-active-p)
                       (buffer-substring-no-properties
                        (region-beginning) (region-end))
                     (thing-at-point 'symbol t))))
        (consult-ripgrep default-inputp input)))
    :config
    (progn
      ;; (defvar my-consult-line-map
      ;;   (let ((map (make-sparse-keymap)))
      ;;     (define-key map "C-s" #'previous-history-element)
      ;;     map))
      ;; (consult-customize consult-line :keymap my-consult-line-map)
      ;; ;; 禁止自动显示consult文件的内容
      (setq consult-preview-key "C-v")
      ;; 应用 Orderless 的正则解析到 consult-grep/ripgrep/find
      (defun consult--orderless-regexp-compiler (input type &rest _config)
        (setq input (orderless-pattern-compiler input))
        (cons
         (mapcar (lambda (r) (consult--convert-regexp r type)) input)
         (lambda (str) (orderless--highlight input str))))
      ;; 表示的buffer种类
      (defcustom consult-buffer-sources
        '(consult--source-hidden-buffer
          consult--source-buffer
          consult--source-file
          consult--source-bookmark
          consult--source-project-buffer
          consult--source-project-file)
        "Sources used by `consult-buffer'. See `consult--multi' for a description of the source values."
        :type '(repeat symbol))
      ;; ？提示检索buffer类型；f<SPC>=file, p<SPC>=project, etc..
      (define-key consult-narrow-map
        (vconcat consult-narrow-key "?") #'consult-narrow-help)))
#+end_src

- *Embark*: minibuffer action 和自适应的context menu

#+begin_src emacs-lisp
  (use-package embark
    :after vertico
    :bind
    (("C-h B" . embark-bindings)  ;; alternative for `describe-bindings'
     (:map minibuffer-local-map
           ("C-;" . embark-act)         ;; 对函数进行设置操作 
           ("M-." . embark-dwim)        ;; 实施 
           ("C-c C-e" . embark-export)  ;; occur
           )) 
    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)
    :config
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))

  ;; embark-export弹出occur和grep mode的buffer
  (use-package embark-consult
    :ensure t
    :after (consult))
#+end_src

**** 撤销（vundo）

我原来使用 undotree ，现在使用 vundo。这些用于视觉化撤销树。这里我之绑
定了 =C-x u= ， =C-/= 我依然用的原生的 Undo，这样适合区分使用。

***** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

#+BEGIN_SRC nix 
  vundo
#+END_SRC

***** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  (use-package vundo
    :defer t
    :commands
    (vundo)
    :bind
    ("C-x u" . vundo))
#+end_src

**** 括号匹配
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (use-package emacs
    :init
    ;; 启用自动括号配对
    (electric-pair-mode t)
    
    :config
    ;; 配置 electric-pair-mode 行为
    (setq electric-pair-preserve-balance nil)
    ;; 使用保守的抑制策略
    ;; https://www.reddit.com/r/emacs/comments/4xhxfw/how_to_tune_the_behavior_of_eletricpairmode/
    (setq electric-pair-inhibit-predicate 'electric-pair-conservative-inhibit)
    
    ;; 保存默认的配对括号设置，以便创建模式特定的本地设置
    (defconst idiig/default-electric-pairs electric-pair-pairs)
    
    ;; 为特定模式添加本地电子配对
    (defun idiig/add-local-electric-pairs (pairs)
      "为当前缓冲区添加本地电子配对括号。
       
       参数:
         PAIRS: 要添加的括号对列表
       
       示例用法:
         (add-hook 'jupyter-org-interaction-mode-hook
                   (lambda () (idiig/add-local-electric-pairs '((?$ . ?$)))))"
      (setq-local electric-pair-pairs (append idiig/default-electric-pairs pairs))
      (setq-local electric-pair-text-pairs electric-pair-pairs))
    
    ;; 禁止自动配对尖括号 <>
    (add-function :before-until electric-pair-inhibit-predicate
                  (lambda (c) (eq c ?<)))
    
    ;; 增强的括号匹配高亮——即使光标在括号内也能高亮匹配的括号
    (define-advice show-paren-function (:around (fn) fix-show-paren-function)
      "即使光标不直接位于括号上，也能高亮匹配的括号。"
      (cond ((looking-at-p "\\s(") (funcall fn))
            (t (save-excursion
                 (ignore-errors (backward-up-list))
                 (funcall fn)))))
    
    ;; 启用括号匹配高亮
    (show-paren-mode t))
#+end_src

**** 语言无关的结构化编程

***** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  puni
#+end_src

***** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (use-package puni
    :defer t
    :bind
    (:map puni-mode-map
  	([remap puni-kill-line] . idiig/puni-kill-line)
  	("C-=" . puni-expand-region)
  	("C--" . puni-contract-region))
    :init
    ;; The autoloads of Puni are set up so you can enable `puni-mode` or
    ;; `puni-global-mode` before `puni` is actually loaded. Only after you press
    ;; any key that calls Puni commands, it's loaded.
    (puni-global-mode)
    (add-hook 'term-mode-hook #'puni-disable-puni-mode)
    :config
    (defun idiig/puni-kill-line ()
      "Kill a line forward while keeping expressions balanced.
  If nothing can be deleted, kill backward.  If still nothing can be
  deleted, kill the pairs around point."
      (interactive)
      (let ((bounds (puni-bounds-of-list-around-point)))
        (if (eq (car bounds) (cdr bounds))
            (when-let ((sexp-bounds (puni-bounds-of-sexp-around-point)))
              (puni-delete-region (car sexp-bounds) (cdr sexp-bounds) 'kill))
  	(if (eq (point) (cdr bounds))
              (puni-backward-kill-line)
            (puni-kill-line))))))
#+end_src

#+begin_src emacs-lisp
  ;; 添加 advice
  (with-eval-after-load 'puni
    (defun idiig/puni-expand-region-advice (orig-fun &rest args)
      "使用 Emacs 风格按键 (^, V, {, }, +) 持续调整窗口大小。"
      
      (let* ((ev last-command-event)
             (echo-keystrokes nil))
        ;; 执行初始调整
        (apply orig-fun args)

        ;; 设置 transient map
        (let ((delta (car args))) 
  	(set-transient-map
  	 (let ((map (make-sparse-keymap)))
             ;; 持续扩大
             (define-key map (kbd "=") 'puni-expand-region)
             ;; 缩小范围
             (define-key map (kbd "-") 'puni-contract-region)
  	   ;; 其他操作
  	   ;; 检索
             (define-key map (kbd "/") 'idiig/consult-project-region-or-symbol)
             (define-key map (kbd "b") 'idiig/consult-buffer-region-or-symbol)
  	   ;; 加包围
  	   (define-key map (kbd ")") 'puni-wrap-round)
             (define-key map (kbd "]") 'puni-wrap-square)
  	   (define-key map (kbd "}") 'puni-wrap-curly)
  	   (define-key map (kbd ">") 'puni-wrap-angle)
  	   map)
  	 nil nil
  	 "Use %k for further adjustment"))))
    (advice-add 'puni-expand-region :around #'idiig/puni-expand-region-advice))
#+end_src

** CJK字体

这里我统一使用的是Sarasa的等宽字体，可以避免2个问题：

- 输入latin以后输入cjk文字以后，由于字体高度不等导致行高抖动

- 方便org等表格等宽表示

*** 依赖
:PROPERTIES:
:header-args: :noweb-ref dependencies
:END:
#+begin_src sh
  if [ "$(uname)" = "Darwin" ]; then
    # macOS
    mkdir -p "$HOME/Library/Fonts/"
    ${pkgs.rsync}/bin/rsync -av ${pkgs.sarasa-gothic}/share/fonts/truetype/ "$HOME/Library/Fonts/"
  else
    # Assume Linux
    mkdir -p "$HOME/.local/share/fonts/truetype/"
    ${pkgs.rsync}/bin/rsync -av ${pkgs.sarasa-gothic}/share/fonts/truetype/ "$HOME/.local/share/fonts/sarasa-gothic/"
    fc-cache -f -v ~/.local/share/fonts/
  fi
#+end_src

*** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  (add-hook 'after-init-hook
  	    (lambda ()
  	      (let* ((screen-height (display-pixel-height))
  		     (font-height (if (and
  				       (< screen-height 1150)
  				       (> screen-height 1200)) 230 130))  ;; 根据屏幕高度调整
  		     (minibuffer-font-height (- font-height 0))
  		     (my-font "Sarasa Mono SC"))
  		(set-face-attribute 'default nil :family my-font :height font-height)
  		;; 设置 mode-line 字体
  		(set-face-attribute 'mode-line nil :family my-font :height font-height)
  		(set-face-attribute 'mode-line-inactive nil :family my-font :height font-height)
  		;; 设置 minibuffer 字体
  		(set-face-attribute 'minibuffer-prompt nil :family my-font :height minibuffer-font-height))))

  ;; 工具栏，菜单保持默认字体
  (set-face-attribute 'menu nil :inherit 'unspecified)
  (set-face-attribute 'tool-bar nil :inherit 'unspecified)
#+end_src

** 日文

*** 输入法

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

#+BEGIN_SRC nix 
  ddskk
#+END_SRC

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  (use-package ddskk
    :defer t
    :bind (("C-x j" . skk-mode))
    :config
    (setq skk-server-inhibit-startup-server nil)
    (setq skk-server-host "localhost")
    (setq skk-server-portnum 55100)
    (setq skk-share-private-jisyo t)

    ;; 候补显示设置
    (setq skk-show-inline t)
    (setq skk-show-tooltip t)
    (setq skk-show-candidates-always-pop-to-buffer t)
    (setq skk-henkan-show-candidates-rows 2)

    ;; 行为设置
    (setq skk-egg-like-newline t)
    (setq skk-delete-implies-kakutei nil)
    (setq skk-use-look t)
    (setq skk-auto-insert-paren t)
    (setq skk-henkan-strict-okuri-precedence t)

    ;; 片假名转换设置
    (setq skk-search-katakana 'jisx0201-kana)

    ;; 加载额外功能
    (require 'skk-hint)
    :hook
    (skk-load . (lambda ()
                  (require 'context-skk))))
#+end_src

*** TODO 检索（Migemo）

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

** 中文

*** 输入法

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

#+BEGIN_SRC nix 
  pyim
    pyim-basedict
#+END_SRC

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

***** 基础设定
#+begin_src emacs-lisp
  (use-package pyim
    :diminish pyim-isearch-mode
    :commands
    (toggle-input-method)
    :custom
    (default-input-method "pyim")
    (pyim-dcache-directory (concat user-emacs-directory "pyim/dcache"))
    (pyim-default-scheme 'quanpin)
    (pyim-page-tooltip 'popup)
    (pyim-page-length 4))

  ;; 加载并启用基础词库
  (use-package pyim-basedict
    :after pyim
    :config
    (pyim-basedict-enable))
#+end_src

***** TODO 正则表达交互

目前支持

- 在minibuffer中用 =C-Ret= 把单字拼音转换为该读音本身代表的中文正则表达
- =M-x idiig/toggle-pyim-region= 用于开关中文的forward-word和backward
- 激活进入pyim时，自动开启中文的forward和backward
  
#+begin_src emacs-lisp
  (with-eval-after-load 'pyim
    (require 'pyim-cstring-utils)

    ;; C-return 把当前选中的位置转换为正则表达
    (define-key minibuffer-local-map (kbd "C-<return>") 'pyim-cregexp-convert-at-point)

    (defvar idiig/pyim-region-enabled nil
      "记录pyim区域功能是否启用的状态变量。")

    (defun idiig/toggle-pyim-region ()
      "切换pyim的单词移动功能。
  当启用时，会将forward-word和backward-word重映射为pyim的相应函数；
  当禁用时，会恢复原来的映射。"
      (interactive)
      (call-interactively #'pyim-activate)
      (call-interactively #'pyim-deactivate)
      (if idiig/pyim-region-enabled
	  (progn
	    (idiig/disable-pyim-region)
	    (setq idiig/pyim-region-enabled nil)
	    (message "已禁用pyim区域功能"))
	(progn
	  (idiig/enable-pyim-region)
	  (setq idiig/pyim-region-enabled t)
	  (message "已启用pyim区域功能"))))

    (defun idiig/enable-pyim-region (&rest _)
      "启用pyim的单词移动建议。"
      (global-set-key [remap forward-word] 'pyim-forward-word)
      (global-set-key [remap backward-word] 'pyim-backward-word))

    (defun idiig/disable-pyim-region (&rest _)
      "禁用pyim的单词移动建议。"
      (global-unset-key [remap forward-word])
      (global-unset-key [remap backward-word]))

    ;; ;; 挂钩到 pyim 的启用/禁用钩子上
    ;; (advice-remove 'pyim-deactivate #'idiig/disable-pyim-region)
    ;; (advice-remove 'pyim-activate #'idiig/enable-pyim-region)
    ;; (advice-add 'pyim-deactivate :after #'idiig/disable-pyim-region)
    (advice-add 'pyim-activate :after #'idiig/enable-pyim-region))
#+end_src

***** Orderless交互

#+begin_src emacs-lisp
  ;; 确保在 orderless 加载后再加载这些配置
  (with-eval-after-load 'orderless
    ;; 拼音检索字符串功能
    (defun zh-orderless-regexp (orig_func component)
      (call-interactively #'pyim-activate)
      (call-interactively #'pyim-deactivate)
      (let ((result (funcall orig_func component)))
  	(pyim-cregexp-build result)))
    (advice-add 'orderless-regexp :around #'zh-orderless-regexp))
#+end_src

** Git（Magit）

用 Magit 进行项目与版本的管理

*** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

#+BEGIN_SRC nix
  magit
#+END_SRC

*** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

**** Magit

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind ("C-x g" . magit-status)
    :commands magit-status
    :init
    ;; 使用nix路径中的git
    (add-to-list 'exec-path "${pkgs.git}/bin"))
#+END_SRC

** 文档写作
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

*** 文档后缀
  
#+begin_src emacs-lisp
  (defvar idiig/writing-environment-list '("\\.org\\'"
                                          "\\.md\\'"
                                          "\\.qmd\\'"
                                          "\\.rmd\\'"
                                          "\\.typ\\'"
                                          "\\.tex\\'"
                                          "\\.bib\\'"
                                          "\\.txt\\'"))
#+end_src

*** 文档状态折行
  
#+begin_src emacs-lisp
  (defun idiig/in-writing-environment-p ()
    "Check if current buffer file matches any pattern in idiig/writing-environment-list."
    (when (buffer-file-name)
      (cl-some (lambda (pattern)
                 (string-match-p pattern (buffer-file-name)))
               idiig/writing-environment-list)))

  (add-hook 'find-file-hook
            (lambda ()
              (when (idiig/in-writing-environment-p)
                (visual-line-mode 1))))

  (with-eval-after-load 'diminish
    (diminish 'visual-line-mode))
#+end_src

*** 在选中区域的状态下 =C-w= 删除选中的区域

在没选中的状态下删除上一个单词。

#+begin_src emacs-lisp
  (defun idiig/backward-kill-word-or-region (&optional arg)
    (interactive "p")
    (if (region-active-p)
  	(call-interactively #'kill-region)
      (backward-kill-word arg)))

  (global-set-key (kbd "C-w") 'idiig/backward-kill-word-or-region) 
#+end_src

*** =C-M-\= 全局缩进

全局缩进

#+begin_src emacs-lisp
  (defun idiig/indent-buffer()
    (interactive)
    (indent-region (point-min) (point-max)))

  (defun idiig/indent-region-or-buffer()
    (interactive)
    (save-excursion
      (if (region-active-p)
          (progn
            (indent-region (region-beginning) (region-end)))
        (progn
          (idiig/indent-buffer)))))

  (global-set-key (kbd "C-M-\\") 'idiig/indent-region-or-buffer)
  (global-set-key (kbd "C-M-¥") 'idiig/indent-region-or-buffer)  ;; JIS keyboard
#+end_src

*** =Shift-Ret= 下方插入空白行

#+begin_src emacs-lisp
  (global-set-key [(shift return)] 'idiig/smart-open-line)
#+end_src

*** =M--= 匹配到括号 

TODO: 把 evil-jump-item 换成别的函数。

#+begin_src emacs-lisp
  (defun idiig/goto-match-paren (arg)
    "Go to the matching if on (){}[], similar to vi style of % "
    (interactive "p")
    ;; first, check for "outside of bracket" positions expected by forward-sexp, etc
    (cond ((looking-at "[\[\(\{]") (evil-jump-item))
          ((looking-back "[\]\)\}]" 1) (evil-jump-item))
          ;; now, try to succeed from inside of a bracket
          ((looking-at "[\]\)\}]") (forward-char) (evil-jump-item))
          ((looking-back "[\[\(\{]" 1) (backward-char) (evil-jump-item))
          (t nil)))

  (bind-key* "M--" 'idiig/goto-match-paren)
#+end_src

*** 点后插入空白

#+begin_src emacs-lisp
  (defun idiig/insert-space-after-point ()
    (interactive)
    (save-excursion (insert " ")))

  (bind-key* "C-." 'idiig/insert-space-after-point)
#+end_src

** 编程工具

*** 我有可能使用的语言
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  ;; TODO: 这里未来需要改成在每个语言的设定的节点push进来
  (defvar idiig/language-list
    '("emacs-lisp" "python" "C" "shell" "js" "clojure" "css" "nix"
      "dot" "gnuplot" "R" "sql" "awk" "haskell" "latex" "lisp"
      "org" "julia" "scheme" "sqlite")
    "支持的编程语言列表。")

  (defun idiig/run-prog-mode-hooks ()
    "Runs `prog-mode-hook'. 针对一些本该为编程语言又没自动加载prog mode的语言hook.
  如：(add-hook 'python-hook 'idiig/run-prog-mode-hooks)
  "
    (run-hooks 'prog-mode-hook))
#+end_src

*** 语言服务器（LSP-Bridge)
:PROPERTIES:
:CUSTOM_ID: lsp-bridge
:END:

语言服务器用于补全代码，提示文档，参照转跳等。这里我使用了 LSP-Bridge，
其主要优势是通过 python 后端调用语言服务器，不卡 emacs 进程达到高速的
补全。其他倾向的代替选项有 emacs 捆绑 =eglot= 。

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

#+begin_src nix
  (lsp-bridge.override {
    # 指定使用 Python 3.11 而不是 3.12
    python3 = pkgs.python311;
  })
    markdown-mode
    yasnippet
#+end_src

这里由于默认的 python (3.12.9) 版本问题导致了下面的报错：

- 首先尝试导入 =SimpleXMLRPCServer= 模块失败，这是因为在 Python 3 中，
  该模块已被移至 =xmlrpc.server=
- 随后在导入 =xmlrpc.client= 时出现了一个奇怪的错误:
  ~'datetime.datetime' object has no attribute 'task'~

这可能是 Python 3.12.9 中的一个 bug，或者是 epc 包与 Python 3.12.9 不
兼容的结果。因此我们在 =lsp-bridge= 的环境中使用了 311 的版本。

#+begin_example
  Traceback (most recent call last):
    File "/nix/store/1bn994va1akp3m0jvg4fj9wzlqmn1kkq-python3-3.12.9-env/lib/python3.12/site-packages/epc/py3compat.py", line 26, in <module>
      import SimpleXMLRPCServer
  ModuleNotFoundError: No module named 'SimpleXMLRPCServer'

  During handling of the above exception, another exception occurred:

  Traceback (most recent call last):
    File "/nix/store/4mx09lzrlahhkgv7qb2q57xmnsfwcmlx-emacs-packages-deps/share/emacs/site-lisp/elpa/lsp-bridge-20250210.0/lsp_bridge.py", line 46, in <module>
      from epc.server import ThreadingEPCServer
    File "/nix/store/1bn994va1akp3m0jvg4fj9wzlqmn1kkq-python3-3.12.9-env/lib/python3.12/site-packages/epc/server.py", line 20, in <module>
      from .py3compat import SocketServer
    File "/nix/store/1bn994va1akp3m0jvg4fj9wzlqmn1kkq-python3-3.12.9-env/lib/python3.12/site-packages/epc/py3compat.py", line 28, in <module>
      import xmlrpc.server as SimpleXMLRPCServer
    File "/nix/store/26yi95240650jxp5dj78xzch70i1kzlz-python3-3.12.9/lib/python3.12/xmlrpc/server.py", line 107, in <module>
      from xmlrpc.client import Fault, dumps, loads, gzip_encode, gzip_decode
    File "/nix/store/26yi95240650jxp5dj78xzch70i1kzlz-python3-3.12.9/lib/python3.12/xmlrpc/client.py", line 272, in <module>
      if _try('%Y'):      # Mac OS X
         ^^^^^^^^^^
    File "/nix/store/26yi95240650jxp5dj78xzch70i1kzlz-python3-3.12.9/lib/python3.12/xmlrpc/client.py", line 269, in _try
      return _day0.strftime(fmt) == '0001'
             ^^^^^^^^^^^^^^^^^^^
  AttributeError: 'datetime.datetime' object has no attribute 'task'
#+end_example

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  (defmacro idiig//setup-nix-lsp-bridge-server (language server-name executable-path &optional lib-path)
    "配置 Nix 环境下的 LSP 服务器。
  LANGUAGE 是语言名称，如 'python'。
  SERVER-NAME 是服务器名称，如 'basedpyright'。
  EXECUTABLE-PATH 是服务器可执行文件的路径。
  LIB-PATH 是可选的库路径，添加到 LD_LIBRARY_PATH。"
    `(with-eval-after-load 'lsp-bridge
       ;; 设置 LSP 服务器
       (setq ,(intern (format "lsp-bridge-%s-lsp-server" language)) ,server-name)
       
       ;; 添加可执行文件路径到 exec-path
       ,(when executable-path
          `(add-to-list 'exec-path ,executable-path))
       
       ;; 添加库路径到 LD_LIBRARY_PATH
       ,(when lib-path
          `(setenv "LD_LIBRARY_PATH" 
                  (concat ,lib-path ":" 
                          (or (getenv "LD_LIBRARY_PATH") ""))))))
#+end_src

上面这个宏用于生成 LSP-Bridge 的设定，因为语言服务器本身需要用户自己安
装，而本配置又需要 Nix 保证复现，所以我们需要把 nix 路径的语言服务器传
递给 emacs ，而且语言服务器往往需要匹配的 C++ 的库。因此我希望通过上面
的代码生成系列配置，同时设定语言，语言服务器，语言服务器的可执行文件路
径，依赖的 C 库。宏使用如下：

#+begin_src emacs-lisp :noweb-ref -
  (idiig/setup-nix-lsp-bridge-server 
   "python" 
   "basedpyright" 
   "${pkgs.basedpyright}/bin" 
   "${pkgs.stdenv.cc.cc.lib}/lib")
#+end_src

宏展开后如下：

#+begin_src emacs-lisp :noweb-ref -
  (with-eval-after-load 'lsp-bridge
    (setq lsp-bridge-python-lsp-bridge-server "basedpyright")
    (add-to-list 'exec-path "${pkgs.basedpyright}/bin")
    (setenv "LD_LIBRARY_PATH" 
            (concat "${pkgs.stdenv.cc.cc.lib}/lib:" 
                    (or (getenv "LD_LIBRARY_PATH") ""))))
#+end_src

后面是 LSP-Bridge 本体的配置：

#+begin_src emacs-lisp
  (use-package lsp-bridge
    :defer t
    :diminish lsp-bridge-mode
    :bind
    (:map acm-mode-map
          ("C-j" . acm-select-next)
          ("C-k" . acm-select-prev))
    :custom
    (acm-enable-yas nil)   ; 补全不包括 Yasnippet
    (acm-enable-doc nil)   ; 不自动显示函数等文档
    (lsp-bridge-org-babel-lang-list idiig/language-list)  ; org支持的代码也使用桥
    (acm-enable-icon nil)  ; 不显示图标
    :hook 
    (prog-mode . (lambda ()
  		 (lsp-bridge-mode)))
    :init
    ;; 这里是为了让语言服务器找到正确的版本的 libstdc++.so.6 库
    (setenv "LD_LIBRARY_PATH" 
              (concat "${pkgs.stdenv.cc.cc.lib}/lib:" 
                      (or (getenv "LD_LIBRARY_PATH") ""))))
#+end_src

*注意* ：语言服务器不会自动安装，如果在新电脑中出现缺少个别语言服务器
的情况，我们可以手动安装。

*** TODO Treesitter

用于解析语法和语法高亮

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  # treesit  # 目前 treesit 已经内置
  treesit-auto
#+end_src

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  (use-package treesit-auto
    :custom
    (treesit-auto-install 'prompt)   ; 设置安装 tree-sitter 语法时提示用户确认
    :hook
    (prog-mode . treesit-auto-mode)    ; 在所有编程模式下自动启用 treesit-auto-mode
    :config
    (treesit-auto-add-to-auto-mode-alist 'all))  ; 将所有已知的 tree-sitter 模式添加到自动模式列表中
#+end_src

这个配置设置了 =treesit-auto= 包，这是一个帮助管理和自动启用 Emacs 内
置 =tree-sitter= 模式的工具。会在启动 major mode 的时候自动替换为
=<major>-ts-mode= 。比如 python-mode 会变成 python-ts-mode。

*注意* ：treesit 不会自动安装，如果在新电脑中出现缺少 treesit 的情况，
我们可以手动 =treesit-auto-install-all= 。下载目前所有可能的语言的
treesit。

*** Snippet（Yasnippet）

Snippet 用于快速插入模板

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

这里 =yasnippet= 本体已经作为 =lsp-bridge= 的依赖被加入，我们这里只加
入一个 snippet 的合集 =yasnippert-snippets= 。

#+begin_src nix
  # yasnippet
  yasnippet-snippets
    consult-yasnippet
#+end_src

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  ;; (defvar idiig/snippet-dir (concat user-emacs-directory "snippets"))
  (use-package yasnippet
    :defer t
    :diminish yas-minor-mode
    :hook
    (prog-mode . yas-minor-mode)
    :init
    ;; (setq yas-snippet-dirs <path/to/snippets>)
    ;; (push idiig/snippet-dir yas-snippet-dirs)
    :config
    (yas-reload-all))
#+end_src

加载用于yasnippet的的合集

#+begin_src emacs-lisp
  (use-package consult
    :after
    (consult
     yas-minor-mode))
#+end_src

*** 基于 tresitter 的结构化编程

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
#+end_src

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
#+end_src

** 编程与文档语言

*** Nix

**** 依赖
#+begin_src nix :noweb-ref epkgs
  nix-mode
#+end_src

加入 nix 的 major mode。

#+begin_src emacs-lisp :noweb-ref ecfg
  (idiig//setup-nix-lsp-bridge-server 
   "nix" 
   "nixd" 
   "${pkgs.nixd}/bin" 
   nil)
#+end_src

设置 nix 的语言服务器。注意这里使用的是在 LSP-Bridge 节中写的宏（参看
[[#lsp-bridge]]）。

**** 配置

*** Python

**** 依赖

#+begin_src emacs-lisp :noweb-ref ecfg
  (idiig//setup-nix-lsp-bridge-server 
   "python" 
   "basedpyright" 
   "${pkgs.basedpyright}/bin" 
   "${pkgs.stdenv.cc.cc.lib}/lib")
#+end_src

**** 配置

*** R

*** Elisp

- =M-:= 时的 eval expression minibuffer 的时候加入 prog mode。
#+begin_src emacs-lisp
  (add-hook 'eval-expression-minibuffer-setup 'idiig/run-prog-mode-hooks)
#+end_src

*** Shell

*** Make

*** TeX

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src nix :noweb-ref epkgs
  auctex
    auctex-latexmk
#+end_src

#+begin_src emacs-lisp
  (idiig//setup-nix-lsp-bridge-server 
   "tex" 
   "texlab" 
   "${pkgs.texlab}/bin" 
   nil)

  (add-to-list 'exec-path "${pkgs.texliveFull}/bin")
#+end_src

**** 配置

#+begin_src emacs-lisp
  (add-hook 'TeX-mode-hook 'idiig/run-prog-mode-hooks)
#+end_src

#+begin_src emacs-lisp
  (use-package auctex
    :defer t)
#+end_src

*** Typst

*** Markdown

*** Quarto

*** XML

*** Web

** Org Mode相关配置
*** Org本体
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

**** 绑定 prog mode

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook 'idiig/run-prog-mode-hooks)
#+end_src

**** 函数与advice
=org-insert-structure-template= 后选择 =s= (src block) 时自动提示插入代码块的语言。

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (defun idiig/org-insert-structure-template-src-advice (orig-fun type)
      "Advice for org-insert-structure-template to handle src blocks."
      (if (string= type "src")  ; 判断条件为 "src"
	  (let ((selected-type (ido-completing-read "Source code type: " idiig/language-list)))
	    (funcall orig-fun (format "src %s" selected-type)))
	(funcall orig-fun type)))

    (advice-add 'org-insert-structure-template :around #'idiig/org-insert-structure-template-src-advice))
#+end_src

**** 代码块支持语言
***** 依赖
由于 =ob-nix= 还没有默认。我们需要添加这些依赖

#+begin_src nix :noweb-ref epkgs
  ob-nix
#+end_src

***** 配置
#+begin_src emacs-lisp
  (defun idiig/load-org-babel-languages ()
    "根据 `idiig/language-list` 启用 `org-babel` 语言。"
    (let ((languages '()))
      (dolist (lang idiig/language-list)
	(push (cons (intern lang) t) languages)) ;; 将字符串转换为符号
      (org-babel-do-load-languages 'org-babel-load-languages languages)))

  (add-hook 'org-mode-hook #'idiig/load-org-babel-languages)
#+end_src

**** TODO 基础设定

- 允许shift用于选择
#+begin_src emacs-lisp 
  (with-eval-after-load 'org
    (setq org-support-shift-select 2))
#+end_src

- 远程图片文件可以通过 =C-u C-c C-x C-v= 被看到
#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (setq org-display-remote-inline-images t))
#+end_src

** AI辅助功能

*** 文档写作

**** gptel.el

***** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

#+BEGIN_SRC nix
  gptel
#+END_SRC

***** TODO 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:
#+begin_src emacs-lisp
  (add-hook 'org-mode-hook
            (lambda ()
              (when (string-match-p "\\.ai\\.org\\'" (buffer-file-name))
                (gptel-mode 1))))
#+end_src

*** Aider

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

***** TODO Aider.el
#+BEGIN_SRC nix
  # aider
#+END_SRC

***** Aider 目录路径
#+begin_src emacs-lisp  :noweb-ref ecfg
  (add-to-list 'exec-path "${pkgs.aider-chat}/bin")
#+end_src

**** TODO 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

** 模态编辑（Meow）
*** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:
#+begin_src nix
  meow
  meow-tree-sitter
#+end_src

*** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  ;; (defalias 'meow-visit #'ctrlf-forward-default) ; 需要ctrlf

  ;; https://github.com/meow-edit/meow/blob/master/KEYBINDING_QWERTY.org
  (defun meow-setup ()
    (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
    (meow-motion-define-key
     '("j" . meow-next)
     '("k" . meow-prev)
     '("<escape>" . ignore))
    (meow-leader-define-key
     ;; Use SPC (0-9) for digit arguments.
     '("1" . meow-digit-argument)
     '("2" . meow-digit-argument)
     '("3" . meow-digit-argument)
     '("4" . meow-digit-argument)
     '("5" . meow-digit-argument)
     '("6" . meow-digit-argument)
     '("7" . meow-digit-argument)
     '("8" . meow-digit-argument)
     '("9" . meow-digit-argument)
     '("0" . meow-digit-argument)
     '("/" . meow-keypad-describe-key)
     '("?" . meow-cheatsheet))
    (meow-normal-define-key
     '("0" . meow-expand-0)
     '("9" . meow-expand-9)
     '("8" . meow-expand-8)
     '("7" . meow-expand-7)
     '("6" . meow-expand-6)
     '("5" . meow-expand-5)
     '("4" . meow-expand-4)
     '("3" . meow-expand-3)
     '("2" . meow-expand-2)
     '("1" . meow-expand-1)
     '("-" . negative-argument)
     '(";" . meow-reverse)
     '("," . meow-inner-of-thing)
     '("." . meow-bounds-of-thing)
     '("[" . meow-beginning-of-thing)
     '("]" . meow-end-of-thing)
     '("a" . meow-append)
     '("A" . meow-open-below)
     '("b" . meow-back-word)
     '("B" . meow-back-symbol)
     '("c" . meow-change)
     '("d" . meow-delete)
     '("D" . meow-backward-delete)
     '("e" . meow-next-word)
     '("E" . meow-next-symbol)
     '("f" . meow-find)
     '("g" . meow-cancel-selection)
     '("G" . meow-grab)
     '("h" . meow-left)
     '("H" . meow-left-expand)
     '("i" . meow-insert)
     '("I" . meow-open-above)
     '("j" . meow-next)
     '("J" . meow-next-expand)
     '("k" . meow-prev)
     '("K" . meow-prev-expand)
     '("l" . meow-right)
     '("L" . meow-right-expand)
     '("m" . meow-join)
     '("n" . meow-search)
     '("o" . meow-block)
     '("O" . meow-to-block)
     '("p" . meow-yank)
     '("q" . meow-quit)
     '("Q" . meow-goto-line)
     '("r" . meow-replace)
     '("R" . meow-swap-grab)
     '("s" . meow-kill)
     '("t" . meow-till)
     '("u" . meow-undo)
     '("U" . meow-undo-in-selection)
     '("v" . meow-visit)
     '("w" . meow-mark-word)
     '("W" . meow-mark-symbol)
     '("x" . meow-line)
     '("X" . meow-goto-line)
     '("y" . meow-save)
     '("Y" . meow-sync-grab)
     '("z" . meow-pop-selection)
     '("'" . repeat)
     '("<escape>" . ignore)))

  (require 'meow)
  (meow-setup)
  (meow-global-mode 1)
#+end_src

给meow增加treesitter的功能：
#+begin_src emacs-lisp
  (require 'meow-tree-sitter)
  (meow-tree-sitter-register-defaults)  
#+end_src

在 meow-edit 退出 insert-state 时，当前输入方式自动被关闭，而再次进入
insert-state 时重新打开输入方式：
#+begin_src emacs-lisp
  (defvar-local the-late-input-method nil)
  (add-hook 'meow-insert-enter-hook
	    (lambda ()
	      (activate-input-method the-late-input-method)))
  (add-hook 'meow-insert-exit-hook
	    (lambda ()
	      (setq the-late-input-method current-input-method)
	      (deactivate-input-method)))
#+end_src

** 扩展

扩展主要针对不存在于 =nixpkgs= 中的包，这里我基本上使用了[[https://codeberg.org/heraplem/nix-emacs-extra/src/branch/emacs-application-framework/packages/eaf][这个链接的代
码和方法]]，由于Nix水平有限，我在代码中增加了一些注释提示自己：

#+begin_src nix :tangle externals/default.nix
  { inputs, pkgs, emacsPackages }: let
    inherit (builtins) readDir;
    inherit (pkgs) runCommand;
    inherit (pkgs.lib) attrNames attrsToList filter functionArgs hasAttr mergeAttrsList pipe readFile remove;
    packagesDir = ./.;
    packageSources = inputs // {
      # nano = inputs.nano-emacs;
    };
    importFile = dir: let
      packageFunction = import "${packagesDir}/${dir}";
    in emacsPackages.callPackage packageFunction (
      pipe ({
        elispFileVersion = file: let
          output = runCommand "${baseNameOf file}-version" { } ''
            ${emacsPackages.emacs}/bin/emacs -Q --batch \
              --eval "(require 'lisp-mnt)" \
              --eval '(setq pkg-version (lm-version "${file}"))' \
              --eval '(find-file (getenv "out"))' \
              --eval '(insert pkg-version)' \
              --eval '(save-buffer)'
          '';
        in readFile output;
        pkgFileVersion = file: let
          output = runCommand "${baseNameOf file}-version" { } ''
            ${emacsPackages.emacs}/bin/emacs -Q --batch \
              --eval '(find-file "${file}")' \
              --eval '(setq pkg-version (caddr (read (current-buffer))))' \
              --eval '(find-file (getenv "out"))' \
              --eval '(insert pkg-version)' \
              --eval '(save-buffer)'
          '';
        in readFile output;
        normalizeVersion = name: version: let
          output = runCommand "${name}-normalized-version" { } ''
            ${emacsPackages.emacs}/bin/emacs -Q --batch \
              --load package \
              --eval '(setq pkg-version (package-version-join (version-to-list "${version}")))' \
              --eval '(find-file (getenv "out"))' \
              --eval '(insert pkg-version)' \
              --eval '(save-buffer)'
          '';
        in readFile output;
        genericBuild = emacsPackages.callPackage "${inputs.nixpkgs}/pkgs/applications/editors/emacs/build-support/generic.nix" { };
        elpa2nix = "${inputs.nixpkgs}/pkgs/applications/editors/emacs/build-support/elpa2nix.el";
        melpa2nix = "${inputs.nixpkgs}/pkgs/applications/editors/emacs/build-support/melpa2nix.el";
      } // (if hasAttr dir packageSources then { package_src = packageSources.${dir}; } else { })
      ) [
        attrsToList
        # => [ 
        #      { name = "elispFileVersion"; value = <function>; }
        #      { name = "pkgFileVersion"; value = <function>; }
        #      { name = "normalizeVersion"; value = <function>; }
        #      { name = "genericBuild"; value = <function>; }
        #      { name = "elpa2nix"; value = "/path/to/elpa2nix.el"; }
        #      { name = "melpa2nix"; value = "/path/to/melpa2nix.el"; }
        #    ]
        (filter ({ name, ... }: hasAttr name (functionArgs packageFunction)))
        # => 假设 packageFunction 需要 elispFileVersion 和 genericBuild
        # => [ 
        #      { name = "elispFileVersion"; value = <function>; }
        #      { name = "genericBuild"; value = <function>; }
        #    ]
        (map ({ name, value }: { ${name} = value; }))
        # => [
        #      { elispFileVersion = <function>; }
        #      { genericBuild = <function>; }
        #    ]
        mergeAttrsList
        # => { 
        #      elispFileVersion = <function>;
        #      genericBuild = <function>;
        #    }
        # 一般来讲，我们会这么写 import XXX.nix { inherit attr; };
        # 这里相当于最后得到一个传入 XXX.nix 的一个参数集
      ]
    );  # Nix 中 pipe 的写法是 pipe <初始对象> [ <函数1> <函数2> ... ]
  in pipe packagesDir [                            # => ./. (当前包目录)
    readDir                                        # => { "package1" = "directory"; "package2" = "directory"; "default.nix" = "regular"; ... }
    attrNames                                      # => [ "package1" "package2" "default.nix" ... ]
    (remove "default.nix")                         # => [ "package1" "package2" ... ]
    (map (dir: { "${dir}" = importFile dir; }))    # => [ { "package1" = <derivation>; } { "package2" = <derivation>; } ... ]
    mergeAttrsList                                 # => { "package1" = <derivation>; "package2" = <derivation>; ... }
  ]
#+end_src

*** EAF

EAF 是一个可编程扩展的框架，它自带一系列丰富的应用。

**** 外部元

eaf还没有在 =nixpkgs= 中被打包，所以需要自己打包依赖。

***** eaf本体

- 以下代码是外部元的链接
  
#+begin_src nix :noweb-ref externals
  eaf = {
    url = "github:emacs-eaf/emacs-application-framework";
    flake = false;
  };
#+end_src

- 以下代码是eaf的打包文件
  
#+begin_src nix :tangle externals/eaf/default.nix
  { package_src
  , elispFileVersion
  , lib
  , stdenv
  , writeText
  , melpaBuild
  , elpa2nix
  , melpa2nix
  , makeWrapper

  , python3
  , qt6

  , withSwayWMSupport ? stdenv.isLinux
  , jq ? null

  , withUnitySupport ? stdenv.isLinux
  , xdotool ? null

  , withX11Support ? true
  , wmctrl ? null
  }: let
    inherit (lib) readFile;
    
    python = python3.withPackages (pkgs: [
      pkgs.easyocr
      pkgs.epc
      pkgs.lxml
      pkgs.pygetwindow
      pkgs.pyqt6
      pkgs.pyqt6-sip
      pkgs.pyqt6-webengine
      pkgs.qrcode
      pkgs.requests
      pkgs.sexpdata
    ]);
  in (melpaBuild (finalAttrs: {
    pname = "eaf";
    version = elispFileVersion "${finalAttrs.src}/eaf.el";
    src = package_src;

    # 在这里添加makeWrapper作为构建依赖
    nativeBuildInputs = [ makeWrapper ];

    patchPhase = ''
      runHook prePatch

      sed -i s#'defcustom eaf-python-command .*'#'defcustom eaf-python-command "${python.interpreter}"'# eaf.el
      ${if withSwayWMSupport then "substituteInPlace eaf.el --replace jq ${jq}/bin/jq" else ""}
      ${if withUnitySupport then "substituteInPlace eaf.el --replace xdotool ${xdotool}/bin/xdotool" else ""}
      ${if withX11Support then "substituteInPlace eaf.el --replace wmctrl ${wmctrl}/bin/wmctrl" else ""}

      mv core/eaf-epc.el .
      mv extension/* .

      runHook postPatch
    '';

    elpa2nix = writeText "elpa2nix.el" ''
      ${readFile elpa2nix}
      (defun byte-recompile-directory (&rest _))
    '';
    melpa2nix = writeText "melpa2nix.el" ''
      ${readFile melpa2nix}
      (defun byte-recompile-directory (&rest _))
    '';
  })).overrideAttrs (old: {
    # 确保nativeBuildInputs被正确继承并添加makeWrapper
    nativeBuildInputs = (old.nativeBuildInputs or []) ++ [ makeWrapper ];
    
    # Override genericBuild's postInstall
    postInstall = ''
      DST=$out/share/emacs/site-lisp/elpa/$ename-$melpaVersion/

      mv eaf.py $DST
      mv applications.json $DST
      mv core $DST

      # 创建包装脚本目录
      mkdir -p $DST/bin

      # 直接创建包装脚本，使用PyQt6模块路径下的Qt库
      QT_LIB_PATH=$(${python}/bin/python -c "import os, PyQt6; print(os.path.join(os.path.dirname(PyQt6.__file__), 'Qt6/lib'))" 2>/dev/null)
      QT_PLUGIN_PATH=$(${python}/bin/python -c "import os, PyQt6; print(os.path.join(os.path.dirname(PyQt6.__file__), 'Qt6/plugins'))" 2>/dev/null)

     # 如果找不到常规路径，尝试其他可能的位置
     if [ ! -d "$QT_LIB_PATH" ] || [ ! -d "$QT_PLUGIN_PATH" ]; then
       QT_BASE_DIR=$(${python}/bin/python -c "import os, sys, PyQt6; print(os.path.normpath(os.path.join(os.path.dirname(PyQt6.__file__), '..', '..')))" 2>/dev/null)
       QT_LIB_PATH="$QT_BASE_DIR/lib"
       QT_PLUGIN_PATH="$QT_BASE_DIR/share/qt6/plugins"
     fi

     # 创建Python包装脚本
     makeWrapper ${python}/bin/python $DST/bin/eaf-python \
       --set LD_LIBRARY_PATH "$QT_LIB_PATH" \
       --set QT_PLUGIN_PATH "$QT_PLUGIN_PATH" \
       --set QT_QPA_PLATFORM_PLUGIN_PATH "$QT_PLUGIN_PATH/platforms" \
       --unset QT_XCB_GL_INTEGRATION \
       --unset XDG_DATA_DIRS

     # 修改eaf.el使用包装的Python
     sed -i s#'defcustom eaf-python-command .*'#'defcustom eaf-python-command "'$DST/bin/eaf-python'"'# $DST/eaf.el
  '';
  })
#+end_src


***** eaf浏览器

- 外部元链接
  
#+begin_src nix :noweb-ref externals
  eaf-browser = {
    url = "github:emacs-eaf/eaf-browser";
    flake = false;
  };
#+end_src

- 打包代码
  
#+begin_src nix :tangle externals/eaf-browser/default.nix
  { package_src
  , elispFileVersion
  , melpaBuild
  , buildNpmPackage
  , jq
  }: melpaBuild (finalAttrs: let
    version = elispFileVersion "${finalAttrs.src}/eaf-browser.el";
    nodeName = "browser";
    nodeModules = buildNpmPackage rec {
      pname = nodeName;
      inherit version;
      src = package_src;
      npmDepsHash = "sha256-MUf+fJdEfzU/0e4he7mVURE1osP+Jm28LduCEtcJAPg=";
      prePatch = ''
        find . -mindepth 1 -maxdepth 1 ! -name "*.json" -exec rm -rf {} ';'
        ${jq}/bin/jq 'setpath(["name"]; "${pname}") | setpath(["version"]; "${version}")' package.json > package.json.tmp
        mv package.json.tmp package.json
      '';
      dontNpmBuild = true;
    };
  in {
    pname = "eaf-browser";
    inherit version;
    src = package_src;
    postInstall = ''
      DST=$out/share/emacs/site-lisp/elpa/$ename-$melpaVersion/
      mv buffer.py $DST
      mv easylist.txt $DST
      ln -s ${nodeModules}/lib/node_modules/${nodeName}/node_modules $DST/node_modules
    '';
  })
#+end_src

***** eaf阅读器

- 外部元的链接
  
#+begin_src nix :noweb-ref externals
  eaf-pdf-viewer = {
    url = "github:emacs-eaf/eaf-pdf-viewer";
    flake = false;
  };
#+end_src

- 打包代码
  
#+begin_src nix :tangle -
  externals/eaf-pdf-viewer/default.nix 
    { package_src
    , elispFileVersion
    , lib
    , stdenv
    , writeText
    , melpaBuild
    , elpa2nix
    , melpa2nix
    , makeWrapper

    , python3
    , qt6

    , withSwayWMSupport ? stdenv.isLinux
    , jq ? null

    , withUnitySupport ? stdenv.isLinux
    , xdotool ? null

    , withX11Support ? true
    , wmctrl ? null
    }: let
      inherit (lib) readFile;
      
      python = python3.withPackages (pkgs: [
        pkgs.easyocr
        pkgs.epc
        pkgs.lxml
        pkgs.pygetwindow
        pkgs.pyqt6
        pkgs.pyqt6-sip
        pkgs.pyqt6-webengine
        pkgs.pycookiecheat
        pkgs.qrcode
        pkgs.requests
        pkgs.sexpdata
      ]);
    in (melpaBuild (finalAttrs: {
      pname = "eaf";
      version = elispFileVersion "${finalAttrs.src}/eaf.el";
      src = package_src;

      # 在这里添加makeWrapper作为构建依赖
      nativeBuildInputs = [ makeWrapper ];

      patchPhase = ''
        runHook prePatch

        sed -i s#'defcustom eaf-python-command .*'#'defcustom eaf-python-command "${python.interpreter}"'# eaf.el
        ${if withSwayWMSupport then "substituteInPlace eaf.el --replace jq ${jq}/bin/jq" else ""}
        ${if withUnitySupport then "substituteInPlace eaf.el --replace xdotool ${xdotool}/bin/xdotool" else ""}
        ${if withX11Support then "substituteInPlace eaf.el --replace wmctrl ${wmctrl}/bin/wmctrl" else ""}

        mv core/eaf-epc.el .
        mv extension/* .

        runHook postPatch
      '';

      elpa2nix = writeText "elpa2nix.el" ''
        ${readFile elpa2nix}
        (defun byte-recompile-directory (&rest _))
      '';
      melpa2nix = writeText "melpa2nix.el" ''
        ${readFile melpa2nix}
        (defun byte-recompile-directory (&rest _))
      '';
    })).overrideAttrs (old: {
      # 确保nativeBuildInputs被正确继承并添加makeWrapper
      nativeBuildInputs = (old.nativeBuildInputs or []) ++ [ makeWrapper ];
      
      # Override genericBuild's postInstall
      postInstall = ''
        DST=$out/share/emacs/site-lisp/elpa/$ename-$melpaVersion/

        mv eaf.py $DST
        mv applications.json $DST
        mv core $DST

        # 创建包装脚本目录
        mkdir -p $DST/bin

        # 直接创建包装脚本，使用PyQt6模块路径下的Qt库
        QT_LIB_PATH=$(${python}/bin/python -c "import os, PyQt6; print(os.path.join(os.path.dirname(PyQt6.__file__), 'Qt6/lib'))" 2>/dev/null)
        QT_PLUGIN_PATH=$(${python}/bin/python -c "import os, PyQt6; print(os.path.join(os.path.dirname(PyQt6.__file__), 'Qt6/plugins'))" 2>/dev/null)

       # 如果找不到常规路径，尝试其他可能的位置
       if [ ! -d "$QT_LIB_PATH" ] || [ ! -d "$QT_PLUGIN_PATH" ]; then
         QT_BASE_DIR=$(${python}/bin/python -c "import os, sys, PyQt6; print(os.path.normpath(os.path.join(os.path.dirname(PyQt6.__file__), '..', '..')))" 2>/dev/null)
         QT_LIB_PATH="$QT_BASE_DIR/lib"
         QT_PLUGIN_PATH="$QT_BASE_DIR/share/qt6/plugins"
       fi

       # 创建Python包装脚本
       makeWrapper ${python}/bin/python $DST/bin/eaf-python \
         --set LD_LIBRARY_PATH "$QT_LIB_PATH" \
         --set QT_PLUGIN_PATH "$QT_PLUGIN_PATH" \
         --set QT_QPA_PLATFORM_PLUGIN_PATH "$QT_PLUGIN_PATH/platforms" \
         --unset XDG_DATA_DIRS

       # 修改eaf.el使用包装的Python
       sed -i s#'defcustom eaf-python-command .*'#'defcustom eaf-python-command "'$DST/bin/eaf-python'"'# $DST/eaf.el
    '';
    })
#+end_src

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref epkgs
:END:

#+begin_src nix
  eaf
    eaf-browser
    # eaf-pdf-viewer
#+end_src

**** 配置
:PROPERTIES:
:header-args: :noweb-ref ecfg
:END:

#+begin_src emacs-lisp
  ;; (defvar idiig/eaf-path (concat user-emacs-directory "site-lisp/emacs-application-framework"))
  ;; (add-to-list 'load-path idiig/eaf-path)
  ;; (setq eaf-python-command (concat idiig/eaf-path "/eaf/bin/python"))

  (require 'eaf)
  (require 'eaf-browser)
  ;; (require 'eaf-pdf-viewer)

  (setq eaf-webengine-default-zoom 2.0
        eaf-browse-blank-page-url "https://kagi.com"
        eaf-browser-auto-import-chrome-cookies nil   ; 非自动 cookies
        eaf-browser-enable-autofill t                ; 自动填充密码
        eaf-browser-enable-tampermonkey t            ; 使用油猴
        )
#+end_src
