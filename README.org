:PROPERTIES:
:GPTEL_MODEL: gpt-4o-mini
:GPTEL_BACKEND: ChatGPT
:GPTEL_SYSTEM: You are a large language model living in Emacs and a helpful assistant. Respond concisely.
:GPTEL_BOUNDS: nil
:END:
#+TITLE: 基于 Nix Flakes 的 Emacs 配置

* 本配置的用法
:PROPERTIES:
:header-args: :tangle no
:END:

这份配置文件使用Nix Flakes管理包。使用Nix的这类系统管理的包的目的主要
是因为

- emacs内置的包管理器无法处理系统工具的依存：如 =ripgrep=, 特定版本的
  =python=

- 使用gitsubmodule相同

- 完全使用Nix的话，写配置和尝试包的体验感比较差

这份配置的解决法如下：

- 通过org-babel同时写作Nix和elisp。前者用于版本和包的管理，后者用于包
  的配置

- 可以在elisp中用 =$pkgs.git= 的方式直接引用Nix的包
  
- 提供一个函数加入一个新包时使用这个函数更新包列表

* 实现方式
:PROPERTIES:
:header-args: :tangle no
:END:

下面以配置 =Magit= 为例说明这个配置的方法。这里和大多数的配置一样我们
把整体目的一致的包放在一个集群实现。每个集群主要分成两个子节点，一个用
于安装包和依赖项，一个用于配置。配置部分可以细分为键位绑定，custom，
hook，config，自定义的函数。

依赖的部分可以从 =pkgs= [fn:pkgs: =nixpkgs.legacyPackages.${system}= ]
同时安装emacs外部的依赖。然后从 =epkgs= [fn:epkgs:
=pkgs.emacs.pkgs.withPackages= ]

这里稍微多做一些解释。在配置节里面，我们利用了org-babel的一些特性。首
先我们在一个汇总代码块中使用了 =:noweb=yes= [fn:noweb:关于文学编程中
=noweb= 的解释可以参考 [[https://www.cs.tufts.edu/~nr/noweb/][这个链接]] 。本身我们还有一个 =:session= 的方式更
适合一些数据科学的工作流。这里我们主要为了和 =:tangle= 引起使用。]，然
后在后面的代码块中我们使用 =:noweb-ref= 参照汇总代码块，最后后续的这些
代码块都会在tangle时合并到第一个代码块中。这个被tangle的代码块在后续过
程中会被nix依赖代码读入作为配置。

* 如何使用？
:PROPERTIES:
:header-args: :tangle no
:END:

用emacs打开本文档， =M-x org-babel-tangle= 或使用快捷键 =C-c C-v t= 生
成flake.nix。接下去运行可以通过如下方式：

** 调试
#+begin_src sh
  nix run <path/to/this/config>
  source ~/.bashrc
  emacs
  #+end_src

** 版本回滚

- 使用git：
#+begin_src sh
  git checkout <previous-commit>
  nix run
  source ~/.bashrc
  emacs
#+end_src

- 备份lock文件：
#+begin_src sh
  # 查看以前的版本
  nix flake metadata

  # 备份版本
  cp flake.lock flake.lock.bachup
  # 使用特定锁文件版本
  nix run --recreate-lock-file --inputs-from ./flake.lock.backup
#+end_src

* 配置本体
:PROPERTIES:
:header-args: :tangle no
:END:

** Flake 入口

包的安装基于下面的 =flake.nix= 和 =init.nix= 。

#+BEGIN_SRC nix :tangle flake.nix :noweb yes
  {
    description = "idiig's Emacs Configuration with Nix Flakes";

    inputs = {
      nixpkgs.url = "github:NixOS/nixpkgs/nixos-24.11";
      flake-utils.url = "github:numtide/flake-utils";
      emacs-overlay.url = "github:nix-community/emacs-overlay";

      eaf = {
        url = "github:emacs-eaf/emacs-application-framework";
        flake = false;
      };
    };

    outputs = inputs@{ self, nixpkgs, flake-utils, emacs-overlay, ... }:
      let
        mkPackages = pkgs: emacsPackages: import ./externals {
          inherit inputs pkgs emacsPackages;
        };
      in
        flake-utils.lib.eachDefaultSystem (system:
  	      let
            
  		      pkgs = import nixpkgs {
  			      inherit system;
  			      overlays = [ emacs-overlay.overlay ];
  		      };

  		      # 主配置文件
  		      emacsConfig = pkgs.writeText "init.el" ''
  	    <<emacs-config>>
  	    '';

  		      # early-init 配置文件
  		      emacsEarlyInitConfig = pkgs.writeText "early-init.el" ''
  	    <<emacs-early-init-config>>
  	    '';

            # 首先定义你的基础 Emacs
            emacs = pkgs.emacs30-gtk3;

            # 定义覆盖函数
            overrides = final: prev: mkPackages pkgs final;
            
            # 创建扩展的包集合并选择包
            emacsWithPackages = ((pkgs.emacsPackagesFor emacs).overrideScope overrides).withPackages (epkgs: with epkgs; [
              eaf
              # 现在这里可以同时访问标准包和自定义包，不需要区分
              <<emacs-packages>>
            ]);
            
  	      in {
  		      packages.default = pkgs.writeShellScriptBin "script" ''
  	      #!/usr/bin/env bash
  	      set -e

  	      # 导出配置到 nix-emacs
  	      EMACS_DIR="$HOME/nix-emacs"
  	      mkdir -p "$EMACS_DIR"
  	      ${pkgs.rsync}/bin/rsync ${emacsConfig} "$EMACS_DIR/init.el"
  	      ${pkgs.rsync}/bin/rsync ${emacsEarlyInitConfig} "$EMACS_DIR/early-init.el"

  	      # 路径
  	      <<dependencies>>

  	      # 更新 Emacs 路径（兼容 macOS 和 Linux）
          if sed --version 2>/dev/null | grep "(GNU sed)"; then
  		      sed -i '/^alias ne=/d' "$HOME/.bashrc"
  	      else
  		      sed -i \"\" '/^alias ne=/d' "$HOME/.bashrc"
  	      fi

  	      echo "alias ne='${emacsWithPackages}/bin/emacs --init-dir \"$EMACS_DIR\"'" >> "$HOME/.bashrc"

  	      # 提示用户手动 source 而不是直接执行，以避免 shell 继承问题
  	      echo "请手动运行 'source ~/.bashrc' 以使 alias 生效"
  	      echo "Emacs 配置已同步到 $EMACS_DIR"
  	      '';  
  	      });
  }
#+END_SRC

** Early init
:PROPERTIES:
:header-args: :noweb-ref emacs-early-init-config
:END:

#+begin_src emacs-lisp
  ;; 增加 GC 阈值，加快启动
  (setq gc-cons-threshold 402653184 gc-cons-percentage 0.6)

  ;; 启动完成后恢复正常 GC 设定
  (add-hook 'emacs-startup-hook
	    (lambda ()
	      (setq gc-cons-threshold 10485760
		    gc-cons-percentage 0.1)))

  ;; 禁用bidi，加速大文件
  (setq-default bidi-display-reordering nil)
  (setq bidi-inhibit-bpa t
	long-line-threshold 1000
	large-hscroll-threshold 1000
	syntax-wholeline-max 1000)
#+end_src

** Emacs基建

*** Mac OS 键位设定
:PROPERTIES:
:header-args: :noweb-ref emacs-config
:END:

#+begin_src emacs-lisp
  ;; 在mac中使用Command key作为meta
  (setq mac-option-key-is-meta nil
	mac-command-key-is-meta t
	mac-command-modifier 'meta
	mac-option-modifier 'none)

  ;; 便于使用mac的JIS日语键盘
  (global-set-key (kbd "C-¥") 'toggle-input-method)
#+end_src

#+RESULTS:
: toggle-input-method

*** 更好的默认设置
**** 本体的设定
:PROPERTIES:
:header-args: :noweb-ref emacs-config
:END:

***** 关闭警告声
#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
#+end_src

***** 确认使用y或n

而不是yes或no。
#+begin_src emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

***** 递归minibuffer
#+begin_src emacs-lisp
  (setq enable-recursive-minibuffers t)
#+end_src

***** UI

#+begin_src emacs-lisp
  ;; 基础设置
  (tool-bar-mode -1) ;; 关闭工具栏
  (scroll-bar-mode -1) ;; 关闭文件滑动控件
  (setq inhibit-splash-screen 1) ;; 关闭启动帮助画面
  (setq initial-frame-alist (quote ((fullscreen . maximized)))) ;; 全屏
  (setq initial-scratch-message nil) ;; 关闭scratch message
  (setq inhibit-startup-message t) ;; 关闭启动信息
  (setq frame-title-format
        ;; 窗口显示文件路径/buffer名
        '("" " idiig - "
          (:eval (if (buffer-file-name)
                     (abbreviate-file-name (buffer-file-name)) "%b"))))
  (setq ns-use-proxy-icon nil)  ;; 删除frame icon
#+end_src

- 主题

#+begin_src emacs-lisp
  (require-theme 'modus-themes)
#+end_src

***** 在选中区域的状态下 =C-w= 删除选中的区域

而不是删除上一个合并区域。
#+begin_src emacs-lisp
  (defun backward-kill-word-or-region (&optional arg)
    (interactive "p")
    (if (region-active-p)
	(call-interactively #'kill-region)
      (backward-kill-word arg)))
#+end_src

***** 光标跳到新窗口

emacs在打开新的窗口时，默认光标维持在原来的窗口。比如当你使用
=describe-function= 时，光标不会跳到函数的简介窗口。在这类窗口我们本身
可以按 =q= 来退出和关闭窗口。所以跳转到新窗口非常便利。

- 专用buffer（display-buffer行为；主要影响 Emacs 自动创建的窗口（如
  help、compilation 等）。注意这里也会影响到 =magit= 这类 transient 窗
  口
#+begin_src emacs-lisp
  (setq switch-to-buffer-obey-display-actions t)
  (setq switch-to-buffer-in-dedicated-window 'pop)
  (customize-set-variable 'display-buffer-base-action
			  '((display-buffer-reuse-window display-buffer-same-window)
			    (reusable-frames . t)))
#+end_src

- split-window时转跳到新窗口
#+begin_src emacs-lisp
  (defadvice split-window-below (after split-window-below-and-switch activate)
    "切换到新分割的窗口"
    (when (called-interactively-p 'any)
      (other-window 1)))

  (defadvice split-window-right (after split-window-right-and-switch activate)
    "切换到新分割的窗口"
    (when (called-interactively-p 'any)
      (other-window 1)))
#+end_src

***** 窗口的放大缩小转变为持续的行为
而不是要一直要重复 =C-x= 按键。后续行为使用默认 =^V/{/}=

这里我没用 =C-x v= 是因为这个键位目前用于 =vc= 。

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x V") 'shrink-window)

  (defun idiig/window-adjust (orig-fun &rest args)
    "使用 Emacs 风格按键 (^, V, {, }, +) 持续调整窗口大小。"
    (let* ((ev last-command-event)
	   (echo-keystrokes nil))
      ;; 执行初始调整
      (apply orig-fun args)

      ;; 设置 transient map
      (let ((delta (car args))) 
	(set-transient-map
	 (let ((map (make-sparse-keymap)))
	   ;; 垂直调整
	   (define-key map (kbd "^")
		       `(lambda () (interactive) (enlarge-window ,delta nil)))
	   (define-key map (kbd "V")
		       `(lambda () (interactive) (shrink-window ,delta nil)))

	   ;; 水平调整
	   (define-key map (kbd "{")
		       `(lambda () (interactive) (shrink-window ,delta t)))
	   (define-key map (kbd "}")
		       `(lambda () (interactive) (enlarge-window ,delta t)))

	   ;; 平衡窗口
	   (define-key map (kbd "+")
		       (lambda () (interactive) (balance-windows)))
	   map)
	 nil nil
	 "Use %k for further adjustment"))))

  ;; ;; 如果需要移除 advice:
  ;; (advice-remove 'enlarge-window #'idiig/window-adjust)
  ;; (advice-remove 'shrink-window #'idiig/window-adjust)
  ;; (advice-remove 'enlarge-window-horizontally #'idiig/window-adjust)
  ;; (advice-remove 'shrink-window-horizontally #'idiig/window-adjust)

  ;; 添加 advice
  (advice-add 'enlarge-window :around #'idiig/window-adjust)
  (advice-add 'shrink-window :around #'idiig/window-adjust)
  (advice-add 'enlarge-window-horizontally :around #'idiig/window-adjust)
  (advice-add 'shrink-window-horizontally :around #'idiig/window-adjust)
#+end_src

**** 撤回（vundo）
我原来使用 undotree ，现在使用 vundo。这些用于视觉化撤销树

***** 依赖
:PROPERTIES:
:header-args: :noweb-ref emacs-packages
:END:

#+BEGIN_SRC nix 
  vundo
#+END_SRC

***** 配置
:PROPERTIES:
:header-args: :noweb-ref emacs-config
:END:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x u") 'vundo)
#+end_src


**** 检索（ctrlf）

针对当前buffer利用 =Ctrlf= 而不在使用swiper和helm这类型的检索方式。
***** 依赖
:PROPERTIES:
:header-args: :noweb-ref emacs-packages
:END:

#+BEGIN_SRC nix 
  ctrlf
#+END_SRC

***** 配置
:PROPERTIES:
:header-args: :noweb-ref emacs-config
:END:

#+begin_src emacs-lisp
  (require 'ctrlf)
  (ctrlf-mode +1)
#+end_src

** CJK字体

这里我统一使用的是Sarasa的等宽字体，可以避免2个问题：
- 输入latin以后输入cjk文字以后，由于字体高度不等导致行高抖动
- 方便org等表格等宽表示

*** 依赖
:PROPERTIES:
:header-args: :noweb-ref dependencies
:END:
#+begin_src sh
  if [ "$(uname)" = "Darwin" ]; then
    # macOS
    mkdir -p "$HOME/Library/Fonts/"
    ${pkgs.rsync}/bin/rsync -av ${pkgs.sarasa-gothic}/share/fonts/truetype/ "$HOME/Library/Fonts/"
  else
    # Assume Linux
    mkdir -p "$HOME/.local/share/fonts/truetype/"
    ${pkgs.rsync}/bin/rsync -av ${pkgs.sarasa-gothic}/share/fonts/truetype/ "$HOME/.local/share/fonts/sarasa-gothic/"
    fc-cache -f -v ~/.local/share/fonts/
  fi

#+end_src

*** 配置
:PROPERTIES:
:header-args: :noweb-ref emacs-config
:END:

#+begin_src emacs-lisp
  (add-hook 'after-init-hook
  	    (lambda ()
  	      (let* ((screen-height (display-pixel-height))
  		     (font-height (if (and
  				       (< screen-height 1150)
  				       (> screen-height 1200)) 230 130))  ;; 根据屏幕高度调整
  		     (minibuffer-font-height (- font-height 0))
  		     (my-font "Sarasa Mono SC"))
  		(set-face-attribute 'default nil :family my-font :height font-height)
  		;; 设置 mode-line 字体
  		(set-face-attribute 'mode-line nil :family my-font :height font-height)
  		(set-face-attribute 'mode-line-inactive nil :family my-font :height font-height)
  		;; 设置 minibuffer 字体
  		(set-face-attribute 'minibuffer-prompt nil :family my-font :height minibuffer-font-height))))

  ;; 工具栏，菜单保持默认字体
  (set-face-attribute 'menu nil :inherit 'unspecified)
  (set-face-attribute 'tool-bar nil :inherit 'unspecified)
#+end_src

** 日文

*** 输入法

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref emacs-packages
:END:

#+BEGIN_SRC nix 
  ddskk
#+END_SRC

**** 配置
:PROPERTIES:
:header-args: :noweb-ref emacs-config
:END:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x j") 'skk-mode)

  (with-eval-after-load 'ddskk
    (setq skk-server-inhibit-startup-server nil)
    (setq skk-server-host "localhost")
    (setq skk-server-portnum 55100)
    (setq skk-share-private-jisyo t)

    ;; 候补显示设置
    (setq skk-show-inline t)
    (setq skk-show-tooltip t)
    (setq skk-show-candidates-always-pop-to-buffer t)
    (setq skk-henkan-show-candidates-rows 2)

    ;; 行为设置
    (setq skk-egg-like-newline t)
    (setq skk-delete-implies-kakutei nil)
    (setq skk-use-look t)
    (setq skk-auto-insert-paren t)
    (setq skk-henkan-strict-okuri-precedence t)

    ;; 加载额外功能
    (require 'skk-hint)
    (add-hook 'skk-load-hook
	      (lambda ()
		(require 'context-skk)))

    ;; 片假名转换设置
    (setq skk-search-katakana 'jisx0201-kana))

  ;; (require 'ddskk nil t)
#+end_src

*** TODO 检索（Migemo）
**** 依赖
:PROPERTIES:
:header-args: :noweb-ref emacs-packages
:END:
**** 配置
:PROPERTIES:
:header-args: :noweb-ref emacs-config
:END:

** 中文

*** 输入法

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref emacs-packages
:END:

#+BEGIN_SRC nix 
  # (pkgs.emacsPackages.pyim.overrideAttrs (old: {
  #     nativeComp = false;
  # }))
  pyim
    pyim-basedict
#+END_SRC

**** 配置
:PROPERTIES:
:header-args: :noweb-ref emacs-config
:END:

***** 基础设定
#+begin_src emacs-lisp
  (with-eval-after-load 'pyim
    ;; 基本设置
    (setq default-input-method "pyim")
    (setq pyim-dcache-directory "~/.emacs.d/.cache/pyim/dcache/")
    ;; 输入法设置为全拼
    (setq pyim-default-scheme 'quanpin)
    ;; 启用搜索功能
    (pyim-isearch-mode 1)
    ;; 选词框设置
    (setq pyim-page-tooltip 'popup)
    (setq pyim-page-length 5)
    ;; 加载并启用基础词库
    (require 'pyim-basedict)
    (pyim-basedict-enable))

  ;; diminish 设置 (如果使用 diminish)
  (with-eval-after-load 'diminish
    (diminish 'pyim-isearch-mode))
#+end_src

***** TODO 正则表达交互

目前支持

- 在minibuffer中用 =C-Ret= 把单字拼音转换为该读音本身代表的中文正则表达
- =M-x idiig/toggle-pyim-region= 用于开关中文的forward-word和backward
- 激活进入pyim时，自动开启中文的forward和backward
  
#+begin_src emacs-lisp
  (with-eval-after-load 'pyim
    (require 'pyim-cstring-utils)

    ;; C-return 把当前选中的位置转换为正则表达
    (define-key minibuffer-local-map (kbd "C-<return>") 'pyim-cregexp-convert-at-point)

    (defvar idiig/pyim-region-enabled nil
      "记录pyim区域功能是否启用的状态变量。")

    (defun idiig/toggle-pyim-region ()
      "切换pyim的单词移动功能。
  当启用时，会将forward-word和backward-word重映射为pyim的相应函数；
  当禁用时，会恢复原来的映射。"
      (interactive)
      (call-interactively #'pyim-activate)
      (call-interactively #'pyim-deactivate)
      (if idiig/pyim-region-enabled
	  (progn
	    (idiig/disable-pyim-region)
	    (setq idiig/pyim-region-enabled nil)
	    (message "已禁用pyim区域功能"))
	(progn
	  (idiig/enable-pyim-region)
	  (setq idiig/pyim-region-enabled t)
	  (message "已启用pyim区域功能"))))

    (defun idiig/enable-pyim-region (&rest _)
      "启用pyim的单词移动建议。"
      (global-set-key [remap forward-word] 'pyim-forward-word)
      (global-set-key [remap backward-word] 'pyim-backward-word))

    (defun idiig/disable-pyim-region (&rest _)
      "禁用pyim的单词移动建议。"
      (global-unset-key [remap forward-word])
      (global-unset-key [remap backward-word]))

    ;; ;; 挂钩到 pyim 的启用/禁用钩子上
    ;; (advice-remove 'pyim-deactivate #'idiig/disable-pyim-region)
    ;; (advice-remove 'pyim-activate #'idiig/enable-pyim-region)
    ;; (advice-add 'pyim-deactivate :after #'idiig/disable-pyim-region)
    (advice-add 'pyim-activate :after #'idiig/enable-pyim-region))
#+end_src

***** Orderless交互
#+begin_src emacs-lisp
  ;; 确保在 orderless 加载后再加载这些配置
  (with-eval-after-load 'orderless
    ;; 拼音检索字符串功能
    (defun zh-orderless-regexp (orig_func component)
      (call-interactively #'pyim-activate)
      (call-interactively #'pyim-deactivate)
      (let ((result (funcall orig_func component)))
	(pyim-cregexp-build result)))
    (advice-add 'orderless-regexp :around #'zh-orderless-regexp))
#+end_src

** Git相关配置

*** 依赖
:PROPERTIES:
:header-args: :noweb-ref emacs-packages
:END:

**** Magit
#+BEGIN_SRC nix
  magit
#+END_SRC

**** Git 目录路径
#+begin_src emacs-lisp  :noweb-ref emacs-config
  (add-to-list 'exec-path "${pkgs.git}/bin")
#+end_src

*** 配置
:PROPERTIES:
:header-args: :noweb-ref emacs-config
:END:

**** Magit

***** 基础设定
#+BEGIN_SRC emacs-lisp
  (require 'magit)
#+END_SRC

** 编程语言
*** 我有可能使用的语言
:PROPERTIES:
:header-args: :noweb-ref emacs-config
:END:

#+begin_src emacs-lisp
  (defvar idiig/language-list
    '("emacs-lisp" "python" "C" "shell" "js" "clojure" "css" "nix"
      "dot" "gnuplot" "R" "sql" "awk" "haskell" "latex" "lisp"
      "org" "julia" "scheme" "sqlite")
    "支持的编程语言列表。")
#+end_src

** Org Mode相关配置
*** Org本体
:PROPERTIES:
:header-args: :noweb-ref emacs-config
:END:

**** 函数与advice

=org-insert-structure-template= 后选择 =s= (src block) 时自动提示插入代码块的语言

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (defun idiig/org-insert-structure-template-src-advice (orig-fun type)
      "Advice for org-insert-structure-template to handle src blocks."
      (if (string= type "src")  ; 判断条件为 "src"
	  (let ((selected-type (ido-completing-read "Source code type: " idiig/language-list)))
	    (funcall orig-fun (format "src %s" selected-type)))
	(funcall orig-fun type)))

    (advice-add 'org-insert-structure-template :around #'idiig/org-insert-structure-template-src-advice))
#+end_src

**** 代码块支持语言
***** 依赖
由于 =ob-nix= 还没有默认。我们需要添加这些依赖

#+begin_src nix :noweb-ref emacs-packages
  ob-nix
#+end_src

***** 配置
#+begin_src emacs-lisp
  (defun idiig/load-org-babel-languages ()
    "根据 `idiig/language-list` 启用 `org-babel` 语言。"
    (let ((languages '()))
      (dolist (lang idiig/language-list)
	(push (cons (intern lang) t) languages)) ;; 将字符串转换为符号
      (org-babel-do-load-languages 'org-babel-load-languages languages)))

  (add-hook 'org-mode-hook #'idiig/load-org-babel-languages)
#+end_src


**** TODO 基础设定

- 允许shift用于选择
#+begin_src emacs-lisp 
  (with-eval-after-load 'org
    (setq org-support-shift-select 2))
#+end_src

- 允许折行
#+begin_src emacs-lisp
  (add-hook 'org-mode-hook #'visual-line-mode)
#+end_src

- 远程图片文件可以通过 =C-u C-c C-x C-v= 被看到
#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (setq org-display-remote-inline-images t))
#+end_src

** AI辅助功能

*** 文档写作

**** gptel.el

***** 依赖
:PROPERTIES:
:header-args: :noweb-ref emacs-packages
:END:

#+BEGIN_SRC nix
  gptel
#+END_SRC

***** TODO 配置
:PROPERTIES:
:header-args: :noweb-ref emacs-config
:END:
#+begin_src emacs-lisp
  (add-hook 'org-mode-hook
            (lambda ()
              (when (string-match-p "\\.ai\\.org\\'" (buffer-file-name))
                (gptel-mode 1))))
#+end_src

*** Aider

**** 依赖
:PROPERTIES:
:header-args: :noweb-ref emacs-packages
:END:

***** TODO Aider.el
#+BEGIN_SRC nix
  # aider
#+END_SRC

***** Aider 目录路径
#+begin_src emacs-lisp  :noweb-ref emacs-config
  (add-to-list 'exec-path "${pkgs.aider-chat}/bin")
#+end_src

**** TODO 配置
:PROPERTIES:
:header-args: :noweb-ref emacs-config
:END:

** 模态编辑（Meow）
*** 依赖
:PROPERTIES:
:header-args: :noweb-ref emacs-packages
:END:
#+begin_src nix
  meow
  meow-tree-sitter
#+end_src

*** 配置
:PROPERTIES:
:header-args: :noweb-ref emacs-config
:END:

#+begin_src emacs-lisp
  ;; (defalias 'meow-visit #'ctrlf-forward-default) ; 需要ctrlf

  ;; https://github.com/meow-edit/meow/blob/master/KEYBINDING_QWERTY.org
  (defun meow-setup ()
    (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
    (meow-motion-define-key
     '("j" . meow-next)
     '("k" . meow-prev)
     '("<escape>" . ignore))
    (meow-leader-define-key
     ;; Use SPC (0-9) for digit arguments.
     '("1" . meow-digit-argument)
     '("2" . meow-digit-argument)
     '("3" . meow-digit-argument)
     '("4" . meow-digit-argument)
     '("5" . meow-digit-argument)
     '("6" . meow-digit-argument)
     '("7" . meow-digit-argument)
     '("8" . meow-digit-argument)
     '("9" . meow-digit-argument)
     '("0" . meow-digit-argument)
     '("/" . meow-keypad-describe-key)
     '("?" . meow-cheatsheet))
    (meow-normal-define-key
     '("0" . meow-expand-0)
     '("9" . meow-expand-9)
     '("8" . meow-expand-8)
     '("7" . meow-expand-7)
     '("6" . meow-expand-6)
     '("5" . meow-expand-5)
     '("4" . meow-expand-4)
     '("3" . meow-expand-3)
     '("2" . meow-expand-2)
     '("1" . meow-expand-1)
     '("-" . negative-argument)
     '(";" . meow-reverse)
     '("," . meow-inner-of-thing)
     '("." . meow-bounds-of-thing)
     '("[" . meow-beginning-of-thing)
     '("]" . meow-end-of-thing)
     '("a" . meow-append)
     '("A" . meow-open-below)
     '("b" . meow-back-word)
     '("B" . meow-back-symbol)
     '("c" . meow-change)
     '("d" . meow-delete)
     '("D" . meow-backward-delete)
     '("e" . meow-next-word)
     '("E" . meow-next-symbol)
     '("f" . meow-find)
     '("g" . meow-cancel-selection)
     '("G" . meow-grab)
     '("h" . meow-left)
     '("H" . meow-left-expand)
     '("i" . meow-insert)
     '("I" . meow-open-above)
     '("j" . meow-next)
     '("J" . meow-next-expand)
     '("k" . meow-prev)
     '("K" . meow-prev-expand)
     '("l" . meow-right)
     '("L" . meow-right-expand)
     '("m" . meow-join)
     '("n" . meow-search)
     '("o" . meow-block)
     '("O" . meow-to-block)
     '("p" . meow-yank)
     '("q" . meow-quit)
     '("Q" . meow-goto-line)
     '("r" . meow-replace)
     '("R" . meow-swap-grab)
     '("s" . meow-kill)
     '("t" . meow-till)
     '("u" . meow-undo)
     '("U" . meow-undo-in-selection)
     '("v" . meow-visit)
     '("w" . meow-mark-word)
     '("W" . meow-mark-symbol)
     '("x" . meow-line)
     '("X" . meow-goto-line)
     '("y" . meow-save)
     '("Y" . meow-sync-grab)
     '("z" . meow-pop-selection)
     '("'" . repeat)
     '("<escape>" . ignore)))

  (require 'meow)
  (meow-setup)
  (meow-global-mode 1)
#+end_src

给meow增加treesitter的功能：
#+begin_src emacs-lisp
  (require 'meow-tree-sitter)
  (meow-tree-sitter-register-defaults)  
#+end_src

在 meow-edit 退出 insert-state 时，当前输入方式自动被关闭，而再次进入
insert-state 时重新打开输入方式：
#+begin_src emacs-lisp
  (defvar-local the-late-input-method nil)
  (add-hook 'meow-insert-enter-hook
	    (lambda ()
	      (activate-input-method the-late-input-method)))
  (add-hook 'meow-insert-exit-hook
	    (lambda ()
	      (setq the-late-input-method current-input-method)
	      (deactivate-input-method)))
#+end_src

** 编程语言

*** 语言服务器（LSP-Bridge)

*** Nix
:PROPERTIES:
:header-args: :noweb-ref emacs-packages
:END:

#+begin_src nix
  nix-mode
#+end_src

** 扩展


这里我无法handle nix用于安装这些不存在在 =nixpkgs= 里的包，只能暂时通
过用手工下载的方式下载，所以不能保证工作环境。

这里的python，我不直接用 =nixpkgs= 里的，我用使用 =uv= ，通过 =uv= 我
可以分离管理依赖的包和文件。 =uv= 的基础使用如下：

#+begin_src shell :noweb-ref nil
  uv venv <虚拟环境名>  # 创建虚拟环境
  source <虚拟环境路径>/bin activate  # 激活虚拟环境

  # 直接用 uv 为当前虚拟环境下载包
  uv pip install <包的名字>

  # 或者先为当前虚拟环境下载 pip，
  # 然后在用 pip 下载其他包，
  # eaf 这类本身自带下载依赖代码的包适合用这个方法
  uv pip install pip
  python -m pip install <包名>

  # 或
  <虚拟环境路径>/bin/python -m pip install <包名>
#+end_src

*** EAF扩展
**** 依赖
:PROPERTIES:
:header-args: :noweb-ref dependencies
:END:

注意这里需要自行运行：

#+begin_src shell :tangle externals/eaf/install-env.sh :noweb-ref nil
  nix profile install "nixpkgs#gcc.cc.lib"
  nix profile install "nixpkgs#libGL"
  nix profile install "nixpkgs#nss"
  nix profile install "nixpkgs#nspr"
  nix profile install "nixpkgs#xorg.libX11"
  nix profile install "nixpkgs#xorg.libXcomposite"
  nix profile install "nixpkgs#xorg.libXdamage"
  nix profile install "nixpkgs#xorg.libXext"
  nix profile install "nixpkgs#xorg.libXfixes"
  nix profile install "nixpkgs#xorg.libXrender"
  nix profile install "nixpkgs#xorg.libXrandr"
  nix profile install "nixpkgs#xorg.libXtst"
  nix profile install "nixpkgs#fontconfig.lib"
  nix profile install "nixpkgs#fontconfig.out"
  nix profile install "nixpkgs#freetype"
  nix profile install "nixpkgs#libdrm.out"
  nix profile install "nixpkgs#expat"
  nix profile install "nixpkgs#xorg.libXi"
  nix profile install "nixpkgs#alsa-lib"
  nix profile install "nixpkgs#zlib"
  nix profile install "nixpkgs#dbus.lib"
  nix profile install "nixpkgs#xorg.libxkbfile"
  nix profile install "nixpkgs#xorg.libxshmfence"
  nix profile install "nixpkgs#glib.out"
  nix profile install "nixpkgs#krb5"

  nix profile install "nixpkgs#libxkbcommon"
  nix profile install "nixpkgs#xorg.libxcb"
  nix profile install "nixpkgs#xorg.xcbutilcursor"
  nix profile install "nixpkgs#xorg.xcbutilicccm"
  nix profile install "nixpkgs#xorg.xcbutilimage"
  nix profile install "nixpkgs#xorg.xcbutilkeysyms"
  nix profile install "nixpkgs#xorg.xcbutilrenderutil"
  nix profile install "nixpkgs#xorg.xcbutilwm"

  nix profile install "nixpkgs#qt6.qtbase"
  nix profile install "nixpkgs#qt6.qtdeclarative"
  nix profile install "nixpkgs#qt6.qtwebengine"

  nix profile install "nixpkgs#python3"
  nix profile install "nixpkgs#uv"
#+end_src

#+begin_src shell :tangle externals/eaf/install.sh :noweb-ref nil
  #!/usr/bin/env bash

  TARGET_DIR="$HOME/nix-emacs/site-lisp/emacs-application-framework"
  mkdir -p "$HOME/nix-emacs/site-lisp"
  cd "$HOME/nix-emacs/site-lisp" || exit 1

  # --- 3. 克隆或更新 EAF 仓库 ---
  if [ -d "$TARGET_DIR" ]; then
      echo "目标目录已存在，跳过克隆过程。"
      cd "$TARGET_DIR" || exit 1
  else
      echo "目标目录不存在，开始克隆 EAF 仓库……"
      git clone --depth=1 -b master https://github.com/emacs-eaf/emacs-application-framework.git "$TARGET_DIR"
      cd "$TARGET_DIR" || exit 1
      chmod +x ./install-eaf.py
  fi

  # --- 4. 创建（或复用）Python 虚拟环境 ---
  if [ ! -d eaf ]; then
      # 如果不想使用 uv，可以改成 python -m venv eaf
      uv venv eaf
      echo "已创建虚拟环境 eaf/"
  fi

  # 进入虚拟环境
  source eaf/bin/activate

  # 升级 pip
  uv pip install --upgrade pip

  # --- 5. 执行安装 eaf ---
  # 如果你想指定安装子功能，可加选项。例如:
  # ./install-eaf.py -i pdf-viewer browser
  # ./install-eaf.py --ignore-core-deps
  ./install-eaf.py

  # --- 1. 设置 Qt 环境变量 ---
  # 使用 ~/.bashrc 作为配置文件
  SHELL_RC="$HOME/.bashrc"

  # 获取 Qt 相关路径
  QT_LIB_PATH=$(python -c "import os, PyQt6; print(os.path.join(os.path.dirname(PyQt6.__file__), 'Qt6/lib'))" 2>/dev/null)
  QT_PLUGIN_PATH=$(python -c "import os, PyQt6; print(os.path.join(os.path.dirname(PyQt6.__file__), 'Qt6/plugins'))" 2>/dev/null)

  # 检查并添加环境变量到 .bashrc
  if [ -n "$QT_LIB_PATH" ] && [ -d "$QT_LIB_PATH" ]; then
      # 清除旧的 EAF 配置，防止重复添加
      sed -i '/# EAF Qt 环境变量配置/,/^$/d' "$SHELL_RC"
      
      # 添加新的环境变量配置
      echo "" >> "$SHELL_RC"
      echo "# EAF Qt 环境变量配置" >> "$SHELL_RC"
      
      # 设置库路径，确保不重复
      echo "export LD_LIBRARY_PATH=\"$QT_LIB_PATH:\$HOME/.nix-profile/lib:\$LD_LIBRARY_PATH\"" >> "$SHELL_RC"
      
      if [ -n "$QT_PLUGIN_PATH" ] && [ -d "$QT_PLUGIN_PATH" ]; then
          echo "export QT_QPA_PLATFORM_PLUGIN_PATH=\"$QT_PLUGIN_PATH\"" >> "$SHELL_RC"
          echo "export QT_PLUGIN_PATH=\"$QT_PLUGIN_PATH\"" >> "$SHELL_RC"
          
          # 改进的 xcb/wayland 检测逻辑
          if [ -f "$QT_PLUGIN_PATH/platforms/libqxcb.so" ]; then
              # 存在 xcb 插件，添加必要的 xcb 相关环境变量
              echo "# XCB 相关配置" >> "$SHELL_RC"
              echo "export XCURSOR_PATH=\"\$HOME/.nix-profile/share/icons:\$XCURSOR_PATH\"" >> "$SHELL_RC"
              echo "export XDG_DATA_DIRS=\"\$HOME/.nix-profile/share:\$XDG_DATA_DIRS\"" >> "$SHELL_RC"
              echo "export QT_XCB_GL_INTEGRATION=none" >> "$SHELL_RC"
          elif [ -f "$QT_PLUGIN_PATH/platforms/libqwayland.so" ]; then
              # 如果没有 xcb 但有 wayland，则使用 wayland
              echo "export QT_QPA_PLATFORM=wayland" >> "$SHELL_RC"
          fi
      fi
      
      # Nix 环境特殊处理
      if command -v nix >/dev/null 2>&1; then
          echo "# Nix 特殊环境配置" >> "$SHELL_RC"
          echo "export NIX_SKIP_LOCKING_ASSERTIONS=1" >> "$SHELL_RC"
      fi
      
      # 添加调试选项（默认注释掉）
      echo "# 取消注释以下行启用 Qt 插件调试" >> "$SHELL_RC"
      echo "#export QT_DEBUG_PLUGINS=1" >> "$SHELL_RC"
      
      echo "" >> "$SHELL_RC"
      echo "已添加 Qt 环境变量配置到 $SHELL_RC"
  else
      echo "警告：未找到 PyQt6 Qt 库路径"
  fi

  # 如果不想留在 venv 中，就在脚本里 deactivate；否则可以省略这行
  deactivate

  echo "EAF 安装过程结束。"
  echo "注意：环境变量配置已添加到 $SHELL_RC，请运行 'source $SHELL_RC' 或重启终端使其生效。"
  echo "      如果想在脚本结束后依然保持虚拟环境激活，请用 'source install-eaf.sh' 运行脚本。"

  # 添加一个简单的运行测试函数到 .bashrc
  cat >> "$SHELL_RC" << 'EOF'

  # EAF 测试函数
  eaf_test() {
      cd $HOME/nix-emacs/site-lisp/emacs-application-framework
      source eaf/bin/activate
      python -c "
  try:
      import PyQt6.QtWidgets
      print('PyQt6 导入成功')
      try:
          app = PyQt6.QtWidgets.QApplication([])
          print('成功创建 QApplication，Qt 环境正常')
      except Exception as e:
          print('创建 QApplication 失败:', e)
  except Exception as e:
      print('PyQt6 导入失败:', e)
  "
      deactivate
  }
  EOF

  echo "已添加 eaf_test 函数到 $SHELL_RC，你可以运行 'eaf_test' 来测试 Qt 环境是否正常"
#+end_src

#+begin_src nix :tangle eaf-env.nix :noweb-ref nil
  { pkgs ? import <nixpkgs> {} }:

  let
    # Python packages needed for EAF
    my-python-packages = python-packages: with python-packages; [
      pandas
      requests
      sexpdata
      tld
      pyqt6
      pyqt6-sip
      pyqt6-webengine
      epc
      lxml       # for eaf
      qrcode     # eaf-file-browser
      pysocks    # eaf-browser
      pymupdf    # eaf-pdf-viewer
      pypinyin   # eaf-file-manager
      psutil     # eaf-system-monitor
      retry      # eaf-markdown-previewer
      markdown
    ];
    python-with-packages = pkgs.python3.withPackages my-python-packages;
  in
  pkgs.mkShell {
    buildInputs = with pkgs; [
      
      # System dependencies
      git
      nodejs
      wmctrl
      xdotool
      aria    # for eaf-browser
      fd      # for eaf-file-manager

      # Python with required packages
      python-with-packages
      pkgs.qt6.qtbase
      pkgs.qt6.qtwebengine

      # OpenGL/VAAPI support
      libvdpau-va-gl
    ];

    # 环境变量设置
    shellHook = ''
      TARGET_DIR="$HOME/nix-emacs/site-lisp/emacs-application-framework"
      EAF_PYTHON_PATH="$TARGET_DIR/eaf"

      export QT_QPA_PLATFORM_PLUGIN_PATH="${pkgs.qt6.qtbase.outPath}/lib/qt-6/plugins"   

      if [ -d "$TARGET_DIR" ]; then
          echo "目标目录已存在，跳过下载过程。"
          cd $TARGET_DIR
          ./install-eaf.py --ignore-core-deps
      else
          git clone --depth=1 -b master https://github.com/emacs-eaf/emacs-application-framework.git $TARGET_DIR
          cd $TARGET_DIR
          chmod +x ./install-eaf.py
          ./install-eaf.py  --ignore-core-deps
      fi

    '';
  }
#+end_src

**** 配置
:PROPERTIES:
:header-args: :noweb-ref emacs-config
:END:

加载 EAF
#+begin_src emacs-lisp
  ;; (defvar idiig/eaf-path (concat user-emacs-directory "site-lisp/emacs-application-framework"))

  ;; (add-to-list 'load-path idiig/eaf-path)
  (require 'eaf)
  ;; (setq eaf-python-command (concat idiig/eaf-path "/eaf/bin/python"))
  ;; (require 'eaf-browser)
  ;; (require 'eaf-pdf-viewer)
#+end_src


**** TODO 本体通过nix安装
:PROPERTIES:
:header-args: :noweb-ref nil :tangle no
:END:

这里我比较难以实现这种在安装后可以选择独立下载其他依存的包。目前下面是
一个最可供参考的例子。未来考虑尝试。

- [[https://codeberg.org/heraplem/nix-emacs-extra/src/branch/emacs-application-framework/packages/eaf][eaf 和其他的没在 nixpkgs 中的包的包装]]

另外，下面的代码是一个失败的尝试。

#+begin_src nix 
  [(pkgs.callPackage ./dependencies/eaf.nix { inherit pkgs; })] ++
#+end_src

#+begin_src nix :tangle externals/default.nix
  { inputs, pkgs, emacsPackages }: let
    inherit (builtins) readDir;
    inherit (pkgs) runCommand;
    inherit (pkgs.lib) attrNames attrsToList filter functionArgs hasAttr mergeAttrsList pipe readFile remove;
    packagesDir = ./.;
    packageSources = inputs // {
      # nano = inputs.nano-emacs;
    };
    importFile = dir: let
      packageFunction = import "${packagesDir}/${dir}";
    in emacsPackages.callPackage packageFunction (
      pipe ({
        elispFileVersion = file: let
          output = runCommand "${baseNameOf file}-version" { } ''
            ${emacsPackages.emacs}/bin/emacs -Q --batch \
              --eval "(require 'lisp-mnt)" \
              --eval '(setq pkg-version (lm-version "${file}"))' \
              --eval '(find-file (getenv "out"))' \
              --eval '(insert pkg-version)' \
              --eval '(save-buffer)'
          '';
        in readFile output;
        pkgFileVersion = file: let
          output = runCommand "${baseNameOf file}-version" { } ''
            ${emacsPackages.emacs}/bin/emacs -Q --batch \
              --eval '(find-file "${file}")' \
              --eval '(setq pkg-version (caddr (read (current-buffer))))' \
              --eval '(find-file (getenv "out"))' \
              --eval '(insert pkg-version)' \
              --eval '(save-buffer)'
          '';
        in readFile output;
        normalizeVersion = name: version: let
          output = runCommand "${name}-normalized-version" { } ''
            ${emacsPackages.emacs}/bin/emacs -Q --batch \
              --load package \
              --eval '(setq pkg-version (package-version-join (version-to-list "${version}")))' \
              --eval '(find-file (getenv "out"))' \
              --eval '(insert pkg-version)' \
              --eval '(save-buffer)'
          '';
        in readFile output;
        genericBuild = emacsPackages.callPackage "${inputs.nixpkgs}/pkgs/applications/editors/emacs/build-support/generic.nix" { };
        elpa2nix = "${inputs.nixpkgs}/pkgs/applications/editors/emacs/build-support/elpa2nix.el";
        melpa2nix = "${inputs.nixpkgs}/pkgs/applications/editors/emacs/build-support/melpa2nix.el";
      } // (if hasAttr dir packageSources then { package_src = packageSources.${dir}; } else { })
      ) [
        attrsToList
        # => [ 
        #      { name = "elispFileVersion"; value = <function>; }
        #      { name = "pkgFileVersion"; value = <function>; }
        #      { name = "normalizeVersion"; value = <function>; }
        #      { name = "genericBuild"; value = <function>; }
        #      { name = "elpa2nix"; value = "/path/to/elpa2nix.el"; }
        #      { name = "melpa2nix"; value = "/path/to/melpa2nix.el"; }
        #    ]
        (filter ({ name, ... }: hasAttr name (functionArgs packageFunction)))
        # => 假设 packageFunction 需要 elispFileVersion 和 genericBuild
        # => [ 
        #      { name = "elispFileVersion"; value = <function>; }
        #      { name = "genericBuild"; value = <function>; }
        #    ]
        (map ({ name, value }: { ${name} = value; }))
        # => [
        #      { elispFileVersion = <function>; }
        #      { genericBuild = <function>; }
        #    ]
        mergeAttrsList
        # => { 
        #      elispFileVersion = <function>;
        #      genericBuild = <function>;
        #    }
        # 一般来讲，我们会这么写 import XXX.nix { inherit attr; };
        # 这里相当于最后得到一个传入 XXX.nix 的一个参数集
      ]
    );  # Nix 中 pipe 的写法是 pipe <初始对象> [ <函数1> <函数2> ... ]
  in pipe packagesDir [                            # => ./. (当前包目录)
    readDir                                        # => { "package1" = "directory"; "package2" = "directory"; "default.nix" = "regular"; ... }
    attrNames                                      # => [ "package1" "package2" "default.nix" ... ]
    (remove "default.nix")                         # => [ "package1" "package2" ... ]
    (map (dir: { "${dir}" = importFile dir; }))    # => [ { "package1" = <derivation>; } { "package2" = <derivation>; } ... ]
    mergeAttrsList                                 # => { "package1" = <derivation>; "package2" = <derivation>; ... }
  ]
#+end_src

#+begin_src nix :tangle externals/eaf/default.nix
  { package_src
  , elispFileVersion
  , lib
  , stdenv
  , writeText
  , melpaBuild
  , elpa2nix
  , melpa2nix
  , makeWrapper

  , python3
  , qt6

  , withSwayWMSupport ? stdenv.isLinux
  , jq ? null

  , withUnitySupport ? stdenv.isLinux
  , xdotool ? null

  , withX11Support ? true
  , wmctrl ? null
  }: let
    inherit (lib) readFile;
    
    python = python3.withPackages (pkgs: [
      pkgs.easyocr
      pkgs.epc
      pkgs.lxml
      pkgs.pygetwindow
      pkgs.pyqt6
      pkgs.pyqt6-sip
      pkgs.pyqt6-webengine
      pkgs.qrcode
      pkgs.requests
      pkgs.sexpdata
    ]);
  in (melpaBuild (finalAttrs: {
    pname = "eaf";
    version = elispFileVersion "${finalAttrs.src}/eaf.el";
    src = package_src;

    # 在这里添加makeWrapper作为构建依赖
    nativeBuildInputs = [ makeWrapper ];

    patchPhase = ''
      runHook prePatch

      sed -i s#'defcustom eaf-python-command .*'#'defcustom eaf-python-command "${python.interpreter}"'# eaf.el
      ${if withSwayWMSupport then "substituteInPlace eaf.el --replace jq ${jq}/bin/jq" else ""}
      ${if withUnitySupport then "substituteInPlace eaf.el --replace xdotool ${xdotool}/bin/xdotool" else ""}
      ${if withX11Support then "substituteInPlace eaf.el --replace wmctrl ${wmctrl}/bin/wmctrl" else ""}

      mv core/eaf-epc.el .
      mv extension/* .

      runHook postPatch
    '';

    elpa2nix = writeText "elpa2nix.el" ''
      ${readFile elpa2nix}
      (defun byte-recompile-directory (&rest _))
    '';
    melpa2nix = writeText "melpa2nix.el" ''
      ${readFile melpa2nix}
      (defun byte-recompile-directory (&rest _))
    '';
  })).overrideAttrs (old: {
    # 确保nativeBuildInputs被正确继承并添加makeWrapper
    nativeBuildInputs = (old.nativeBuildInputs or []) ++ [ makeWrapper ];
    
    # Override genericBuild's postInstall
    postInstall = ''
      DST=$out/share/emacs/site-lisp/elpa/$ename-$melpaVersion/

      mv eaf.py $DST
      mv applications.json $DST
      mv core $DST

      # 创建包装脚本目录
      mkdir -p $DST/bin

      # 直接创建包装脚本，使用PyQt6模块路径下的Qt库
      QT_LIB_PATH=$(${python}/bin/python -c "import os, PyQt6; print(os.path.join(os.path.dirname(PyQt6.__file__), 'Qt6/lib'))" 2>/dev/null)
      QT_PLUGIN_PATH=$(${python}/bin/python -c "import os, PyQt6; print(os.path.join(os.path.dirname(PyQt6.__file__), 'Qt6/plugins'))" 2>/dev/null)

     # 如果找不到常规路径，尝试其他可能的位置
     if [ ! -d "$QT_LIB_PATH" ] || [ ! -d "$QT_PLUGIN_PATH" ]; then
       QT_BASE_DIR=$(${python}/bin/python -c "import os, sys, PyQt6; print(os.path.normpath(os.path.join(os.path.dirname(PyQt6.__file__), '..', '..')))" 2>/dev/null)
       QT_LIB_PATH="$QT_BASE_DIR/lib"
       QT_PLUGIN_PATH="$QT_BASE_DIR/share/qt6/plugins"
     fi

     # 创建Python包装脚本
     makeWrapper ${python}/bin/python $DST/bin/eaf-python \
       --set LD_LIBRARY_PATH "$QT_LIB_PATH" \
       --set QT_PLUGIN_PATH "$QT_PLUGIN_PATH" \
       --set QT_QPA_PLATFORM_PLUGIN_PATH "$QT_PLUGIN_PATH/platforms" \
       --unset XDG_DATA_DIRS

     # 修改eaf.el使用包装的Python
     sed -i s#'defcustom eaf-python-command .*'#'defcustom eaf-python-command "'$DST/bin/eaf-python'"'# $DST/eaf.el
  '';
  })
#+end_src

#+begin_src nix
  { pkgs }:

  pkgs.stdenv.mkDerivation rec {
    pname = "emacs-application-framework";
    version = "2025-02-26";

    src = pkgs.fetchgit {
      url = "https://github.com/emacs-eaf/${pname}";
      branchName = "Master";
      sha256 = "19mmg79df5ydj2hwbcs3c2pay4b6d16jwgp95s7gv6a129iy80v1";
    };

    installEaf = ''
      mkdir -p $out/share/emacs/site-lisp/${pname}/app
      cp -r ${src}/* $out/share/emacs/site-lisp/${pname}
    '';

    nativeBuildInputs = [
      pkgs.git
      pkgs.python310
    ];

    installPhase = installEaf;

    # 如果需要特定依赖，可以在这里添加
    buildInputs = [
    ];
  }
#+end_src

#+begin_src shell
  cd ${emacsWithPackages}/share/emacs/site-lisp/emacs-application-framework
  chmod +x ./install-eaf.py
  ${pkgs.python310} ./install-eaf.py --app-drop-local-edit -i browser
#+end_src

